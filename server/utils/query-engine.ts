// RECOMPILE TIMESTAMP: 1768888326
/**
 * Query Engine - Comprehensive Natural Language Database Query System
 * Ported from Python with ALL backend logic preserved
 * 
 * Updated to use GPT-5 via direct OpenAI API (August 2025)
 */

import { QueryResponse, ChartConfig, SummaryStats } from "@shared/schema";
import * as fs from 'fs';
import { OpenAIClient, FunctionDefinition } from "./openai-client";
import { SemanticTimeParser, NumberCalculator, ProjectSizeCalculator } from "./query-utils";
import { RAGVectorStore } from "./rag-store";
import { openaiQueue } from "./request-queue";
import { convertPlaceholders, getClientTableName } from "../mssql-db";
import { columnCache } from "./column-cache";

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// CLIENT TABLE CONFIGURATION
// The TABLE constant is resolved from CLIENT_TABLE_NAME environment variable
// All SQL templates use this constant - no hardcoded table names
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
const TABLE = getClientTableName();

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// COLUMN SYNONYM MAPPING SYSTEM
// Maps user-friendly terms to actual database column names
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

const COLUMN_SYNONYMS: Record<string, string[]> = {
  // Financial columns (including plurals and abbreviations)
  // Excel: Fee
  "Fee": ["cost", "costs", "revenue", "revenues", "rev", "price", "prices", "value", "values", "amount", "amounts", "budget", "budgets", "contract value", "project value", "deal value", "contract amount", "project cost", "total cost", "total value", "dollar amount", "dollars", "money", "fees", "sales", "sale", "income"],
  
  // Win rate columns (including win% without space and probability)
  // Excel: ChanceOfSuccess
  "ChanceOfSuccess": ["win rate", "win rates", "success rate", "win percentage", "close rate", "conversion rate", "hit rate", "win ratio", "success ratio", "closure rate", "win%", "win percent", "win %", "probability", "prob", "likelihood", "chance", "odds", "win probability", "chanceofsuccess", "chance of success"],
  
  // Location columns
  // Excel: State (was State)
  "State": ["state", "states", "location", "locations", "geography", "area", "areas", "territory", "territories", "market", "markets", "geo", "statelookup"],
  
  // Category columns
  // Excel: RequestCategory
  "RequestCategory": ["category", "categories", "type", "types", "sector", "sectors", "industry", "industries", "vertical", "verticals", "segment", "segments", "market segment", "request type", "request category", "requestcategory"],
  
  // Project Type column (distinct from Request Category)
  // Excel: ProjectType
  "ProjectType": ["project type", "project types", "proj type", "ptype", "projecttype"],
  
  // Organization columns
  
  // Service Type column (distinct from Project Type)
  // Excel: ServiceType
  "ServiceType": ["service type", "service types", "servicetype", "service", "services", "service category", "service line", "service offering"],

  // Excel: Company (was Company)
  "Company": ["company", "companies", "firm", "firms", "organization", "organizations", "business", "businesses", "contractor", "contractors", "vendor", "vendors", "provider", "providers", "our company", "internal company", "companylookup", "company lookup"],
  // Excel: Client (was Client)
  "Client": ["client", "clients", "customer", "customers", "account", "accounts", "buyer", "buyers", "owner", "owners", "client name", "customer name", "project owner", "crmcompanylookup", "crm company lookup", "crm company", "crmcompanytitle"],
  
  // People columns
  // Excel: PointOfContact
  "PointOfContact": ["poc", "point of contact", "contact", "contacts", "sales rep", "sales reps", "representative", "representatives", "account manager", "account managers", "salesperson", "rep", "reps", "sales person", "project manager", "pm", "pms", "point of contacts", "pointofcontact"],
  
  // Date columns
  // Excel: ConstStartDate
  "ConstStartDate": ["date", "dates", "start", "started", "began", "commenced", "project date", "start time", "beginning", "initiation date", "start date", "created", "created date", "quarter", "quarters", "year", "years", "month", "months", "conststartdate", "const start date", "construction start date"],
  
  // Status columns
  // Excel: StatusChoice
  "StatusChoice": ["status", "statuses", "stage", "stages", "phase", "phases", "current status", "project status", "deal status", "pipeline status", "pipeline stage", "statuschoice", "status choice"],
  
  // Project identification
  // Excel: Title
  "Title": ["project", "projects", "project name", "name", "names", "title", "titles", "deal", "deals", "opportunity", "opportunities", "deal name"],
  "PID": ["pid", "pids", "project id", "id", "identifier", "identifiers", "project number", "deal id"],
  
  // Tags
  
  // Group/Module columns
  "Group": ["group", "groups", "grouping", "team", "teams"],
  // Excel: ModuleName
  "ModuleName": ["module", "modules", "module name", "source", "sources", "modulename"],
  
  // Division column (organizational unit)
  // Excel: Division
  "Division": ["division", "divisions", "business unit", "business units", "bu", "bus"],
  
  // Department column (organizational department)
  // Excel: Department
  "Department": ["department", "departments", "dept", "depts", "unit", "units"],
  
  // Size (virtual column for filtering)
  "size": ["size", "sizes", "project size", "deal size", "small", "medium", "large"],
  
  // Office/Location
  "Office": ["office", "offices", "branch", "branches", "location office"],
  
  // Description
  // Excel: Description (same)
  "Description": ["description", "descriptions", "desc", "details", "notes", "summary", "overview"],
  
  // Email
  "Email": ["email", "emails", "email address", "e-mail"],
  
  // LP/Conflict/Co Op flags
  "LP": ["lp", "limited partner", "limited partnership"],
  "Conflict": ["conflict", "conflicts", "conflict of interest"],
  "CoOp": ["co op", "coop", "co-op", "cooperative", "cooperation"],
  
  // Group Criteria
  "GroupCriteria": ["group criteria", "criteria", "grouping criteria"],
  
  // Internal Id
  // Excel: InternalId
  "InternalId": ["internal id", "internalid", "internal identifier"],
  
  // Is Updated flag
  // Excel: IsUpdated
  "IsUpdated": ["is updated", "isupdated", "updated", "updated flag"],
};

// Create reverse lookup: synonym -> canonical column name
const SYNONYM_TO_COLUMN: Record<string, string> = {};
for (const [column, synonyms] of Object.entries(COLUMN_SYNONYMS)) {
  for (const synonym of synonyms) {
    SYNONYM_TO_COLUMN[synonym.toLowerCase()] = column;
  }
  // Also add the column name itself (lowercase)
  SYNONYM_TO_COLUMN[column.toLowerCase()] = column;
}

/**
 * Normalize column references in user query
 * Replaces user-friendly column synonyms with canonical database column names
 * Used for sort_field, group_by, and other column-referencing arguments
 */
function normalizeColumnReference(value: string): string {
  const lowerValue = value.toLowerCase().trim();
  return SYNONYM_TO_COLUMN[lowerValue] || value;
}

/**
 * Normalize all column references in classification arguments
 * Handles sort_field, group_by, column, field, metric, breakdown_column arguments
 * Also handles arrays of columns (e.g., columns in select_specific_columns)
 */


// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// HALLUCINATION GUARD: Strip state/region parameters not mentioned in query
// This prevents AI from adding random geography filters like "Colorado" when
// the user never mentioned any location
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// STATE NAME NORMALIZATION HELPER: Convert common misspellings/variations to database values
function normalizeStateName(value: string): string {
  const stateNormMap: Record<string, string> = {
    // US States
    'newyork': 'New York', 'ny': 'New York',
    'california': 'California', 'ca': 'California',
    'texas': 'Texas', 'tx': 'Texas',
    'florida': 'Florida', 'fl': 'Florida',
    // Indian States - common misspellings
    'maharashtra': 'Maharashtra', 'mahastra': 'Maharashtra', 'maharastra': 'Maharashtra', 'mahrastra': 'Maharashtra',
    'karnataka': 'Karnataka', 'karnatak': 'Karnataka', 'kernataka': 'Karnataka',
    'tamilnadu': 'Tamil Nadu', 'tamil': 'Tamil Nadu',
    'andhrapradesh': 'Andhra Pradesh', 'andhra': 'Andhra Pradesh', 'ap': 'Andhra Pradesh',
    'telangana': 'Telangana', 'telengana': 'Telangana',
    'westbengal': 'West Bengal', 'bengal': 'West Bengal', 'wb': 'West Bengal',
    'madhyapradesh': 'Madhya Pradesh', 'mp': 'Madhya Pradesh',
    'uttarpradesh': 'Uttar Pradesh', 'up': 'Uttar Pradesh',
    'rajasthan': 'Rajasthan', 'rajsthan': 'Rajasthan',
    'gujarat': 'Gujarat', 'gujrat': 'Gujarat', 'gj': 'Gujarat',
    'kerala': 'Kerala', 'kerela': 'Kerala',
    'punjab': 'Punjab', 'panjab': 'Punjab',
    'haryana': 'Haryana', 'hariyana': 'Haryana',
    'delhi': 'Delhi', 'newdelhi': 'New Delhi',
    'mumbai': 'Mumbai', 'bombay': 'Mumbai',
    'bangalore': 'Bangalore', 'bengaluru': 'Bangalore',
    'chennai': 'Chennai', 'madras': 'Chennai',
    'kolkata': 'Kolkata', 'calcutta': 'Kolkata',
    'hyderabad': 'Hyderabad', 'hydrabad': 'Hyderabad',
  };
  const normalized = stateNormMap[value.toLowerCase().replace(/\s+/g, '')];
  if (normalized) {
    console.log(`[StateNorm] Normalized "${value}" â†’ "${normalized}"`);
    return normalized;
  }
  return value;
}

function stripHallucinatedGeography(args: Record<string, any>, originalQuestion: string): Record<string, any> {
  if (!args || !originalQuestion) return args;
  
  // SKIP stripping when disambiguation was applied - user explicitly selected a column
  if (args._disambiguation_column) {
    console.log(`[StripGeo] â­ï¸ SKIPPING - disambiguation applied: ${args._disambiguation_column}`);
    return args;
  }
  
  // SKIP stripping when HeadChef already validated geo entities
  if (args._states_already_applied || args._regions_already_applied || args._countries_already_applied) {
    console.log(`[StripGeo] â­ï¸ SKIPPING - geo entity already validated by HeadChef`);
    return args;
  }
  
  const questionLower = originalQuestion.toLowerCase();
  
  // Full US state names (lowercase for case-insensitive matching)
  const US_STATE_NAMES = [
    'alabama', 'alaska', 'arizona', 'arkansas', 'california', 'colorado', 'connecticut',
    'delaware', 'florida', 'georgia', 'hawaii', 'idaho', 'illinois', 'indiana', 'iowa',
    'kansas', 'kentucky', 'louisiana', 'maine', 'maryland', 'massachusetts', 'michigan',
    'minnesota', 'mississippi', 'missouri', 'montana', 'nebraska', 'nevada', 'new hampshire',
    'new jersey', 'new mexico', 'new york', 'north carolina', 'north dakota', 'ohio',
    'oklahoma', 'oregon', 'pennsylvania', 'rhode island', 'south carolina', 'south dakota',
    'tennessee', 'texas', 'utah', 'vermont', 'virginia', 'washington', 'west virginia',
    'wisconsin', 'wyoming', 'district of columbia'
  ];
  
  // Two-letter state abbreviations (UPPERCASE - these must appear uppercase in the original question)
  const US_STATE_CODES = [
    'AL', 'AK', 'AZ', 'AR', 'CA', 'CO', 'CT', 'DE', 'FL', 'GA', 'HI', 'ID', 'IL', 'IN',
    'IA', 'KS', 'KY', 'LA', 'ME', 'MD', 'MA', 'MI', 'MN', 'MS', 'MO', 'MT', 'NE', 'NV',
    'NH', 'NJ', 'NM', 'NY', 'NC', 'ND', 'OH', 'OK', 'OR', 'PA', 'RI', 'SC', 'SD', 'TN',
    'TX', 'UT', 'VT', 'VA', 'WA', 'WV', 'WI', 'WY', 'DC'
  ];
  
  // Region keywords
  const REGIONS = ['west', 'east', 'north', 'south', 'midwest', 'northeast', 'southeast', 
                   'southwest', 'northwest', 'pacific', 'mountain', 'central', 'gulf', 
                   'atlantic', 'mena', 'uae', 'middle east',
                   // International regions
                   'europe', 'asia', 'africa', 'oceania', 'canada', 'latin america',
                   'sub-saharan', 'sub-saharan africa', 'south east asia', 'central asia',
                   'hong kong', 'singapore', 'caribbean', 'pacific islands'];
  
  // Check for full state names (case-insensitive)
  const mentionsStateName = US_STATE_NAMES.some(state => {
    const regex = new RegExp('\\b' + state.replace(/\s+/g, '\\s+') + '\\b', 'i');
    return regex.test(questionLower);
  });
  
  // Check for state codes (MUST be uppercase in original question, not part of "Co." or "Inc.")
  // Requires uppercase code followed by word boundary, NOT preceded by common company suffixes
  const mentionsStateCode = US_STATE_CODES.some(code => {
    // Match standalone uppercase code: word boundary, code, then end/space/comma/punctuation
    // Avoid matching "Co." in company names by requiring it's not preceded by "&" or followed by "."
    const regex = new RegExp('(?<!&\\s?)\\b' + code + '(?!\\.)\\b');
    return regex.test(originalQuestion);
  });
  
  const mentionsRegion = REGIONS.some(region => {
    const regex = new RegExp('\\b' + region + '\\b', 'i');
    return regex.test(questionLower);
  });
  
  // If no geography mentioned, strip all state/region parameters
  if (!mentionsStateName && !mentionsStateCode && !mentionsRegion) {
    const stripped: string[] = [];
    if (args.state_code) { stripped.push('state_code'); delete args.state_code; }
    if (args.state) { stripped.push('state'); delete args.state; }
  // Add debug info to args
    if (args.states) { stripped.push('states'); delete args.states; }
    if (args.region) { stripped.push('region'); delete args.region; }
    if (args.regions) { stripped.push('regions'); delete args.regions; }
    
    if (stripped.length > 0) {
      console.log('[HallucinationGuard] Stripped geography params not in question: ' + stripped.join(', '));
    }
  }
  
  return args;
}

function normalizeClassificationArguments(args: Record<string, any>, originalQuestion?: string): Record<string, any> {
  console.log(`[Normalize] ENTRY: args=${JSON.stringify(args)}`);
  // Debug flag removed
  if (!args) return args;
  
  // Single-value column arguments
  const singleColumnArgs = ['sort_field', 'group_by', 'column', 'field', 'metric', 'breakdown_column'];
  // Array column arguments (e.g., columns: ["Fee", "Client"])
  const arrayColumnArgs = ['columns', 'select_columns', 'fields'];
  
  const normalized = { ...args };
  
  // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  // PARAMETER NAME NORMALIZATION: Standardize all parameter name variations
  // This ensures SQL clause handlers always find the expected parameter names
  // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  
  // 1. Category normalization: categories_purchased, categories â†’ category + categories
  // Keep both single and array forms for different clause handlers
  if (normalized.categories_purchased && !normalized.category) {
    if (Array.isArray(normalized.categories_purchased)) {
      normalized.category = normalized.categories_purchased[0]; // Single for simple handlers
      normalized.categories = normalized.categories_purchased;   // Array for multi-category handlers
      console.log(`[Normalize] categories_purchased â†’ category: "${normalized.category}", categories:`, normalized.categories);
    } else {
      normalized.category = normalized.categories_purchased;
      normalized.categories = [normalized.categories_purchased];
      console.log(`[Normalize] categories_purchased â†’ category: "${normalized.category}"`);
    }
  }
  if (normalized.categories && !normalized.category) {
    if (Array.isArray(normalized.categories)) {
      normalized.category = normalized.categories[0]; // Single for simple handlers
      console.log(`[Normalize] categories[0] â†’ category: "${normalized.category}"`);
    } else {
      normalized.category = normalized.categories;
      normalized.categories = [normalized.categories];
      console.log(`[Normalize] categories â†’ category: "${normalized.category}"`);
    }
  }
  
  // 2. State normalization: state_code, state â†’ states (array for SQL)
  if (normalized.state_code && !normalized.states) {
    normalized.states = Array.isArray(normalized.state_code) 
      ? normalized.state_code 
      : [normalized.state_code];
    console.log(`[Normalize] state_code â†’ states:`, normalized.states);
  }
  if (normalized.state && !normalized.states) {
    normalized.states = Array.isArray(normalized.state) 
      ? normalized.state 
      : [normalized.state];
    console.log(`[Normalize] state â†’ states:`, normalized.states);
  }
  
  // 3. Client normalization: ensure client is properly formatted
  // NOTE: Client and Company are DIFFERENT entities - do NOT convert client to company!
  // - Client = customer/buyer (e.g., "Client 5057")
  // - Company = internal company (e.g., "Company A")
  if (normalized.client && Array.isArray(normalized.client)) {
    // If client is an array with single value, extract to string for simpler SQL handling
    if (normalized.client.length === 1) {
      normalized.client = normalized.client[0];
      console.log(`[Normalize] client[0] â†’ client: "${normalized.client}"`);
    } else {
      // Keep as array for multi-client queries
      console.log(`[Normalize] client array:`, normalized.client);
    }
  }
  // Also ensure company is always a string, not an array
  if (normalized.company && Array.isArray(normalized.company)) {
    if (normalized.company.length > 1 && !normalized.companies) {
      normalized.companies = normalized.company;
    }
    normalized.company = normalized.company[0];
    console.log(`[Normalize] company array â†’ single: "${normalized.company}"`);
  }

  // CLIENT TO ORGANIZATION CONVERSION: If client value is not an ID, move to organization
  // This handles cases like "show projects for google client" where AI extracts client: "google client"
  // but "google" should search both Client and Company columns via organization filter
  // EXCEPTION: Organization names found in Client column (e.g., "Abu Dhabi Airports Company") should stay as client
  if (normalized.client && typeof normalized.client === 'string' && !normalized.organization && !normalized._client_already_applied && !normalized._smart_detection_done) {
    const clientValue = normalized.client.trim();
    // Check if it looks like a Client ID (contains digits or starts with "Client ")
    const looksLikeClientId = /\d/.test(clientValue) || /^Client\s+/i.test(clientValue);
    
    // Check if it's an organization name (which should STAY as client if found in Client column)
    const orgIndicatorsPattern = /\b(company|corporation|corp|inc|llc|ltd|group|authority|agency|district|foundation|hospital|airports|university|college|school|transit|metro|mta|port|center|institute|department|office|service|board|commission)\b/i;
    const isOrganizationName = orgIndicatorsPattern.test(clientValue);
    
    // Check if this is a geographic entity name that should be preserved for disambiguation
    // Geographic entities need to go through detectAllMatchingColumns later
    const geoPatterns = /^(city|town|county|state|village|municipality|borough|port|metro|district)/i;
    // Only detect as geographic entity if explicitly starts with geographic keywords
    // Do NOT treat single-word company names like "Google" or "LiRo" as geographic
    const isGeographicEntity = geoPatterns.test(clientValue);
    
    console.log(`[Normalize DEBUG] clientValue="${clientValue}", looksLikeClientId=${looksLikeClientId}, isOrganizationName=${isOrganizationName}, isGeographicEntity=${isGeographicEntity}, _client_already_applied=${normalized._client_already_applied}`);
    // CRITICAL: If _client_already_applied is set, user explicitly chose Client column - do NOT convert to organization
    if (!looksLikeClientId && !isOrganizationName && !isGeographicEntity && !normalized._client_already_applied) {
      // Not an ID, not an organization name, and not a geographic entity - move to organization
      // Remove trailing "client" word if present (e.g., "google client" â†’ "google")
      let orgName = clientValue.replace(/\s+client$/i, '').trim();
      if (orgName) {
        normalized.organization = orgName;
        console.log(`[Normalize] âš ï¸ client "${clientValue}" is not an ID, moved to organization: "${orgName}"`);
      }
      delete normalized.client;
    } else if (normalized._client_already_applied) {
      console.log(`[Normalize] âœ“ Client preserved (disambiguation selected): "${clientValue}"`);
    } else if (isGeographicEntity) {
      // Preserve geographic entity for disambiguation
      console.log(`[Normalize] ğŸ“ Geographic entity preserved in client: "${clientValue}" (will be disambiguated later)`);
    } else if (isOrganizationName) {
      // Keep organization names in client - they were found in the Client column
      console.log(`[Normalize] âœ“ Organization name preserved in client: "${clientValue}"`);
    }
  }
  
  // 4. POC normalization: poc_name, poc â†’ poc
  if (normalized.poc_name && !normalized.poc) {
    normalized.poc = normalized.poc_name;
    console.log(`[Normalize] poc_name â†’ poc: "${normalized.poc}"`);
  }
  
  // 5. Status normalization: status_value â†’ status (clause handler reads args.status)
  if (normalized.status_value && !normalized.status) {
    // Keep as array if multiple, or single value
    normalized.status = normalized.status_value;
    console.log(`[Normalize] status_value â†’ status:`, normalized.status);
  }
  if (normalized.statuses && !normalized.status) {
    normalized.status = normalized.statuses;
    console.log(`[Normalize] statuses â†’ status:`, normalized.status);
  }
  
  // GUARD: Fix LLM-sent status - handle both string and array values
  // CRITICAL: Convert "open", "closed", "won", "lost", "pending" etc. to correct status arrays BEFORE any other processing
  // These are execution-based synonyms verified against actual database values
  const OPEN_STATUS_VALUES = ["Proposal Development", "Qualified Lead", "Submitted", "Won", "Lead", "In Progress", "Hold"];
  const CLOSED_STATUS_VALUES = ["Lost", "No Go", "Cancelled"];
  const WON_STATUS_VALUES = ["Won", "Awarded", "Accepted"];
  const LOST_STATUS_VALUES = ["Lost", "Declined", "Rejected", "No Go"];
  const PENDING_STATUS_VALUES = ["Pending", "In Review", "Under Consideration", "Submitted"];
  
  if (normalized.status && typeof normalized.status === 'string') {
    const statusLower = normalized.status.toLowerCase().trim();
    // Use cache-backed resolution with fallback to hardcoded values
    // columnCache.resolveStatus returns actual database values
    const cacheResolved = columnCache.isReady() ? columnCache.resolveStatus(statusLower) : null;
    
    // Convert "open" and synonyms to all open statuses
    if (statusLower === 'open' || statusLower === 'active' || statusLower === 'ongoing' || statusLower === 'current') {
      console.log(`[Normalize] STATUS EXPANSION: "${normalized.status}" â†’ all open statuses`);
      normalized.status = OPEN_STATUS_VALUES;
    }
    // Convert "closed" and synonyms to all closed statuses
    else if (statusLower === 'closed' || statusLower === 'completed' || statusLower === 'finished') {
      console.log(`[Normalize] STATUS EXPANSION: "${normalized.status}" â†’ all closed statuses`);
      normalized.status = CLOSED_STATUS_VALUES;
    }
    // Convert "won" and synonyms to won statuses
    else if (statusLower === 'won' || statusLower === 'awarded' || statusLower === 'accepted') {
      console.log(`[Normalize] STATUS EXPANSION: "${normalized.status}" â†’ all won statuses`);
      normalized.status = WON_STATUS_VALUES;
    }
    // Convert "lost" and synonyms to lost statuses
    else if (statusLower === 'lost' || statusLower === 'declined' || statusLower === 'rejected') {
      console.log(`[Normalize] STATUS EXPANSION: "${normalized.status}" â†’ all lost statuses`);
      normalized.status = LOST_STATUS_VALUES;
    }
    // Convert "pending" and synonyms to pending statuses
    else if (statusLower === 'pending' || statusLower === 'waiting' || statusLower === 'in review' || statusLower === 'under review') {
      console.log(`[Normalize] STATUS EXPANSION: "${normalized.status}" â†’ all pending statuses`);
      normalized.status = PENDING_STATUS_VALUES;
    }
    // Fallback: Try cache-based resolution for unknown status synonyms
    else if (cacheResolved && cacheResolved.length > 0 && cacheResolved[0] !== statusLower) {
      console.log(`[Normalize] CACHE-BACKED STATUS: "${normalized.status}" â†’ ${JSON.stringify(cacheResolved)}`);
      normalized.status = cacheResolved;
    }
  }
  
  // FALLBACK: If status is empty/missing but question contains status keywords, extract from question
  if (originalQuestion && (!normalized.status || (Array.isArray(normalized.status) && normalized.status.length === 0))) {
    const questionLower = originalQuestion.toLowerCase();
    if (/\b(open|active|ongoing|current|which are open|are open)\b/i.test(questionLower)) {
      console.log(`[Normalize] STATUS FALLBACK: Detected "open" in question, setting open statuses`);
      normalized.status = OPEN_STATUS_VALUES;
    } else if (/\b(closed|completed|finished|closed out)\b/i.test(questionLower)) {
      console.log(`[Normalize] STATUS FALLBACK: Detected "closed" in question, setting closed statuses`);
      normalized.status = CLOSED_STATUS_VALUES;
    } else if (/\b(won|awarded|accepted)\b/i.test(questionLower)) {
      console.log(`[Normalize] STATUS FALLBACK: Detected "won" in question, setting won statuses`);
      normalized.status = WON_STATUS_VALUES;
    } else if (/\b(lost|declined|rejected)\b/i.test(questionLower)) {
      console.log(`[Normalize] STATUS FALLBACK: Detected "lost" in question, setting lost statuses`);
      normalized.status = LOST_STATUS_VALUES;
    }
  }

  // GUARD: Fix LLM-sent status arrays that may have wrong open/closed mappings
  if (normalized.status && Array.isArray(normalized.status)) {
    // FIX: If question says "open" but LLM returned a subset of open statuses, expand to all
    const hasOpenKeyword = originalQuestion && /\bopen\b/i.test(originalQuestion);
    if (hasOpenKeyword) {
      const openLower = new Set(OPEN_STATUS_VALUES.map(s => s.toLowerCase()));
      const allAreOpen = normalized.status.every(s => openLower.has(s.toLowerCase()));
      if (allAreOpen && normalized.status.length < OPEN_STATUS_VALUES.length) {
        console.log(`[Normalize] STATUS FIX: Question asked for "open" but LLM returned subset; expanding to all open statuses`);
        normalized.status = OPEN_STATUS_VALUES;
      }
    }
    const statusArray = normalized.status.map((s: string) => s.toLowerCase());
    // If status array contains "pursuing" or "dormant" (old open definition), fix it
    if (statusArray.some((s: string) => s === "pursuing" || s === "dormant")) {
      normalized.status = ["Proposal Development", "Qualified Lead", "Submitted", "Won", "Lead", "In Progress", "Hold"];
      console.log(`[Normalize] STATUS FIX: Replaced old "open" array with correct statuses`);
    }
    // If status array contains both "won" and "lost" (old closed definition), fix it
    else if (statusArray.includes("won") && statusArray.includes("lost") && !statusArray.includes("proposal development")) {
      normalized.status = ["Lost", "No Go", "Cancelled"];
      console.log(`[Normalize] STATUS FIX: Replaced old "closed" (Won+Lost) with correct statuses`);
    }
    // STATUS CAPITALIZATION: Normalize case-insensitive status values to proper capitalization
    else {
      const STATUS_MAP: Record<string, string> = {
        'won': 'Won', 'lost': 'Lost', 'lead': 'Lead', 'submitted': 'Submitted',
        'in progress': 'In Progress', 'proposal development': 'Proposal Development',
        'qualified lead': 'Qualified Lead', 'hold': 'Hold', 'no go': 'No Go', 'cancelled': 'Cancelled'
      };
      const capitalizedStatus = normalized.status.map((s: string) => {
        const lower = s.toLowerCase();
        return STATUS_MAP[lower] || s;
      });
      if (JSON.stringify(capitalizedStatus) !== JSON.stringify(normalized.status)) {
        console.log(`[Normalize] STATUS CAPITALIZATION: ${JSON.stringify(normalized.status)} â†’ ${JSON.stringify(capitalizedStatus)}`);
        normalized.status = capitalizedStatus;
      }
    }
  }
  
  // 6. Fee normalization: fee â†’ min_fee or max_fee based on context
  if (normalized.fee && typeof normalized.fee === 'number') {
    if (!normalized.min_fee && !normalized.max_fee) {
      // If just "fee" is provided, treat as exact match range
      normalized.min_fee = normalized.fee;
      normalized.max_fee = normalized.fee;
      console.log(`[Normalize] fee â†’ min_fee/max_fee: ${normalized.fee}`);
    }
  }
  
  // 7. Limit normalization: count, top, number â†’ limit
  if (normalized.count && !normalized.limit) {
    normalized.limit = normalized.count;
    console.log(`[Normalize] count â†’ limit: ${normalized.limit}`);
  }
  if (normalized.top && !normalized.limit) {
    normalized.limit = normalized.top;
    console.log(`[Normalize] top â†’ limit: ${normalized.limit}`);
  }
  if (normalized.number && !normalized.limit) {
    normalized.limit = normalized.number;
    console.log(`[Normalize] number â†’ limit: ${normalized.limit}`);
  }
  
  // 7b. Extract numeric limit from question text if not already set
  // Handles queries like "smallest 3 projects", "top 5 largest", "bottom 10"
  if (!normalized.limit && originalQuestion) {
    const limitPatterns = [
      /\b(?:top|bottom|first|last|smallest|largest|biggest|cheapest)\s+(\d+)\b/i,
      /\b(\d+)\s+(?:top|bottom|first|last|smallest|largest|biggest|cheapest)\b/i,
      /\bshow\s+(?:me\s+)?(\d+)\b/i,
      /\bget\s+(\d+)\b/i,
      /\blist\s+(\d+)\b/i,
    ];
    
    for (const pattern of limitPatterns) {
      const match = originalQuestion.match(pattern);
      if (match && match[1]) {
        const extractedLimit = parseInt(match[1], 10);
        if (extractedLimit > 0 && extractedLimit <= 1000) {
          normalized.limit = extractedLimit;
          console.log(`[Normalize] Extracted limit from question: "${originalQuestion}" â†’ limit: ${extractedLimit}`);
          break;
        }
      }
    }
  }
  
  // 8. Project type normalization: project_types â†’ project_type
  if (normalized.project_types && !normalized.project_type) {
    const typeValue = Array.isArray(normalized.project_types) 
      ? normalized.project_types[0] 
      : normalized.project_types;
    normalized.project_type = typeValue;
    console.log(`[Normalize] project_types â†’ project_type: "${typeValue}"`);
  }
  
  // 9. Division normalization: division_name, divisions â†’ division + divisions
  // Keep both single and array forms for different clause handlers
  if (normalized.division_name && !normalized.division) {
    normalized.division = normalized.division_name;
    console.log(`[Normalize] division_name â†’ division: "${normalized.division}"`);
  }
  if (normalized.divisions && !normalized.division) {
    if (Array.isArray(normalized.divisions) && normalized.divisions.length > 0) {
      normalized.division = normalized.divisions[0]; // Single for simple handlers
      console.log(`[Normalize] divisions[0] â†’ division: "${normalized.division}"`);
    } else if (typeof normalized.divisions === 'string') {
      normalized.division = normalized.divisions;
      normalized.divisions = [normalized.divisions];
      console.log(`[Normalize] divisions (string) â†’ division: "${normalized.division}"`);
    }
  }
  // Ensure divisions array exists if division is set (for multi-division handlers)
  if (normalized.division && !normalized.divisions) {
    normalized.divisions = Array.isArray(normalized.division) 
      ? normalized.division 
      : [normalized.division];
    if (Array.isArray(normalized.division)) {
      normalized.division = normalized.division[0];
    }
    console.log(`[Normalize] division â†’ divisions:`, normalized.divisions);
  }
  
  // 10. Department normalization: department_name, departments â†’ department + departments
  if (normalized.department_name && !normalized.department) {
    normalized.department = normalized.department_name;
    console.log(`[Normalize] department_name â†’ department: "${normalized.department}"`);
  }
  if (normalized.departments && !normalized.department) {
    if (Array.isArray(normalized.departments) && normalized.departments.length > 0) {
      normalized.department = normalized.departments[0]; // Single for simple handlers
      console.log(`[Normalize] departments[0] â†’ department: "${normalized.department}"`);
    } else if (typeof normalized.departments === 'string') {
      normalized.department = normalized.departments;
      normalized.departments = [normalized.departments];
      console.log(`[Normalize] departments (string) â†’ department: "${normalized.department}"`);
    }
  }
  // Ensure departments array exists if department is set
  if (normalized.department && !normalized.departments) {
    normalized.departments = Array.isArray(normalized.department) 
      ? normalized.department 
      : [normalized.department];
    if (Array.isArray(normalized.department)) {
      normalized.department = normalized.department[0];
    }
    console.log(`[Normalize] department â†’ departments:`, normalized.departments);
  }
  
  // 11. PROJECT TYPE CORRECTION: When AI incorrectly sets categories for known project types
  // (e.g., "government projects" â†’ categories: ["Government"] when it should be project_type: "Government")
  // This happens because the AI doesn't know that "Government" is a ProjectType column value, not RequestCategory.
  const PROJECT_TYPE_VALUES = new Set([
    'government', 'governmental', 'gov', 'govt',
    'civic', 'city hall', 'courthouse',
    'airports', 'airport', 'aviation',
    'hospitals', 'hospital', 'healthcare',
    'bridges', 'bridge',
    'transit', 'rail', 'railway', 'subway',
    'higher education', 'university', 'college',
    'k-12', 'school', 'schools',
    'corrections', 'prison', 'jail',
    'energy', 'solar', 'renewable',
    'industrial', 'manufacturing', 'warehouse',
    'waterfront', 'port', 'marina',
    'multi-family', 'multifamily', 'apartment',
    'mixed use', 'mixed-use',
    'office', 'commercial office',
    'parking', 'parking garage',
    'retail', 'shopping', 'mall',
    'sports', 'stadium', 'arena',
    'water', 'wastewater', 'sewer'
  ]);
  
  // Map from lowercase keyword to proper ProjectType value
  const KEYWORD_TO_PROJECT_TYPE_MAP: Record<string, string> = {
    'government': 'Government', 'governmental': 'Government', 'gov': 'Government', 'govt': 'Government',
    'civic': 'Civic', 'city hall': 'Civic', 'courthouse': 'Civic',
    'airport': 'Airports', 'airports': 'Airports', 'aviation': 'Airports',
    'hospital': 'Hospitals', 'hospitals': 'Hospitals', 'healthcare': 'Hospitals',
    'bridge': 'Bridges', 'bridges': 'Bridges',
    'road': 'Road/Highway', 'roads': 'Road/Highway', 'highway': 'Road/Highway', 'highways': 'Road/Highway', 'road/highway': 'Road/Highway', 'transportation': 'Transportation',
  };
  
  // NORMALIZE PROJECT_TYPE: If project_type is set but not a valid database value, try to map it
  if (normalized.project_type && typeof normalized.project_type === "string") {
    const ptLower = String(normalized.project_type).toLowerCase();
    // Check each word in compound values like "Road/Highway"
    const words = ptLower.split(/[\/\s]+/);
    for (const word of words) {
      if (KEYWORD_TO_PROJECT_TYPE_MAP[word]) {
        console.log(`[Normalize] PROJECT_TYPE KEYWORD MAP: "${normalized.project_type}" â†’ "${KEYWORD_TO_PROJECT_TYPE_MAP[word]}"`);
        normalized.project_type = KEYWORD_TO_PROJECT_TYPE_MAP[word];
        break;
      }
    }
  }
  
  console.log(`[Normalize] PROJECT TYPE CHECK: _explicit_category=${normalized._explicit_category}, categories=${JSON.stringify(normalized.categories)}, project_type=${normalized.project_type}`);
  // GUARD: If BOTH project_type AND categories are set with the same value, delete categories
  if (normalized.project_type && normalized.categories) {
    const catValue = Array.isArray(normalized.categories) ? normalized.categories[0] : normalized.categories;
    const catLower = String(catValue).toLowerCase();
    const ptLower = String(normalized.project_type).toLowerCase();
    if (catLower === ptLower || catLower.includes(ptLower) || ptLower.includes(catLower)) {
      console.log(`[Normalize] ğŸ§¹ DUPLICATE CLEANUP: Deleting categories="${catValue}" (same as project_type="${normalized.project_type}")`);
      delete normalized.categories;
      delete normalized.category;
      normalized._project_type_explicit = true;
    }
  }
  // Debug flag removed
  if (normalized._explicit_category && normalized.categories && !normalized.project_type) {
    const catValue = Array.isArray(normalized.categories) ? normalized.categories[0] : normalized.categories;
    const catLower = String(catValue).toLowerCase();
    
    // Check if this is actually a project type value, not a real category
    // Debug flag removed
    if (PROJECT_TYPE_VALUES.has(catLower) || KEYWORD_TO_PROJECT_TYPE_MAP[catLower]) {
      const properProjectType = KEYWORD_TO_PROJECT_TYPE_MAP[catLower] || catValue;
      console.log(`[Normalize] ğŸ”§ PROJECT TYPE FIX: Moving "${catValue}" from categories to project_type="${properProjectType}" (AI incorrectly classified as category)`);
      
      // Move to project_type and clear category flags
      normalized.project_type = properProjectType;
      normalized._normalize_project_type_fix = true;
      delete normalized.category;
      delete normalized.categories;
      delete normalized._explicit_category;
    }
  }
  
  // 12. SECTOR/CATEGORY CONFLICT RESOLUTION: When user says "sector" or "category",
  // we should ONLY filter by Request Category column, NOT Project Type column.
  // The LLM sometimes sets BOTH args.category/categories AND args.project_type to the same value
  // (e.g., "Aviation sector" â†’ categories: ["Aviation"], project_type: "Aviation")
  // This causes double-filtering that reduces results. Clear project_type in this case.
  if (normalized._explicit_category && normalized.project_type && !normalized._project_type_explicit) {
    // Get category value from either category (string) or categories (array)
    const categoryValue = normalized.category 
      || (Array.isArray(normalized.categories) && normalized.categories[0]) 
      || null;
    
    if (categoryValue) {
      // Clear project_type if it matches category (redundant filter)
      const catLower = String(categoryValue).toLowerCase();
      const ptLower = String(normalized.project_type).toLowerCase();
      if (catLower === ptLower || catLower.includes(ptLower) || ptLower.includes(catLower)) {
        console.log(`[Normalize] ğŸ“‚ SECTOR FIX: Clearing redundant project_type="${normalized.project_type}" (user said "sector/category", using only Request Category: "${categoryValue}")`);
        delete normalized.project_type;
        delete normalized.project_types;
        delete normalized._project_type_already_applied;
      }
    } else {
      // If _explicit_category is set but no category value, move project_type to category
      normalized.category = normalized.project_type;
      normalized.categories = [normalized.project_type];
      console.log(`[Normalize] ğŸ“‚ SECTOR FIX: Moving project_type="${normalized.project_type}" â†’ category (user said "sector/category")`);
      delete normalized.project_type;
      delete normalized.project_types;
      delete normalized._project_type_already_applied;
    }
  }
  
  // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  // COLUMN REFERENCE NORMALIZATION: Map user terms to actual column names
  // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  
  // Normalize single-value column arguments
  for (const argName of singleColumnArgs) {
    if (normalized[argName] && typeof normalized[argName] === 'string') {
      const original = normalized[argName];
      normalized[argName] = normalizeColumnReference(normalized[argName]);
      if (original !== normalized[argName]) {
        console.log(`[QueryEngine] Column synonym: "${original}" â†’ "${normalized[argName]}"`);
      }
    }
  }
  
  // Normalize array column arguments
  for (const argName of arrayColumnArgs) {
    if (normalized[argName] && Array.isArray(normalized[argName])) {
      normalized[argName] = normalized[argName].map((col: string) => {
        if (typeof col === 'string') {
          const original = col;
          const normalizedCol = normalizeColumnReference(col);
          if (original !== normalizedCol) {
            console.log(`[QueryEngine] Column synonym (array): "${original}" â†’ "${normalizedCol}"`);
          }
          return normalizedCol;
        }
        return col;
      });
    }
  }
  
  return normalized;
}

/**
 * FLEXIBLE DIVISION/DEPARTMENT MATCHING
 * 
 * Normalizes division/department names for flexible LIKE matching.
 * Users often omit punctuation when typing division names:
 * - "LCC Healthcare" should match "LCC - Healthcare"
 * - "Civil Structural" should match "Civil & Structural"
 * - "SES Hill Spain Madrid" should match "SES - Hill Spain - Madrid - Projects"
 * 
 * Strategy: Convert input into a %token1%token2%token3% pattern
 * that matches regardless of punctuation between tokens.
 * 
 * @param value - The user's input for division/department
 * @returns A SQL LIKE pattern with wildcards between tokens
 */
function normalizeDivisionForFlexibleMatch(value: string): string {
  if (!value) return value;
  
  // Step 1: Remove common punctuation (hyphens, colons, ampersands, dots)
  // Keep the actual word characters
  let normalized = value
    .replace(/[-:&.]/g, ' ')  // Replace punctuation with spaces
    .replace(/\s+/g, ' ')      // Collapse multiple spaces
    .trim();
  
  // Step 2: Split into tokens (words)
  const tokens = normalized.split(' ').filter(t => t.length > 0);
  
  // Step 3: Build flexible LIKE pattern
  // %token1%token2%token3% matches "token1 - token2 & token3" etc.
  if (tokens.length === 0) return value;
  if (tokens.length === 1) return `%${tokens[0]}%`;
  
  // Build pattern: %token1%token2%...%tokenN%
  const pattern = '%' + tokens.join('%') + '%';
  
  console.log(`[FlexibleMatch] Division/Department: "${value}" â†’ LIKE "${pattern}"`);
  return pattern;
}

/**
 * FLEXIBLE SEARCH PATTERN: Creates SQL LIKE patterns for flexible whitespace matching.
 * 
 * Handles variations like "waste water" vs "wastewater", "air port" vs "airport".
 * Returns an object with:
 * - patterns: Array of LIKE patterns to search
 * - needsOr: Boolean indicating if multiple patterns need OR conditions
 * 
 * Example: "waste water" â†’ patterns: ["%waste water%", "%wastewater%", "%waste%water%"]
 */
function createFlexibleSearchPatterns(term: string): { patterns: string[], needsOr: boolean } {
  if (!term || typeof term !== 'string') {
    return { patterns: [`%${term}%`], needsOr: false };
  }
  
  const trimmed = term.trim();
  
  // Check if term has spaces that might be optional in the database
  if (trimmed.includes(' ')) {
    const noSpaces = trimmed.replace(/\s+/g, '');    // "waste water" â†’ "wastewater"
    const flexible = trimmed.replace(/\s+/g, '%');   // "waste water" â†’ "waste%water"
    
    // Return all three patterns
    return {
      patterns: [`%${trimmed}%`, `%${noSpaces}%`, `%${flexible}%`],
      needsOr: true
    };
  }
  
  // No spaces - single pattern is sufficient
  return { patterns: [`%${trimmed}%`], needsOr: false };
}

/**
 * FLEXIBLE LIKE CLAUSE: Builds SQL WHERE clause with flexible whitespace matching.
 * 
 * @param column - The SQL column name (e.g., "RequestCategory")
 * @param term - The search term (e.g., "waste water")
 * @param startParamIndex - Starting parameter index for @p1, @p2, etc.
 * @returns Object with sql clause and params array
 */
function buildFlexibleLikeClause(column: string, term: string, startParamIndex: number): { 
  sql: string, 
  params: string[], 
  nextParamIndex: number 
} {
  const { patterns, needsOr } = createFlexibleSearchPatterns(term);
  
  if (!needsOr) {
    return {
      sql: `"${column}" LIKE @p${startParamIndex}`,
      params: patterns,
      nextParamIndex: startParamIndex + 1
    };
  }
  
  // Multiple patterns need OR conditions
  const conditions = patterns.map((_, idx) => `"${column}" LIKE @p${startParamIndex + idx}`);
  return {
    sql: `(${conditions.join(' OR ')})`,
    params: patterns,
    nextParamIndex: startParamIndex + patterns.length
  };
}

/**
 * GARBAGE VALUE CLEANUP: Remove invalid/garbage parameter values
 * 
 * The LLM sometimes extracts parts of the question as parameter values incorrectly.
 * For example: "show by division" â†’ division: "show by" (WRONG)
 * 
 * This function detects and removes garbage values from ANY parameter.
 * It works generically for all parameters, not just division/department.
 * 
 * Garbage detection rules:
 * 1. Contains common query words (show, by, the, and, or, with, etc.)
 * 2. Long text with multiple spaces (likely extracted from question)
 * 3. Contains punctuation that doesn't belong in entity names
 * 4. Matches known garbage patterns
 */
function cleanupGarbageValues(args: Record<string, any>, userQuestion: string): Record<string, any> {
  if (!args) return args;
  
  const cleaned = { ...args };
  
  // Common query words that shouldn't appear in entity parameter values
  // Includes quantifiers like "each", "every", "all" that get incorrectly extracted
  const GARBAGE_WORDS = [
    'show', 'display', 'list', 'get', 'give', 'find', 'provide', 'fetch',
    'by the', 'by a', 'and show', 'show it', 'it by', 'doing the',
    'is over', 'over the', 'in the', 'for the', 'with the',
    'request category', 'or sector', 'in revenues', 'doing work',
    // Quantifiers that shouldn't be extracted as filter values
    'each', 'every', 'all', 'any', 'both', 'either', 'neither',
    // Pronouns that shouldn't be extracted as filter values (common in follow-ups)
    'they', 'them', 'their', 'theirs', 'thy', // thy is typo for they
    'he', 'him', 'his', 'she', 'her', 'hers',
    'it', 'its', 'this', 'that', 'these', 'those',
    'who', 'whom', 'whose', 'which', 'what',
    // Follow-up artifacts
    'how many', 'people', 'there are', 'there in', 'do they', 'work for'
  ];
  
  // Parameters that represent entity names (not filters like limit, min_fee, etc.)
  const ENTITY_PARAMS = [
    'division', 'department', 'client', 'company', 'poc', 'status',
    'category', 'project_type', 'state', 'state_code', 'keyword',
    'sector', 'region', 'office', 'group'
  ];
  
  for (const param of ENTITY_PARAMS) {
    const value = cleaned[param];
    if (!value || typeof value !== 'string') continue;
    
    const valueLower = value.toLowerCase();
    
    // Check 1: Contains garbage words (use word boundary matching to avoid false positives)
    // Example: "dallas" should NOT match "all" - we need whole word matching
    const hasGarbageWords = GARBAGE_WORDS.some(word => {
      // For multi-word phrases like "by the", use includes
      if (word.includes(' ')) {
        return valueLower.includes(word);
      }
      // For single words, use word boundary regex to avoid substring matches
      // This prevents "dallas" from matching "all" or "hall" from matching "all"
      const regex = new RegExp(`\\b${word}\\b`, 'i');
      return regex.test(valueLower);
    });
    
    // Check 2: Long text with multiple spaces (likely extracted from question)
    // EXCEPTION: Skip this check for compound names with structural punctuation (hyphen, colon, ampersand)
    // Examples: "LCC - Healthcare", "SPM: Cost Management", "Civil & Structural"
    const isCompoundName = /[-:&]/.test(value);
    // EXCEPTION: Organization names with indicators should be preserved through ALL checks
    const orgIndicatorsGC = /\b(company|corporation|corp|inc|llc|ltd|group|authority|agency|district|foundation|hospital|airports?|university|college|school|transit|metro|mta|port|center|institute|department|office|service|board|commission)\b/i;
    const hasOrgIndicatorGC = orgIndicatorsGC.test(value);
    
    // FINAL GUARD: If org indicator is present, NEVER delete (skip all garbage checks)
    if (hasOrgIndicatorGC) {
      console.log(`[QueryEngine] ğŸ” GARBAGE CLEANUP SKIP: Preserving ${param}="${value}" (organization indicator detected)`);
      continue;
    }
    
    // Check 2: Long text with multiple spaces (likely extracted from question)
    const hasManySpaces = !isCompoundName && (value.match(/\s/g) || []).length >= 2 && value.length > 15;
    
    // Check 3: Contains punctuation that doesn't belong in entity names
    // (allow colons, hyphens, ampersands for names like "SCM: Cost Management" or "Research & Development")
    const hasBadPunctuation = /[(),!?@#$%^*+=\[\]{}|\\<>]/.test(value);
    
    // Check 4: Value looks like it was extracted from the question (substring match)
    const isQuestionSubstring = userQuestion.toLowerCase().includes(valueLower) && 
                                 valueLower.split(/\s+/).length > 3;
    
    if (hasGarbageWords || hasManySpaces || hasBadPunctuation || isQuestionSubstring) {
      console.log(`[QueryEngine] ğŸ§¹ GARBAGE CLEANUP: Removing ${param}="${value}" (garbage detected)`);
      delete cleaned[param];
    }
  }
  
  
  // HALLUCINATED CATEGORY CLEANUP: If the LLM added a category/categories but the user
  // didnt explicitly mention category keywords, remove it to prevent false filtering
  const categoryKeywords = /\b(category|categories|sector|sectors|transportation|healthcare|aviation|infrastructure|water|education)\b/i;
  const hasExplicitCategoryInQuestion = categoryKeywords.test(userQuestion);
  
  if (!hasExplicitCategoryInQuestion && !args._explicit_category) {
    if (cleaned.category) {
      console.log(`[QueryEngine] HALLUCINATED CATEGORY CLEANUP: Removing category="${cleaned.category}" (not explicitly mentioned)`);
      delete cleaned.category;
    }
    if (cleaned.categories) {
      console.log(`[QueryEngine] HALLUCINATED CATEGORY CLEANUP: Removing categories=${JSON.stringify(cleaned.categories)} (not explicitly mentioned)`);
      delete cleaned.categories;
    }
  }
  return cleaned;
}

/**
 * GENERIC BREAKDOWN DETECTION: Extract "by <column>" patterns from any query
 * 
 * Instead of hardcoding regex for each column (division, department, state, etc.),
 * this function dynamically detects "by <column>" patterns and maps them to
 * the appropriate breakdown function.
 * 
 * Returns: { breakdownColumn: string | null, breakdownFunction: string | null }
 */
function detectBreakdownPattern(userQuestion: string): { breakdownColumn: string | null, breakdownFunction: string | null } {
  const lowerQuestion = userQuestion.toLowerCase();
  
  // Map of column keywords to their breakdown functions
  const BREAKDOWN_FUNCTIONS: Record<string, string> = {
    'division': 'get_division_breakdown',
    'divisions': 'get_division_breakdown',
    'department': 'get_department_breakdown',
    'departments': 'get_department_breakdown',
    'dept': 'get_department_breakdown',
    'module': 'get_module_breakdown',
    'modules': 'get_module_breakdown',
    'source': 'get_module_breakdown',
    'state': 'get_revenue_by_state',
    'states': 'get_revenue_by_state',
    'region': 'compare_regions',
    'regions': 'compare_regions',
    'country': 'compare_countries',
    'countries': 'compare_countries',
    'category': 'get_category_breakdown',
    'categories': 'get_category_breakdown',
    'sector': 'get_category_breakdown',
    'sectors': 'get_category_breakdown',
    'type': 'get_project_type_breakdown',
    'types': 'get_project_type_breakdown',
    'project type': 'get_project_type_breakdown',
    'project types': 'get_project_type_breakdown',
    'client': 'get_top_clients',
    'clients': 'get_top_clients',
    'company': 'compare_companies',
    'companies': 'compare_companies',
    'poc': 'get_top_pocs',
    'pocs': 'get_top_pocs',
    'sales rep': 'get_top_pocs',
    'contact': 'get_top_pocs',
    'status': 'get_status_breakdown',
    'statuses': 'get_status_breakdown',
    'size': 'get_size_distribution',
    'sizes': 'get_size_distribution',
    'year': 'compare_years',
    'years': 'compare_years',
    'month': 'get_revenue_by_month',
    'months': 'get_revenue_by_month',
  };
  
  // Patterns to detect "by <column>" aggregation requests
  // "by division", "per department", "grouped by state", "break down by category"
  // "break it down by which department handles them", "breakdown by which division"
  // IMPORTANT: Use non-greedy match and known column words only to avoid capturing trailing garbage
  const knownColumns = Object.keys(BREAKDOWN_FUNCTIONS).join('|');
  const byPatterns = [
    // Match known column keywords after "by/per/grouped by" etc.
    new RegExp(`\\b(?:by|per|grouped\\s+by|break\\s*(?:down|it)\\s*(?:by|per)|split\\s+by|breakdown\\s+by)\\s+(?:the\\s+)?(${knownColumns})\\b`, 'i'),
    // Match "<column> breakdown"
    new RegExp(`\\b(${knownColumns})\\s+breakdown\\b`, 'i'),
    // Match "show it by <column>"
    new RegExp(`\\bshow\\s+(?:it\\s+)?(?:by|per)\\s+(?:the\\s+)?(${knownColumns})\\b`, 'i'),
    // Match "break it down by which <column>" pattern
    new RegExp(`\\bbreak\\s+(?:it\\s+)?down\\s+by\\s+(?:which|what)\\s+(${knownColumns})\\b`, 'i'),
    // Match "by which/what <column>" pattern
    new RegExp(`\\bby\\s+(?:which|what)\\s+(${knownColumns})\\b`, 'i'),
    // Match "<column> handles/does/manages" pattern (implied grouping)
    new RegExp(`\\bwhich\\s+(${knownColumns})\\s+(?:handles?|does?|manages?|works?\\s+on)\\b`, 'i'),
    // Match "which <column> had/has/is" pattern - for questions like "which month had the highest"
    new RegExp(`\\bwhich\\s+(${knownColumns})\\s+(?:had|has|is|was|were|are)\\b`, 'i'),
    // Match "each/every/per <column>" pattern
    new RegExp(`\\b(?:each|every|per)\\s+(${knownColumns})\\b`, 'i'),
    // Match "show me the <column> of" pattern - for "show me the region of all data centers"
    new RegExp(`\\b(?:show|list|display|get)\\s+(?:me\\s+)?(?:the\\s+|all\\s+)?(${knownColumns})s?\\s+(?:of|for)\\b`, 'i'),
    // Match "all <column>s" pattern - for "show all regions"
    new RegExp(`\\b(?:show|list|display|get)\\s+(?:me\\s+)?all\\s+(${knownColumns})s?\\b`, 'i'),
  ];
  
  for (const pattern of byPatterns) {
    const match = lowerQuestion.match(pattern);
    if (match && match[1]) {
      const columnKeyword = match[1].toLowerCase().trim();
      const breakdownFn = BREAKDOWN_FUNCTIONS[columnKeyword];
      
      if (breakdownFn) {
        console.log(`[QueryEngine] ğŸ” BREAKDOWN DETECTED: "by ${columnKeyword}" â†’ ${breakdownFn}`);
        return { breakdownColumn: columnKeyword, breakdownFunction: breakdownFn };
      }
    }
  }
  
  return { breakdownColumn: null, breakdownFunction: null };
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// QUERY STATE SYSTEM: State-based follow-up handling for 100% accuracy
// This ensures follow-ups ALWAYS properly combine with original query context
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

/**
 * Canonical QueryState - captures complete query context after classification
 * This state is frozen after the first query and modified by follow-up operations
 */
interface QueryState {
  // Core query identity
  originalQuestion: string;           // The original user question
  templateFunction: string;           // The function/template selected (e.g., get_projects_by_state)
  
  // All filter values (normalized)
  filters: {
    // Location filters
    states?: string[];
    state_code?: string;
    region?: string;
    
    // Organization filters
    company?: string;
    companies?: string[];
    client?: string;
    clients?: string[];
    poc?: string;
    pocs?: string[];
    
    // Category filters
    category?: string;
    categories?: string[];
    project_type?: string;
    project_types?: string[];
    tags?: string[];
    
    // Status filters
    status?: string | string[];
    
    // Date filters
    start_date?: string;
    end_date?: string;
    year?: number;
    quarter?: number;
    years?: number[];
    time_reference?: string;
    days_threshold?: number;
    
    // Value filters
    min_fee?: number;
    max_fee?: number;
    min_win?: number;
    max_win?: number;
    size?: string;
    
    // Text filters
    keyword?: string;
    keywords?: string[];
    description_search?: string;
    project_name?: string;
    
    // Other filters
    [key: string]: any;
  };
  
  // Query modifiers
  limit?: number;
  offset?: number;
  sort_field?: string;
  sort_direction?: 'ASC' | 'DESC';
  group_by?: string;
  
  // Aggregation context
  aggregationType?: string;           // 'sum', 'average', 'count', 'breakdown'
  aggregationColumn?: string;         // The column being aggregated
  
  // Metadata
  followUpCount: number;              // Track number of follow-ups (max 3)
  lastModified: Date;
}

/**
 * Follow-up operation types that the LLM can return
 */
type FollowUpOperation = 
  | { type: 'add_filter'; key: string; value: any }           // Add/append a filter
  | { type: 'replace_filter'; key: string; value: any }       // Replace a filter entirely
  | { type: 'remove_filter'; key: string }                    // Remove a filter entirely
  | { type: 'remove_value'; key: string; value: any }         // Remove specific value(s) from array filter
  | { type: 'set_limit'; value: number }                      // Set result limit
  | { type: 'set_sort'; field: string; direction: 'ASC' | 'DESC' }  // Set sorting
  | { type: 'change_template'; newTemplate: string; reason: string }  // Switch to different template
  | { type: 'set_aggregation'; aggregationType: string; column?: string }  // Change aggregation
  | { type: 'no_change' };                                    // No modifications needed

/**
 * Apply follow-up operations to QueryState deterministically
 * Returns a new state (immutable update)
 */
function applyFollowUpOperations(
  state: QueryState, 
  operations: FollowUpOperation[]
): QueryState {
  // Deep clone the state
  const newState: QueryState = JSON.parse(JSON.stringify(state));
  newState.followUpCount += 1;
  newState.lastModified = new Date();
  
  console.log(`[FollowUpState] Applying ${operations.length} operations to state`);
  
  for (const op of operations) {
    switch (op.type) {
      case 'add_filter':
        // Add to existing filter (merge arrays, or set if not exists)
        let addValue = op.value;
        
        // STATUS NORMALIZATION: Convert "open"/"closed" to correct status arrays
        if (op.key === 'status') {
          const OPEN_STATUSES_ADD = ["Proposal Development", "Qualified Lead", "Submitted", "Won", "Lead", "In Progress", "Hold"];
          const CLOSED_STATUSES_ADD = ["Lost", "No Go", "Cancelled"];
          
          if (typeof addValue === 'string') {
            const statusLower = addValue.toLowerCase();
            if (statusLower === 'open' || statusLower === 'active' || statusLower === 'ongoing' || statusLower === 'current') {
              console.log(`[FollowUpState] STATUS EXPANSION (add): "${addValue}" â†’ all open statuses`);
              addValue = OPEN_STATUSES_ADD;
            } else if (statusLower === 'closed' || statusLower === 'completed' || statusLower === 'finished') {
              console.log(`[FollowUpState] STATUS EXPANSION (add): "${addValue}" â†’ all closed statuses`);
              addValue = CLOSED_STATUSES_ADD;
            }
          }
        }
        
        const existing = newState.filters[op.key];
        if (Array.isArray(existing) && Array.isArray(addValue)) {
          // Merge arrays, removing duplicates
          const combined = [...existing, ...addValue];
          newState.filters[op.key] = combined.filter((v, i) => combined.indexOf(v) === i);
        } else if (Array.isArray(existing) && !Array.isArray(addValue)) {
          // Add single value to existing array
          if (!existing.includes(addValue)) {
            newState.filters[op.key] = [...existing, addValue];
          }
        } else {
          // Set new value
          newState.filters[op.key] = addValue;
        }
        console.log(`[FollowUpState] ADD_FILTER: ${op.key} = ${JSON.stringify(newState.filters[op.key])}`);
        break;
        
      case 'replace_filter':
        // Replace filter entirely
        let valueToSet = op.value;
        
        // STATUS NORMALIZATION: Convert "open"/"closed" to correct status arrays
        if (op.key === 'status') {
          const OPEN_STATUSES = ["Proposal Development", "Qualified Lead", "Submitted", "Won", "Lead", "In Progress", "Hold"];
          const CLOSED_STATUSES = ["Lost", "No Go", "Cancelled"];
          
          if (typeof valueToSet === 'string') {
            const statusLower = valueToSet.toLowerCase();
            if (statusLower === 'open' || statusLower === 'active' || statusLower === 'ongoing' || statusLower === 'current') {
              console.log(`[FollowUpState] STATUS EXPANSION: "${valueToSet}" â†’ all open statuses`);
              valueToSet = OPEN_STATUSES;
            } else if (statusLower === 'closed' || statusLower === 'completed' || statusLower === 'finished') {
              console.log(`[FollowUpState] STATUS EXPANSION: "${valueToSet}" â†’ all closed statuses`);
              valueToSet = CLOSED_STATUSES;
            }
          }
        }
        
        newState.filters[op.key] = valueToSet;
        console.log(`[FollowUpState] REPLACE_FILTER: ${op.key} = ${JSON.stringify(valueToSet)}`);
        break;
        
      case 'remove_filter':
        // Remove filter entirely
        delete newState.filters[op.key];
        console.log(`[FollowUpState] REMOVE_FILTER: ${op.key}`);
        break;
        
      case 'remove_value':
        // Remove specific value(s) from an array filter
        const currentFilterVal = newState.filters[op.key];
        if (Array.isArray(currentFilterVal)) {
          const valuesToRemove = Array.isArray(op.value) ? op.value : [op.value];
          // Normalize for comparison (handle strings case-insensitively, numbers exactly)
          const normalizeValue = (v: any): string => {
            if (typeof v === 'string') return v.toLowerCase();
            return String(v);
          };
          const normalizedToRemove = valuesToRemove.map(normalizeValue);
          
          // Also handle state code/name normalization for states filter
          const STATE_CODE_TO_NAME: Record<string, string> = {
            'ca': 'california', 'tx': 'texas', 'ny': 'new york', 'fl': 'florida',
            'pa': 'pennsylvania', 'il': 'illinois', 'oh': 'ohio', 'ga': 'georgia',
            'nc': 'north carolina', 'mi': 'michigan', 'nj': 'new jersey', 'va': 'virginia',
            'wa': 'washington', 'az': 'arizona', 'ma': 'massachusetts', 'tn': 'tennessee',
            'in': 'indiana', 'mo': 'missouri', 'md': 'maryland', 'wi': 'wisconsin'
          };
          
          const normalizedToRemoveExpanded = [...normalizedToRemove];
          if (op.key === 'states') {
            for (const v of normalizedToRemove) {
              const vLower = v.toLowerCase();
              // If it's a code, add the full name too
              if (STATE_CODE_TO_NAME[vLower]) {
                normalizedToRemoveExpanded.push(STATE_CODE_TO_NAME[vLower]);
              }
              // If it's a name, add the code too
              for (const [code, name] of Object.entries(STATE_CODE_TO_NAME)) {
                if (name === vLower) normalizedToRemoveExpanded.push(code);
              }
            }
          }
          
          newState.filters[op.key] = currentFilterVal.filter(
            (v: any) => !normalizedToRemoveExpanded.includes(normalizeValue(v))
          );
          // If array is now empty, remove the filter entirely
          if (newState.filters[op.key].length === 0) {
            delete newState.filters[op.key];
            console.log(`[FollowUpState] REMOVE_VALUE: ${op.key} - removed all values, filter cleared`);
          } else {
            console.log(`[FollowUpState] REMOVE_VALUE: ${op.key} = ${JSON.stringify(newState.filters[op.key])} (removed ${JSON.stringify(valuesToRemove)})`);
          }
        } else {
          // For non-array, treat as remove_filter if value matches
          const currentStr = typeof currentFilterVal === 'string' ? currentFilterVal.toLowerCase() : String(currentFilterVal);
          const opStr = typeof op.value === 'string' ? op.value.toLowerCase() : String(op.value);
          if (currentStr === opStr) {
            delete newState.filters[op.key];
            console.log(`[FollowUpState] REMOVE_VALUE: ${op.key} - scalar value matched, filter removed`);
          }
        }
        break;
        
      case 'set_limit':
        newState.limit = op.value;
        console.log(`[FollowUpState] SET_LIMIT: ${op.value}`);
        break;
        
      case 'set_sort':
        newState.sort_field = op.field;
        newState.sort_direction = op.direction;
        console.log(`[FollowUpState] SET_SORT: ${op.field} ${op.direction}`);
        break;
        
      case 'change_template':
        newState.templateFunction = op.newTemplate;
        console.log(`[FollowUpState] CHANGE_TEMPLATE: ${op.newTemplate} (${op.reason})`);
        break;
        
      case 'set_aggregation':
        newState.aggregationType = op.aggregationType;
        if (op.column) {
          newState.aggregationColumn = op.column;
        }
        console.log(`[FollowUpState] SET_AGGREGATION: ${op.aggregationType} on ${op.column || 'default'}`);
        break;
        
      case 'no_change':
        console.log(`[FollowUpState] NO_CHANGE - state unchanged`);
        break;
    }
  }
  
  return newState;
}

/**
 * Convert QueryState back to classification arguments for SQL execution
 */
function stateToArguments(state: QueryState): Record<string, any> {
  const args: Record<string, any> = { ...state.filters };
  
  // Add modifiers
  if (state.limit) args.limit = state.limit;
  if (state.offset) args.offset = state.offset;
  if (state.sort_field) args.sort_field = state.sort_field;
  if (state.sort_direction) args.sort_direction = state.sort_direction;
  if (state.group_by) args.group_by = state.group_by;
  if (state.aggregationType) args.aggregation_type = state.aggregationType;
  if (state.aggregationColumn) args.aggregation_column = state.aggregationColumn;
  
  console.log(`[FollowUpState] State â†’ Arguments:`, JSON.stringify(args));
  return args;
}

/**
 * Generate a synthetic combined question from QueryState
 * This creates a complete question that captures all filters for accurate re-classification
 */
function generateCombinedQuestion(state: QueryState, followUpQuestion: string): string {
  const parts: string[] = [];
  
  // Start with the intent based on template
  const templateIntents: Record<string, string> = {
    'get_projects_by_state': 'Show projects',
    'get_projects_by_client': 'Show projects for client',
    'get_projects_by_company': 'Show projects by company',
    'get_client_expansion_opportunities': 'Show expansion opportunities',
    'get_largest_projects': 'Show largest projects',
    'get_smallest_projects': 'Show smallest projects',
    'get_status_breakdown': 'Show status breakdown',
    'get_revenue_by_project_type': 'Show revenue by project type',
    'get_project_type_breakdown': 'Show project type breakdown',
    'get_stalled_deals': 'Show stalled deals',
    'get_high_risk_opportunities': 'Show high risk opportunities',
    'search_projects_by_description': 'Search projects',
  };
  
  parts.push(templateIntents[state.templateFunction] || 'Show projects');
  
  // Add all active filters
  const f = state.filters;
  
  if (f.states?.length) {
    parts.push(`in ${f.states.join(', ')}`);
  } else if (f.state_code) {
    parts.push(`in ${f.state_code}`);
  }
  
  if (f.category) {
    parts.push(`with category ${f.category}`);
  } else if (f.categories?.length) {
    parts.push(`with categories ${f.categories.join(', ')}`);
  }
  
  if (f.company) {
    parts.push(`for company ${f.company}`);
  }
  
  if (f.client) {
    parts.push(`for client ${f.client}`);
  }
  
  if (f.status) {
    const statusStr = Array.isArray(f.status) ? f.status.join(' or ') : f.status;
    parts.push(`with status ${statusStr}`);
  }
  
  if (f.project_type) {
    parts.push(`of type ${f.project_type}`);
  }
  
  if (f.min_fee !== undefined || f.max_fee !== undefined) {
    if (f.min_fee && f.max_fee) {
      parts.push(`with fee between $${f.min_fee} and $${f.max_fee}`);
    } else if (f.min_fee) {
      parts.push(`with fee greater than $${f.min_fee}`);
    } else if (f.max_fee) {
      parts.push(`with fee less than $${f.max_fee}`);
    }
  }
  
  if (f.year) {
    parts.push(`in year ${f.year}`);
  }
  
  if (state.limit) {
    parts.push(`limit ${state.limit}`);
  }
  
  if (state.sort_field) {
    parts.push(`sorted by ${state.sort_field} ${state.sort_direction || 'DESC'}`);
  }
  
  const combined = parts.join(' ');
  console.log(`[FollowUpState] Combined question: "${combined}"`);
  console.log(`[FollowUpState] Follow-up was: "${followUpQuestion}"`);
  
  return combined;
}

/**
 * Create initial QueryState from first query classification result
 */
function createInitialQueryState(
  originalQuestion: string,
  functionName: string,
  args: Record<string, any>
): QueryState {
  // Separate filters from modifiers
  const modifierKeys = ['limit', 'offset', 'sort_field', 'sort_direction', 'group_by', 
                        'aggregation_type', 'aggregation_column'];
  
  const filters: Record<string, any> = {};
  let limit: number | undefined;
  let offset: number | undefined;
  let sort_field: string | undefined;
  let sort_direction: 'ASC' | 'DESC' | undefined;
  let group_by: string | undefined;
  let aggregationType: string | undefined;
  let aggregationColumn: string | undefined;
  
  for (const [key, value] of Object.entries(args)) {
    if (key === 'limit') limit = value;
    else if (key === 'offset') offset = value;
    else if (key === 'sort_field') sort_field = value;
    else if (key === 'sort_direction') sort_direction = value;
    else if (key === 'group_by') group_by = value;
    else if (key === 'aggregation_type') aggregationType = value;
    else if (key === 'aggregation_column') aggregationColumn = value;
    else filters[key] = value;
  }
  
  const state: QueryState = {
    originalQuestion,
    templateFunction: functionName,
    filters,
    limit,
    offset,
    sort_field,
    sort_direction,
    group_by,
    aggregationType,
    aggregationColumn,
    followUpCount: 0,
    lastModified: new Date(),
  };
  
  console.log(`[FollowUpState] Created initial state:`, JSON.stringify(state, null, 2));
  return state;
}

/**
 * TWO-PHASE LLM-powered follow-up interpretation
 * Phase 1: Classify the INTENT of the follow-up (time, fee, win_rate, location, etc.)
 * Phase 2: Extract values using type-safe mapping
 * This prevents confusion between filter types (e.g., "3 months" won't become $3M)
 */

// Define allowed keys per intent type for type-safety
const INTENT_ALLOWED_KEYS: Record<string, string[]> = {
  'time': ['start_date', 'end_date', 'year', 'years'],
  'fee': ['min_fee', 'max_fee'],
  'win_rate': ['min_win', 'max_win'],
  'location': ['states', 'state_code'],
  'category': ['category', 'categories', 'project_type', 'project_types'],
  'status': ['status'],
  'entity': ['company', 'companies', 'client', 'clients', 'poc', 'organization'],
  'division': ['division', 'divisions'],
  'department': ['department', 'departments'],
  'limit': ['limit'],
  'sort': ['sort_field', 'sort_direction'],
  'tags': ['tags', 'exclude_tags'],
  'mixed': [], // Allow any keys for complex queries
  'remove': [], // For removal operations
  'no_change': []
};

async function interpretFollowUp(
  openaiClient: { chat: (messages: Array<{ role: string; content: string }>, options?: { max_completion_tokens?: number; model?: string }) => Promise<string> },
  followUpQuestion: string,
  currentState: QueryState
): Promise<FollowUpOperation[]> {
  console.log(`[InterpretFollowUp] Analyzing: "${followUpQuestion}"`);
  console.log(`[InterpretFollowUp] Current state filters:`, JSON.stringify(currentState.filters));
  
  // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  // PHASE 1: CLASSIFY THE INTENT OF THE FOLLOW-UP
  // This prevents confusion between filter types by first determining WHAT type
  // of modification the user wants before extracting values
  // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  const today = new Date().toISOString().split('T')[0];
  
  const classificationPrompt = `Classify this follow-up question into ONE primary intent type.

Follow-up: "${followUpQuestion}"
Current filters: ${JSON.stringify(currentState.filters)}
Today's date: ${today}

INTENT TYPES (choose exactly ONE):
- "time": About time periods, dates, months, years (e.g., "in 3 months", "next 6 months", "last year", "after 2025", "over the next quarter")
- "fee": About fees, costs, budget, revenue, dollar amounts (e.g., "over $1M", "fee above 500k", "budget under 10 million")
- "win_rate": About win rate, win percentage, probability (e.g., "win rate below 10", "above 50%", "high probability")
- "location": About states, regions, geography (e.g., "in California", "West region", "add Texas")
- "category": About categories, sectors, project types (e.g., "healthcare", "transportation", "show airports")
- "status": About project status (e.g., "Won", "Lost", "Submitted", "Lead")
- "division": About business units/divisions (e.g., "in Engineering division", "Healthcare division", "switch to IT division")
- "department": About departments (e.g., "Operations department", "Sales department", "in Marketing department")
- "entity": About companies, clients, people (e.g., "for Company A", "assigned to John")
- "limit": About number of results (e.g., "top 10", "first 5", "limit to 20")
- "sort": About ordering results (e.g., "sort by fee", "order by date", "highest first")
- "remove": Removing/clearing filters (e.g., "remove the state filter", "clear all")
- "mixed": Multiple unrelated intents in one query
- "no_change": Just asking a question, no filter change needed

CRITICAL RULES:
- "X months" or "X years" or "X days" = ALWAYS "time" intent, NEVER "fee"
- Dollar signs ($), "million", "M", "k", "budget", "cost", "fee" = "fee" intent
- "win %", "win rate", "probability", "chance" = "win_rate" intent
- Numbers without context: check for time words first, then fee words

Return JSON: {"intent": "<intent_type>", "reason": "<brief explanation>"}`;

  try {
    // Phase 1: Get the intent classification
    const classifyResponse = await openaiClient.chat(
      [
        { role: "system", content: "You are a precise intent classifier. Return only valid JSON." },
        { role: "user", content: classificationPrompt }
      ],
      { model: "gpt-5.1", max_completion_tokens: 150 }
    );
    
    let intent = 'mixed';
    try {
      const parsed = JSON.parse(classifyResponse.trim());
      intent = parsed.intent || 'mixed';
      console.log(`[InterpretFollowUp] Phase 1 - Intent classified as: "${intent}" (${parsed.reason || 'no reason'})`);
    } catch (e) {
      console.log(`[InterpretFollowUp] Phase 1 - Could not parse intent, defaulting to "mixed"`);
    }
    
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    // PHASE 2: EXTRACT VALUES WITH TYPE-SAFE CONSTRAINTS
    // Based on the intent, we now know which keys are allowed
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    const allowedKeys = INTENT_ALLOWED_KEYS[intent] || [];
    console.log(`[InterpretFollowUp] Phase 2 - Allowed keys for "${intent}": ${JSON.stringify(allowedKeys)}`);
  
  const systemPrompt = `You are a query modification interpreter. Given a current query state and a follow-up question, determine what modifications to make.

CLASSIFIED INTENT: "${intent}"
${intent !== 'mixed' && intent !== 'remove' && intent !== 'no_change' ? `IMPORTANT: Since this is a "${intent}" intent, you can ONLY use these keys: ${allowedKeys.join(', ')}` : ''}

CURRENT QUERY STATE:
- Template: ${currentState.templateFunction}
- Original Question: "${currentState.originalQuestion}"
- Active Filters: ${JSON.stringify(currentState.filters)}
- Limit: ${currentState.limit || 'none'}
- Sort: ${currentState.sort_field ? `${currentState.sort_field} ${currentState.sort_direction}` : 'none'}
- Today's date: ${today}

VALID FILTER KEYS (use these exact names):
LOCATION:
- states: array of full state names like ["California", "Texas", "New York"] (IMPORTANT: use full names, not abbreviations)
- state_code: single state code like "CA" (only if specifically mentioned as code)

CATEGORIES & TYPES:
- category: single category like "Transportation" or "Healthcare"
- categories: array of categories
- project_type: specific project type like "Bridges", "Hospitals", "Aviation"
- project_types: array of project types

ENTITIES:
- company: single company name like "Company A"
- companies: array of company names
- client: single client name like "Client 1234"
- clients: array of client names
- poc: point of contact name

DIVISION / DEPARTMENT:
- division: single division name like "Engineering", "Healthcare", "IT"
- divisions: array of division names
- department: single department name like "Operations", "Sales", "Marketing"
- departments: array of department names

STATUS & RANGES:
- status: status value like "Won", "Lost", "Lead", "Qualified Lead", "Pending"
- min_fee, max_fee: fee range filters (numbers, e.g., 1000000 for $1M) - ONLY for dollar amounts
- min_win, max_win: win rate percentage filters (numbers 0-100) - ONLY for percentages

TIME (today is ${today}):
- start_date, end_date: date strings in YYYY-MM-DD format
- For "in/over/next X months": start_date = today, end_date = today + X months
- For "last/past X months": start_date = today - X months, end_date = today
- year: specific year (number like 2024)
- years: array of years

OTHER:
- tags: array of tags like ["healthcare", "renovation"]
- exclude_tags: array of tags to exclude
- limit: number of results (e.g., 10, 5)
- keyword: general search keyword

OPERATION TYPES:
1. add_filter: Add a new filter or append to existing array filter
2. replace_filter: Replace an existing filter with a new value (use for "only X" or "X instead")
3. remove_filter: Remove a filter entirely (clears the whole filter)
4. remove_value: Remove specific value(s) from an array filter (partial removal)
5. set_limit: Set result limit (number)
6. set_sort: Set sorting (field and direction ASC or DESC)
7. change_template: Switch to a different template function
8. no_change: If the follow-up doesn't require any state changes

INTERPRETATION RULES:
LOCATION:
- REGIONS: "South", "Midwest", "West", "Northeast", "Southwest", "Southeast", "Pacific" are REGIONS - query the Region column directly!
  - "in South" or "South region" â†’ region: "South" (query Region column directly)
  - "in Midwest" â†’ region: "Midwest" (query Region column directly)
  - "in West" â†’ region: "West" (query Region column directly)
  - "in Northeast" â†’ region: "Northeast" (query Region column directly)
  - CRITICAL: Do NOT expand regions to states - use the region parameter to query the Region column directly
  - CRITICAL: "South" means the South REGION, NOT "South Dakota" or "South Carolina"
- STATES (individual): 
  - "in California" â†’ add_filter: states: ["California"]
  - "California only" â†’ replace_filter: states: ["California"] (because "only" means replace)
  - "also in Texas" â†’ add_filter: states: ["Texas"] (because "also" means add)
  - "remove Texas" or "exclude Texas" â†’ remove_value: states: ["Texas"] (removes ONLY Texas, keeps others)
  - "remove the state filter" or "clear states" â†’ remove_filter: states (removes ALL states)

CATEGORIES:
- "with transportation" or "transportation only" â†’ replace_filter: category: "Transportation"
- "healthcare" â†’ add_filter: category: "Healthcare"
- "show bridges" â†’ add_filter: project_type: "Bridges"

RANGES:
- "with fee over 1M" or "min fee 1000000" â†’ add_filter: min_fee: 1000000
- "under $500k" â†’ add_filter: max_fee: 500000
- "win rate above 50%" â†’ add_filter: min_win: 50
- "remove fee filter" â†’ remove_filter: min_fee, remove_filter: max_fee

LIMIT & SORT:
- "top 10" â†’ set_limit: 10
- "sorted by fee" â†’ set_sort: field: "Fee", direction: "DESC"
- "oldest first" â†’ set_sort: field: "ConstStartDate", direction: "ASC"

STATUS:
- "only won projects" â†’ replace_filter: status: "Won"
- "add leads" â†’ add_filter: status: "Lead"
- CRITICAL: "open" or "which are open" or "active" â†’ replace_filter: status: ["Proposal Development", "Qualified Lead", "Submitted", "Won", "Lead", "In Progress", "Hold"]
- CRITICAL: "closed" or "which are closed" â†’ replace_filter: status: ["Lost", "No Go", "Cancelled"]
- When user says "open", "active", "ongoing", "current" - ALWAYS expand to the full array of open statuses listed above
- When user says "closed", "completed", "finished" - ALWAYS expand to the full array of closed statuses listed above

IMPORTANT: 
- When user says "remove X" where X is a specific value currently in an array filter, use remove_value to remove just that value. Only use remove_filter when removing the entire filter.
- Use full state names (California, Texas) not abbreviations (CA, TX) in values.
- Carefully consider whether a modification is additive (add_filter), a replacement (replace_filter), or a removal (remove_filter/remove_value).

Return a JSON array of operations. Each operation must have a "type" field.`;

  const userPrompt = `Follow-up question: "${followUpQuestion}"

Based on this follow-up, what operations should be applied to modify the current query state?
Return a JSON array of operations.

Example response for "in California with transportation only":
[
  {"type": "add_filter", "key": "states", "value": ["CA"]},
  {"type": "replace_filter", "key": "category", "value": "Transportation"}
]

Example response for "top 5 sorted by fee":
[
  {"type": "set_limit", "value": 5},
  {"type": "set_sort", "field": "Fee", "direction": "DESC"}
]

Return ONLY the JSON array, no other text.`;

    const messages = [
      { role: 'system', content: systemPrompt },
      { role: 'user', content: userPrompt }
    ];
    
    const content = await openaiClient.chat(messages, { 
      model: 'gpt-5.1',
      max_completion_tokens: 500 
    });
    
    console.log(`[InterpretFollowUp] LLM response:`, content);
    
    // Parse the JSON response
    let operations: FollowUpOperation[];
    try {
      // Extract JSON array from response (in case LLM adds extra text)
      const jsonMatch = content.match(/\[[\s\S]*\]/);
      if (jsonMatch) {
        operations = JSON.parse(jsonMatch[0]);
      } else {
        console.log(`[InterpretFollowUp] No JSON array found, using empty operations`);
        operations = [];
      }
    } catch (parseError) {
      console.error(`[InterpretFollowUp] Failed to parse JSON:`, parseError);
      operations = [];
    }
    
    // Validate operations
    const validOperations: FollowUpOperation[] = [];
    for (const op of operations) {
      if (!op.type) continue;
      
      switch (op.type) {
        case 'add_filter':
        case 'replace_filter':
          if (op.key && op.value !== undefined) {
            validOperations.push(op as FollowUpOperation);
          }
          break;
        case 'remove_filter':
          if (op.key) {
            validOperations.push(op as FollowUpOperation);
          }
          break;
        case 'remove_value':
          if (op.key && op.value !== undefined) {
            validOperations.push(op as FollowUpOperation);
          }
          break;
        case 'set_limit':
          if (typeof op.value === 'number') {
            validOperations.push(op as FollowUpOperation);
          }
          break;
        case 'set_sort':
          if (op.field && op.direction) {
            validOperations.push(op as FollowUpOperation);
          }
          break;
        case 'change_template':
          if (op.newTemplate) {
            validOperations.push(op as FollowUpOperation);
          }
          break;
        case 'set_aggregation':
          if (op.aggregationType) {
            validOperations.push(op as FollowUpOperation);
          }
          break;
        case 'no_change':
          validOperations.push({ type: 'no_change' });
          break;
      }
    }
    
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    // TYPE-SAFE VALIDATION: Use the classified intent to reject operations 
    // with keys that don't match the intent type
    // This is deterministic and handles arbitrary user questions correctly
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    
    // FAIL-SAFE: Detect win rate vs fee context directly from the question
    // This prevents the LLM from adding fee filters when the user mentions win rate
    const hasWinRateContext = /\b(?:win\s*%|win\s+rate|win\s+percentage|success\s+rate|probability)\b/i.test(followUpQuestion);
    const hasFeeContext = /\b(?:fee|cost|budget|revenue|value|dollar|\$|amount)\b/i.test(followUpQuestion);
    
    const filteredOperations = validOperations.filter(op => {
      if (op.type === 'add_filter' || op.type === 'replace_filter') {
        const key = op.key;
        
        // FAIL-SAFE: If question mentions win rate but NOT fee, reject fee operations
        if (hasWinRateContext && !hasFeeContext) {
          if (key === 'min_fee' || key === 'max_fee') {
            console.log(`[InterpretFollowUp] âš ï¸ FAIL-SAFE REJECTION: Key "${key}" rejected - question mentions win rate, not fee`);
            return false;
          }
        }
        
        // FAIL-SAFE: If question mentions fee but NOT win rate, reject win rate operations
        if (hasFeeContext && !hasWinRateContext) {
          if (key === 'min_win' || key === 'max_win') {
            console.log(`[InterpretFollowUp] âš ï¸ FAIL-SAFE REJECTION: Key "${key}" rejected - question mentions fee, not win rate`);
            return false;
          }
        }
        
        // If we have a specific intent (not mixed/remove/no_change), validate key is allowed
        if (intent && allowedKeys.length > 0) {
          if (!allowedKeys.includes(key!)) {
            console.log(`[InterpretFollowUp] âš ï¸ TYPE-SAFE REJECTION: Key "${key}" not allowed for intent "${intent}" (allowed: ${allowedKeys.join(', ')})`);
            return false;
          }
        }
      }
      return true;
    });
    
    console.log(`[InterpretFollowUp] Valid operations:`, JSON.stringify(filteredOperations));
    return filteredOperations;
    
  } catch (error) {
    console.error(`[InterpretFollowUp] Error:`, error);
    return [];
  }
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// QUERY SYNONYMS: Replace common terms in user queries before classification
// This helps the LLM understand queries that use alternative terminology
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
const QUERY_SYNONYMS: Record<string, string> = {
  // Project synonyms
  // NOTE: Do NOT map 'opportunities' â†’ 'projects' because "opportunities" is a 
  // specific business term used in get_client_expansion_opportunities, get_high_risk_opportunities, etc.
  'deals': 'projects',
  'deal': 'project',
  'pursuits': 'projects',
  'pursuit': 'project',
  'bids': 'projects',
  'bid': 'project',
  'proposals': 'projects',
  'proposal': 'project',
  'engagements': 'projects',
  'engagement': 'project',
  'contracts': 'projects',
  'contract': 'project',
  'jobs': 'projects',
  'job': 'project',
  
  // Company synonyms
  'firms': 'companies',
  'firm': 'company',
  'vendors': 'companies',
  'vendor': 'company',
  // NOTE: 'contractor' removed from synonym mapping as 'Contractor' is a valid project type in database
  // Use 'firm', 'vendor', or 'consultant' synonyms instead
  'consultants': 'companies',
  'consultant': 'company',
  
  // Client synonyms
  'customers': 'clients',
  'customer': 'client',
  'accounts': 'clients',
  'account': 'client',
  
  // Fee synonyms
  'revenue': 'fee',
  'revenues': 'fees',
  'price': 'fee',
  'prices': 'fees',
  'cost': 'fee',
  'costs': 'fees',
  'value': 'fee',
  'values': 'fees',
  'budget': 'fee',
  'budgets': 'fees',
  
  // Win rate synonyms
  'success rate': 'win rate',
  'win percentage': 'win rate',
  'win %': 'win rate',
  'win%': 'win rate',
};

/**
 * Normalize user query by replacing synonyms with standard terms
 * This helps the LLM understand queries that use alternative terminology
 */
function normalizeQuerySynonyms(query: string): string {
  let normalized = query;
  
  // PRESERVE KNOWN STATUS VALUES - these should not be converted by synonyms
  // E.g., "Proposal Development" should NOT become "project Development"
  const KNOWN_STATUS_PHRASES = [
    'proposal development', 'qualified lead', 'in progress', 
    'no go', 'on hold', 'no bid'
  ];
  
  // Check if query contains a known status phrase
  const queryLower = query.toLowerCase();
  const containsStatusPhrase = KNOWN_STATUS_PHRASES.some(phrase => queryLower.includes(phrase));
  
  if (containsStatusPhrase) {
    console.log('[QueryEngine] ğŸ›¡ï¸ Preserving query - contains known status phrase');
    return query; // Return original without synonym replacements
  }
  
  // Sort by length descending to replace longer phrases first
  const sortedSynonyms = Object.entries(QUERY_SYNONYMS).sort((a, b) => b[0].length - a[0].length);
  
  for (const [synonym, replacement] of sortedSynonyms) {
    // Use word boundary matching to avoid partial replacements
    const regex = new RegExp(`\\b${synonym}\\b`, 'gi');
    if (regex.test(normalized)) {
      const before = normalized;
      normalized = normalized.replace(regex, replacement);
      console.log(`[QueryEngine] ğŸ”„ QUERY SYNONYM: "${synonym}" â†’ "${replacement}"`);
    }
  }
  
  return normalized;
}

interface QueryTemplate {
  sql: string;
  params: string[];
  param_types: string[];
  optional_params?: string[];
  chart_type: "bar" | "line" | "pie";
  chart_field?: string;
}

// Union type to support both Azure and direct OpenAI clients
type AIClient = OpenAIClient;

export class QueryEngine {
  private openaiClient: AIClient;
  private timeParser: SemanticTimeParser;
  private sizeCalculator: ProjectSizeCalculator;
  private queryTemplates: Record<string, QueryTemplate>;
  private functionDefinitions: FunctionDefinition[];
  private ragStore: RAGVectorStore | null;
  
  // Cache for valid category/project type values (loaded lazily)
  private categoryCache: string[] | null = null;
  private projectTypeCache: string[] | null = null;

  constructor(openaiClient: AIClient, ragStore: RAGVectorStore | null = null) {
    this.openaiClient = openaiClient;
    this.timeParser = new SemanticTimeParser();
    this.sizeCalculator = new ProjectSizeCalculator();
    this.queryTemplates = this.initializeQueryTemplates();
    this.functionDefinitions = this.initializeFunctionDefinitions();
    this.ragStore = ragStore;
  }
  
  /**
   * Simple Levenshtein distance for fuzzy matching
   */
  private levenshteinDistance(a: string, b: string): number {
    const matrix: number[][] = [];
    for (let i = 0; i <= b.length; i++) {
      matrix[i] = [i];
    }
    for (let j = 0; j <= a.length; j++) {
      matrix[0][j] = j;
    }
    for (let i = 1; i <= b.length; i++) {
      for (let j = 1; j <= a.length; j++) {
        if (b.charAt(i - 1) === a.charAt(j - 1)) {
          matrix[i][j] = matrix[i - 1][j - 1];
        } else {
          matrix[i][j] = Math.min(
            matrix[i - 1][j - 1] + 1,
            matrix[i][j - 1] + 1,
            matrix[i - 1][j] + 1
          );
        }
      }
    }
    return matrix[b.length][a.length];
  }
  
  /**
   * Calculate similarity score (0-1, higher is better)
   */
  private calculateSimilarity(a: string, b: string): number {
    const aLower = a.toLowerCase().trim();
    const bLower = b.toLowerCase().trim();
    if (aLower === bLower) return 1;
    if (aLower.includes(bLower) || bLower.includes(aLower)) return 0.9;
    const maxLen = Math.max(aLower.length, bLower.length);
    if (maxLen === 0) return 1;
    const distance = this.levenshteinDistance(aLower, bLower);
    return 1 - (distance / maxLen);
  }
  
  /**
   * Smart Column Detection: Counts matches in each searchable column and returns the best one.
   * This enables prioritizing queries to the column with the most matches instead of OR across all.
   */
  private async detectBestMatchingColumn(
    searchTerm: string,
    externalDbQuery: (sql: string, params?: any[]) => Promise<any[]>
  ): Promise<{ column: string; count: number; functionName: string; paramName: string } | null> {
    if (!searchTerm || searchTerm.trim().length < 2) return null;
    
    const term = searchTerm.trim();
    console.log(`[ColumnDetect] Starting detection for term: "${term}" (length: ${term.length})`);
    console.log(`[ColumnDetect] =========================================`);
    
    const columnMappings = [
      { column: 'Company', functionName: 'get_projects_by_combined_filters', paramName: 'company' },
      { column: 'Client', functionName: 'get_projects_by_client', paramName: 'client' },
      { column: 'PointOfContact', functionName: 'get_projects_by_poc', paramName: 'poc' },
      { column: 'ProjectType', functionName: 'get_projects_by_project_type', paramName: 'project_type' },
      { column: 'Division', functionName: 'get_projects_by_division', paramName: 'division' },
      { column: 'Department', functionName: 'get_projects_by_department', paramName: 'department' },
      { column: 'Title', functionName: 'search_projects_by_keyword', paramName: 'keyword' },
      { column: 'RequestCategory', functionName: 'get_projects_by_category', paramName: 'category' },
      { column: 'City', functionName: 'get_projects_by_city', paramName: 'city' },
      { column: 'ServiceType', functionName: 'get_projects_by_service_type', paramName: 'service_type' },
      { column: 'State', functionName: 'get_projects_by_combined_filters', paramName: 'states', displayName: 'State', isArray: true },
      { column: 'Region', functionName: 'get_projects_by_combined_filters', paramName: 'regions', displayName: 'Region', isArray: true },
      { column: 'Country', functionName: 'get_projects_by_combined_filters', paramName: 'countries', displayName: 'Country', isArray: true },
    ];
    
    try {
      const countPromises = columnMappings.map(async (mapping) => {
        const sql = `SELECT COUNT(*) as cnt FROM "${TABLE}" WHERE "${mapping.column}" LIKE @p1`;
        const result = await externalDbQuery(sql, [`%${term}%`]);
        const count = result[0]?.cnt || 0;
        return { ...mapping, count };
      });
      
      const results = await Promise.all(countPromises);
      results.forEach(r => console.log(`[ColumnDetect]   ${r.column}: ${r.count} matches`));
      
      const best = results.reduce((a, b) => (a.count > b.count ? a : b));
      
      if (best.count >= 1) {
        console.log(`[ColumnDetect] âœ“ Best: ${best.column} (${best.count}) â†’ ${best.functionName}(${best.paramName})`);
        return { column: best.column, count: best.count, functionName: best.functionName, paramName: best.paramName };
      }
      
      console.log(`[ColumnDetect] âœ— No significant matches found`);
      return null;
    } catch (error) {
      console.error(`[ColumnDetect] Error:`, error);
      return null;
    }
  }

  /**
   * Detect ALL columns with matches for disambiguation UI
   * Returns sorted array of columns with match counts > 0
   */
  private async detectAllMatchingColumns(
    searchTerm: string,
    externalDbQuery: (sql: string, params?: any[]) => Promise<any[]>
  ): Promise<Array<{ column: string; count: number; functionName: string; paramName: string; displayName: string; isArray?: boolean }>> {
    if (!searchTerm || searchTerm.trim().length < 2) return [];
    
    const term = searchTerm.trim();
    console.log(`[ColumnDetectAll] Starting detection for term: "${term}"`);
    
    const columnMappings = [
      { column: 'Client', functionName: 'get_projects_by_client', paramName: 'client', displayName: 'Client' },
      { column: 'Company', functionName: 'get_projects_by_combined_filters', paramName: 'company', displayName: 'Company' },
      { column: 'PointOfContact', functionName: 'get_projects_by_poc', paramName: 'poc', displayName: 'Point of Contact' },
      { column: 'ProjectType', functionName: 'get_projects_by_project_type', paramName: 'project_type', displayName: 'Project Type' },
      { column: 'Division', functionName: 'get_projects_by_division', paramName: 'division', displayName: 'Division' },
      { column: 'Department', functionName: 'get_projects_by_department', paramName: 'department', displayName: 'Department' },
      { column: 'Title', functionName: 'search_projects_by_keyword', paramName: 'keyword', displayName: 'Project Title' },
      { column: 'RequestCategory', functionName: 'get_projects_by_category', paramName: 'category', displayName: 'Category' },
      { column: 'City', functionName: 'get_projects_by_city', paramName: 'city', displayName: 'City' },
      { column: 'ServiceType', functionName: 'get_projects_by_service_type', paramName: 'service_type', displayName: 'Service Type' },
      { column: 'State', functionName: 'get_projects_by_combined_filters', paramName: 'states', displayName: 'State', isArray: true },
      { column: 'Region', functionName: 'get_projects_by_combined_filters', paramName: 'regions', displayName: 'Region', isArray: true },
      { column: 'Country', functionName: 'get_projects_by_combined_filters', paramName: 'countries', displayName: 'Country', isArray: true },
      { column: 'StatusChoice', functionName: 'get_projects_by_status', paramName: 'status', displayName: 'Status', isArray: true },
    ];
    
    try {
      // FLEXIBLE WHITESPACE MATCHING: Handle "waste water" vs "wastewater"
      // Generate normalized variants: original, no-spaces, and flexible pattern
      const termNoSpaces = term.replace(/\s+/g, ''); // "waste water" â†’ "wastewater"
      const termFlexible = term.replace(/\s+/g, '%'); // "waste water" â†’ "waste%water"
      const needsFlexibleMatch = term.includes(' ') && termNoSpaces !== term;
      
      if (needsFlexibleMatch) {
        console.log(`[ColumnDetectAll] Flexible matching: "${term}" â†’ also searching "${termNoSpaces}" and "${termFlexible}"`);
      }
      
      const countPromises = columnMappings.map(async (mapping) => {
        let sql: string;
        let params: string[];
        
        // SMART COLUMN SEARCH: Strip column-specific keywords for better matching
        // "northeast region" searching Region column â†’ also search "northeast"
        // "california state" searching State column â†’ also search "california"
        let smartTerm = term;
        let aliasTerms: string[] = []; // Additional terms from common aliases
        const columnLower = mapping.column.toLowerCase();
        if (columnLower === 'region') {
          smartTerm = term.replace(/\s*(region|regions|area|areas)\s*/gi, ' ').trim();
        } else if (columnLower === 'state') {
          smartTerm = term.replace(/\s*(state|states|province|provinces)\s*/gi, ' ').trim();
          // State aliases (US + Indian states)
          const stateAliases: Record<string, string> = {
            // US States
            'newyork': 'New York', 'ny': 'New York',
            'newjersey': 'New Jersey', 'nj': 'New Jersey',
            'northcarolina': 'North Carolina', 'nc': 'North Carolina',
            'southcarolina': 'South Carolina', 'sc': 'South Carolina',
            'california': 'California', 'ca': 'California',
            'texas': 'Texas', 'tx': 'Texas',
            'florida': 'Florida', 'fl': 'Florida',
            'washingtondc': 'District of Columbia', 'dc': 'District of Columbia',
            'pennsylvania': 'Pennsylvania', 'pa': 'Pennsylvania',
            'illinois': 'Illinois', 'il': 'Illinois',
            'ohio': 'Ohio', 'oh': 'Ohio',
            'georgia': 'Georgia', 'ga': 'Georgia',
            'michigan': 'Michigan', 'mi': 'Michigan',
            // Indian States - variations/misspellings
            'maharashtra': 'Maharashtra', 'mahastra': 'Maharashtra', 'maharastra': 'Maharashtra', 'mahrastra': 'Maharashtra',
            'karnataka': 'Karnataka', 'karnatak': 'Karnataka', 'kernataka': 'Karnataka',
            'tamilnadu': 'Tamil Nadu', 'tamil': 'Tamil Nadu',
            'andhrapradesh': 'Andhra Pradesh', 'andhra': 'Andhra Pradesh', 'ap': 'Andhra Pradesh',
            'telangana': 'Telangana', 'telengana': 'Telangana',
            'westbengal': 'West Bengal', 'bengal': 'West Bengal', 'wb': 'West Bengal',
            'madhyapradesh': 'Madhya Pradesh', 'mp': 'Madhya Pradesh',
            'uttarpradesh': 'Uttar Pradesh', 'up': 'Uttar Pradesh',
            'rajasthan': 'Rajasthan', 'rajsthan': 'Rajasthan',
            'gujarat': 'Gujarat', 'gujrat': 'Gujarat', 'gj': 'Gujarat',
            'kerala': 'Kerala', 'kerela': 'Kerala',
            'punjab': 'Punjab', 'panjab': 'Punjab',
            'haryana': 'Haryana', 'hariyana': 'Haryana',
            'delhi': 'Delhi', 'newdelhi': 'New Delhi',
            'mumbai': 'Mumbai', 'bombay': 'Mumbai',
            'bangalore': 'Bangalore', 'bengaluru': 'Bangalore',
            'chennai': 'Chennai', 'madras': 'Chennai',
            'kolkata': 'Kolkata', 'calcutta': 'Kolkata',
            'hyderabad': 'Hyderabad', 'hydrabad': 'Hyderabad',
          };
          const aliasKey = smartTerm.toLowerCase().replace(/\s+/g, '');
          if (stateAliases[aliasKey]) aliasTerms.push(stateAliases[aliasKey]);
        } else if (columnLower === 'country') {
          smartTerm = term.replace(/\s*(country|countries|nation|nations)\s*/gi, ' ').trim();
          // Country aliases - map common names to database values
          const countryAliases: Record<string, string[]> = {
            'usa': ['United States', 'US', 'USA', 'America'],
            'us': ['United States', 'US', 'USA'],
            'america': ['United States', 'America', 'USA'],
            'unitedstates': ['United States'],
            'uk': ['United Kingdom', 'UK', 'Britain', 'England'],
            'unitedkingdom': ['United Kingdom'],
            'britain': ['United Kingdom', 'Great Britain'],
            'england': ['United Kingdom', 'England'],
            'uae': ['United Arab Emirates', 'UAE', 'Emirates'],
            'unitedarabemirates': ['United Arab Emirates'],
            'ksa': ['Saudi Arabia', 'KSA'],
            'saudiarabia': ['Saudi Arabia'],
          };
          const aliasKey = smartTerm.toLowerCase().replace(/\s+/g, '');
          if (countryAliases[aliasKey]) aliasTerms = countryAliases[aliasKey];
        }
        
        // Use smart term if it's different and not empty
        const searchTerm = (smartTerm && smartTerm !== term && smartTerm.length >= 2) ? smartTerm : term;
        const searchTermNoSpaces = searchTerm.replace(/\s+/g, '');
        const searchTermFlexible = searchTerm.replace(/\s+/g, '%');
        
        // Build SQL with alias terms if available
        if (aliasTerms.length > 0) {
          // Search original term plus all alias terms
          const conditions = [`"${mapping.column}" LIKE @p1`, `"${mapping.column}" LIKE @p2`];
          params = [`%${term}%`, `%${searchTerm}%`];
          aliasTerms.forEach((alias, idx) => {
            conditions.push(`"${mapping.column}" LIKE @p${idx + 3}`);
            params.push(`%${alias}%`);
          });
          sql = `SELECT COUNT(*) as cnt FROM "${TABLE}" WHERE ${conditions.join(' OR ')}`;
        } else if (needsFlexibleMatch || searchTerm !== term) {
          // Search for original term OR smart term OR no-spaces version OR flexible pattern
          sql = `SELECT COUNT(*) as cnt FROM "${TABLE}" WHERE "${mapping.column}" LIKE @p1 OR "${mapping.column}" LIKE @p2 OR "${mapping.column}" LIKE @p3 OR "${mapping.column}" LIKE @p4`;
          params = [`%${term}%`, `%${searchTerm}%`, `%${searchTermNoSpaces}%`, `%${searchTermFlexible}%`];
        } else {
          sql = `SELECT COUNT(*) as cnt FROM "${TABLE}" WHERE "${mapping.column}" LIKE @p1`;
          params = [`%${term}%`];
        }
        
        const result = await externalDbQuery(sql, params);
        const count = result[0]?.cnt || 0;
        
        // Log when smart matching finds results
        if (count > 0 && searchTerm !== term) {
          console.log(`[ColumnDetectAll] SMART MATCH: "${term}" â†’ "${searchTerm}" in ${mapping.column} = ${count} matches`);
        }
        
        return { ...mapping, count };
      });
      
      const results = await Promise.all(countPromises);
      const withMatches = results.filter(r => r.count > 0).sort((a, b) => b.count - a.count);
      console.log(`[ColumnDetectAll] Found ${withMatches.length} columns with matches`);
      return withMatches;
    } catch (error) {
      console.error(`[ColumnDetectAll] Error:`, error);
      return [];
    }
  }

  /**
   * â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
   * UNIFIED ENTITY RESOLUTION - "HEAD CHEF" PATTERN
   * â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
   * 
   * This function consolidates all entity resolution logic into ONE place:
   * 1. Normalize LLM output (fix arrays, extract status)
   * 2. Merge previous context for follow-ups
   * 3. Extract entity term from question/args
   * 4. Run cache detection on ALL columns
   * 5. Pick winner (highest matches) or prepare disambiguation
   * 6. Return IMMUTABLE result that cannot be changed by later code
   * 
   * This prevents the "5 cooks fighting" problem where multiple scattered
   * logic blocks each mutate args and undo each other's work.
   */
  private async resolveEntityUnified(
    question: string,
    llmArgs: Record<string, any>,
    previousContext?: { question: string; function_name: string; arguments: Record<string, any> },
    externalDbQuery?: (sql: string, params?: any[]) => Promise<any[]>
  ): Promise<{
    entity: { column: string; paramName: string; value: string; displayName: string } | null;
    status: string[];
    functionName: string;
    allArgs: Record<string, any>;
    disambiguation?: Array<{ column: string; count: number; displayName: string }>;
    locked: boolean;
  }> {
    console.log(`[HeadChef] â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•`);
    console.log(`[HeadChef] Starting unified entity resolution`);
    console.log(`[HeadChef] Question: "${question}"`);
    console.log(`[HeadChef] LLM args: ${JSON.stringify(llmArgs)}`);
    console.log(`[HeadChef] Has previousContext: ${!!previousContext}`);
    
    // Step 1: Initialize with LLM args
    const args: Record<string, any> = { ...llmArgs };
    let functionName = llmArgs._function_name || 'get_projects_by_combined_filters';
    
    // Step 2: Normalize status (array handling, synonym resolution)
    let status: string[] = [];
    if (args.status) {
      if (Array.isArray(args.status) && args.status.length > 0) {
        status = args.status.flat().filter(Boolean);
      } else if (typeof args.status === 'string') {
        status = [args.status];
      }
    }
    
    // Extract status from question if not in args
    const questionLower = question.toLowerCase();
    if (status.length === 0) {
      if (questionLower.includes('open') || questionLower.includes('pending') || questionLower.includes('in progress')) {
        status = this.resolveStatusSynonym('open');
        console.log(`[HeadChef] Extracted status from question: open â†’ ${JSON.stringify(status)}`);
      } else if (questionLower.includes('won') || questionLower.includes('awarded')) {
        status = this.resolveStatusSynonym('won');
        console.log(`[HeadChef] Extracted status from question: won â†’ ${JSON.stringify(status)}`);
      } else if (questionLower.includes('lost')) {
        status = this.resolveStatusSynonym('lost');
        console.log(`[HeadChef] Extracted status from question: lost â†’ ${JSON.stringify(status)}`);
      } else if (questionLower.includes('closed')) {
        status = this.resolveStatusSynonym('closed');
        console.log(`[HeadChef] Extracted status from question: closed â†’ ${JSON.stringify(status)}`);
      }
    }
    args.status = status;
    
    // Step 3: Merge previous context for follow-ups
    if (previousContext?.arguments) {
      const prev = previousContext.arguments;
      
      // Preserve entity from previous query if not overridden
      if (prev.client && prev._client_already_applied && !args.client) {
        args.client = prev.client;
        args._client_already_applied = true;
        console.log(`[HeadChef] Preserved client from previous: "${prev.client}"`);
      }
      if (prev.company && prev._company_already_applied && !args.company) {
        args.company = prev.company;
        args._company_already_applied = true;
        console.log(`[HeadChef] Preserved company from previous: "${prev.company}"`);
      }
      if (prev.poc && prev._poc_already_applied && !args.poc) {
        args.poc = prev.poc;
        args._poc_already_applied = true;
        console.log(`[HeadChef] Preserved poc from previous: "${prev.poc}"`);
      }
      if (prev.keyword && !args.keyword) {
        args.keyword = prev.keyword;
        console.log(`[HeadChef] Preserved keyword from previous: "${prev.keyword}"`);
      }
      // CRITICAL: Preserve category from disambiguation selection
      if (prev.category && prev._category_already_applied && !args.category) {
        args.category = prev.category;
        args._category_already_applied = true;
        if (prev._disambiguation_column) args._disambiguation_column = prev._disambiguation_column;
        console.log(`[HeadChef] Preserved category from previous: "${prev.category}"`);
      }
      // CRITICAL: Preserve status from previous query if current query doesn't override it
      if (prev.status && (!args.status || args.status.length === 0)) {
        args.status = prev.status;
        console.log(`[HeadChef] Preserved status from previous: ${JSON.stringify(prev.status)}`);
      }
      
      // Preserve year from previous query if current query doesn't override it
      if (prev.year && !args.year) {
        args.year = prev.year;
        console.log(`[HeadChef] Preserved year from previous: ${prev.year}`);
      }
      
      // Preserve date range from previous query
      if (prev.start_date && !args.start_date) {
        args.start_date = prev.start_date;
        console.log(`[HeadChef] Preserved start_date from previous: ${prev.start_date}`);
      }
      if (prev.end_date && !args.end_date) {
        args.end_date = prev.end_date;
        console.log(`[HeadChef] Preserved end_date from previous: ${prev.end_date}`);
      }
    }
    
    // Step 4: Extract entity term (company/client/poc/keyword)
    let entityTerm: string | null = null;
    let entitySource: string = '';
    
    // Check if we already have a locked entity
    if (args._client_already_applied && args.client) {
      console.log(`[HeadChef] Entity already locked: Client = "${args.client}"`);
      return {
        entity: { column: 'Client', paramName: 'client', value: args.client, displayName: 'Client' },
        status,
        functionName: 'get_projects_by_client',
        allArgs: args,
        locked: true
      };
    }
    if (args._company_already_applied && args.company) {
      console.log(`[HeadChef] Entity already locked: Company = "${args.company}"`);
      return {
        entity: { column: 'Company', paramName: 'company', value: args.company, displayName: 'Company' },
        status,
        functionName: 'get_projects_by_company',
        allArgs: args,
        locked: true
      };
    }
    if (args._poc_already_applied && args.poc) {
      console.log(`[HeadChef] Entity already locked: POC = "${args.poc}"`);
      return {
        entity: { column: 'PointOfContact', paramName: 'poc', value: args.poc, displayName: 'Point of Contact' },
        status,
        functionName: 'get_projects_by_poc',
        allArgs: args,
        locked: true
      };
    }
    
    // Find entity term from args (priority: company > client > poc > keyword)
    if (args.company && typeof args.company === 'string') {
      entityTerm = args.company;
      entitySource = 'company';
    } else if (args.client && typeof args.client === 'string') {
      entityTerm = args.client;
      entitySource = 'client';
    } else if (args.poc && typeof args.poc === 'string') {
      entityTerm = args.poc;
      entitySource = 'poc';
    } else if (args.keyword && typeof args.keyword === 'string') {
      entityTerm = args.keyword;
      entitySource = 'keyword';
    }
    
    console.log(`[HeadChef] Entity term: "${entityTerm}" (source: ${entitySource})`);
    
    // Step 5: Run cache detection on ALL columns
    if (entityTerm && externalDbQuery) {
      const allMatches = await this.detectAllMatchingColumns(entityTerm, externalDbQuery);
      console.log(`[HeadChef] Cache detection found ${allMatches.length} columns with matches`);
      
      if (allMatches.length === 0) {
        // No matches - keep original
        console.log(`[HeadChef] No matches found, keeping original`);
        return {
          entity: null,
          status,
          functionName,
          allArgs: args,
          locked: false
        };
      }
      
      if (allMatches.length === 1) {
        // Single match - auto-select
        const match = allMatches[0];
        console.log(`[HeadChef] âœ“ Single match: ${match.column} (${match.count} results)`);
        
        // Clear other entity params and set the winning one
        delete args.company;
        delete args.client;
        delete args.poc;
        delete args.keyword;
        // Normalize state names when setting state-related parameters
        let normalizedValue = match.column === 'State' ? normalizeStateName(entityTerm) : entityTerm;
        // Use array format for geographic columns (State, Region, Country)
        console.log(`[HeadChef] ğŸ” Setting param: paramName="${match.paramName}", isArray=${(match as any).isArray}, column="${match.column}"`);
        if ((match as any).isArray) {
          args[match.paramName] = [normalizedValue];
          console.log(`[HeadChef] âœ“ Set as ARRAY: ${match.paramName}=[${normalizedValue}]`);
        } else {
          args[match.paramName] = normalizedValue;
          console.log(`[HeadChef] âœ“ Set as STRING: ${match.paramName}=${normalizedValue}`);
        }
        args[`_${match.paramName}_already_applied`] = true;
        
        return {
          entity: { column: match.column, paramName: match.paramName, value: normalizedValue, displayName: match.displayName },
          status,
          functionName: match.functionName,
          allArgs: args,
          locked: true
        };
      }
      
      // Multiple matches - check if top match is significantly better (2x)
      const topMatch = allMatches[0];
      const secondMatch = allMatches[1];
      
      if (topMatch.count > secondMatch.count * 2) {
        // Top match is 2x better - auto-select
        console.log(`[HeadChef] âœ“ Top match 2x better: ${topMatch.column} (${topMatch.count}) vs ${secondMatch.column} (${secondMatch.count})`);
        
        delete args.company;
        delete args.client;
        delete args.poc;
        delete args.keyword;
        // Normalize state names when setting state-related parameters
        let normalizedTopValue = topMatch.column === 'State' ? normalizeStateName(entityTerm) : entityTerm;
        // Use array format for geographic columns (State, Region, Country)
        if ((topMatch as any).isArray) {
          args[topMatch.paramName] = [normalizedTopValue];
        } else {
          args[topMatch.paramName] = normalizedTopValue;
        }
        args[`_${topMatch.paramName}_already_applied`] = true;
        
        return {
          entity: { column: topMatch.column, paramName: topMatch.paramName, value: normalizedTopValue, displayName: topMatch.displayName },
          status,
          functionName: topMatch.functionName,
          allArgs: args,
          locked: true
        };
      }
      
      // Multiple matches with similar counts - need disambiguation
      console.log(`[HeadChef] âš  Disambiguation needed: ${allMatches.map(m => `${m.column}(${m.count})`).join(', ')}`);
      return {
        entity: null,
        status,
        functionName: 'disambiguation_required',
        allArgs: args,
        disambiguation: allMatches.map(m => ({ column: m.column, count: m.count, displayName: m.displayName, paramName: m.paramName, functionName: m.functionName })),
        locked: false
      };
    }
    
    // No entity term found - return as-is
    console.log(`[HeadChef] No entity term to resolve`);
    return {
      entity: null,
      status,
      functionName,
      allArgs: args,
      locked: false
    };
  }
  
  /**
   * Load valid category and project type values from database
   */
  private async loadCategoryTypeCache(
    externalDbQuery: (sql: string, params?: any[]) => Promise<any[]>
  ): Promise<void> {
    // Initialize column cache if not ready
    if (!columnCache.isReady() || columnCache.needsRefresh()) {
      await columnCache.initialize(externalDbQuery);
    }
    
    if (this.categoryCache && this.projectTypeCache) return;
    
    try {
      // Load categories
      const categoryResult = await externalDbQuery(
        `SELECT TOP 100 DISTINCT "RequestCategory" as value FROM "${TABLE}" WHERE "RequestCategory" IS NOT NULL AND "RequestCategory" != ''`,
        []
      );
      this.categoryCache = categoryResult.map(r => r.value).filter(Boolean);
      
      // Load project types
      const typeResult = await externalDbQuery(
        `SELECT TOP 200 DISTINCT "ProjectType" as value FROM "${TABLE}" WHERE "ProjectType" IS NOT NULL AND "ProjectType" != ''`,
        []
      );
      this.projectTypeCache = typeResult.map(r => r.value).filter(Boolean);
      
      console.log(`[AutoRetry] Loaded ${this.categoryCache.length} categories, ${this.projectTypeCache.length} project types`);
    } catch (error) {
      console.error(`[AutoRetry] Failed to load cache:`, error);
      this.categoryCache = [];
      this.projectTypeCache = [];
    }
  }

  /**
   * Resolve status synonyms using cache-based lookup
   * "open" â†’ ["Submitted", "Pending", "In Review", "Under Consideration"]
   * "won" â†’ ["Won", "Awarded"]
   */
  private resolveStatusSynonym(status: string): string[] {
    return columnCache.resolveStatus(status);
  }

  /**
   * Resolve region aliases using cache-based lookup
   * "uae" â†’ "MENA"
   * "middle east" â†’ "MENA"
   */
  private resolveRegionAlias(region: string): string[] {
    return columnCache.resolveRegion(region);
  }

  /**
   * Resolve project type synonym using cache-based lookup
   * "highway" â†’ "Road/Highway"
   */
  private resolveProjectTypeSynonym(projectType: string): string | null {
    return columnCache.resolveProjectType(projectType);
  }
  
  /**
   * Find the closest matching category or project type
   * Returns { match: string, column: 'category' | 'project_type', similarity: number } or null
   */
  private async findClosestCategoryMatch(
    searchTerm: string,
    externalDbQuery: (sql: string, params?: any[]) => Promise<any[]>
  ): Promise<{ match: string; column: 'category' | 'project_type'; similarity: number } | null> {
    await this.loadCategoryTypeCache(externalDbQuery);
    
    let bestMatch: { match: string; column: 'category' | 'project_type'; similarity: number } | null = null;
    const minSimilarity = 0.5; // Minimum threshold for a valid match
    
    // Check categories
    for (const cat of this.categoryCache || []) {
      const sim = this.calculateSimilarity(searchTerm, cat);
      if (sim > minSimilarity && (!bestMatch || sim > bestMatch.similarity)) {
        bestMatch = { match: cat, column: 'category', similarity: sim };
      }
    }
    
    // Check project types
    for (const type of this.projectTypeCache || []) {
      const sim = this.calculateSimilarity(searchTerm, type);
      if (sim > minSimilarity && (!bestMatch || sim > bestMatch.similarity)) {
        bestMatch = { match: type, column: 'project_type', similarity: sim };
      }
    }
    
    if (bestMatch) {
      console.log(`[AutoRetry] Best match for "${searchTerm}": "${bestMatch.match}" (${bestMatch.column}, ${(bestMatch.similarity * 100).toFixed(1)}%)`);
    }
    
    return bestMatch;
  }

  /**
   * Fetch valid database values to help LLM self-correction
   * Returns hints about valid statuses, categories, project types, etc.
   */
  private async fetchDatabaseHints(
    externalDbQuery: (sql: string, params?: any[]) => Promise<any[]>
  ): Promise<{
    validStatuses?: string[];
    validCategories?: string[];
    validProjectTypes?: string[];
    validClients?: string[];
    validStates?: string[];
  }> {
    const hints: {
      validStatuses?: string[];
      validCategories?: string[];
      validProjectTypes?: string[];
      validClients?: string[];
      validStates?: string[];
    } = {};
    
    try {
      // Run all queries in parallel for speed
      const [statusResult, categoryResult, typeResult, stateResult, clientResult] = await Promise.all([
        externalDbQuery(
          `SELECT DISTINCT "StatusChoice" as value FROM "${TABLE}" WHERE "StatusChoice" IS NOT NULL AND "StatusChoice" != '' ORDER BY "StatusChoice" OFFSET 0 ROWS FETCH NEXT 20 ROWS ONLY`,
          []
        ).catch(() => []),
        externalDbQuery(
          `SELECT DISTINCT "RequestCategory" as value FROM "${TABLE}" WHERE "RequestCategory" IS NOT NULL AND "RequestCategory" != '' ORDER BY "RequestCategory" OFFSET 0 ROWS FETCH NEXT 30 ROWS ONLY`,
          []
        ).catch(() => []),
        externalDbQuery(
          `SELECT DISTINCT "ProjectType" as value FROM "${TABLE}" WHERE "ProjectType" IS NOT NULL AND "ProjectType" != '' ORDER BY "ProjectType" OFFSET 0 ROWS FETCH NEXT 40 ROWS ONLY`,
          []
        ).catch(() => []),
        externalDbQuery(
          `SELECT DISTINCT "State" as value FROM "${TABLE}" WHERE "State" IS NOT NULL AND "State" != '' ORDER BY "State" OFFSET 0 ROWS FETCH NEXT 60 ROWS ONLY`,
          []
        ).catch(() => []),
        externalDbQuery(
          `SELECT DISTINCT "Client" as value FROM "${TABLE}" WHERE "Client" IS NOT NULL AND "Client" != '' ORDER BY "Client" OFFSET 0 ROWS FETCH NEXT 20 ROWS ONLY`,
          []
        ).catch(() => [])
      ]);
      
      if (statusResult.length) hints.validStatuses = statusResult.map(r => r.value);
      if (categoryResult.length) hints.validCategories = categoryResult.map(r => r.value);
      if (typeResult.length) hints.validProjectTypes = typeResult.map(r => r.value);
      if (stateResult.length) hints.validStates = stateResult.map(r => r.value);
      if (clientResult.length) hints.validClients = clientResult.map(r => r.value);
      
      console.log(`[SelfCorrection] Fetched DB hints: ${hints.validStatuses?.length || 0} statuses, ${hints.validCategories?.length || 0} categories, ${hints.validProjectTypes?.length || 0} types`);
    } catch (error) {
      console.error(`[SelfCorrection] Failed to fetch DB hints:`, error);
    }
    
    return hints;
  }

  getQueryTemplates() {
    return this.queryTemplates;
  }

  private initializeQueryTemplates(): Record<string, QueryTemplate> {
    return {
      // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
      // BASIC DATE QUERIES
      // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
      
      get_projects_by_year: {
        sql: `SELECT * FROM "${TABLE}" 
              WHERE YEAR(TRY_CONVERT(DATE, "ConstStartDate")) = @p1
              AND "ConstStartDate" > '2000-01-01'
              {status_filter}
              {additional_filters}
              ORDER BY CAST(NULLIF("Fee", '') AS NUMERIC) DESC
              {limit_clause}`,
        params: ["year"],
        param_types: ["int"],
        optional_params: ["size", "status", "state_code", "company",
          "client",
          "organization", "client", "categories", "min_fee", "max_fee", "min_win", "max_win", "limit"],
        chart_type: "bar",
        chart_field: "Fee",
      },

      get_projects_by_date_range: {
        sql: `SELECT * FROM "${TABLE}" 
              WHERE "ConstStartDate" >= TRY_CONVERT(DATE, @p1) 
              AND "ConstStartDate" <= TRY_CONVERT(DATE, @p2)
              AND "ConstStartDate" > '2000-01-01'
              {status_filter}
              {additional_filters}
              ORDER BY CAST(NULLIF("Fee", '') AS NUMERIC) DESC
              {limit_clause}`,
        params: ["start_date", "end_date"],
        param_types: ["str", "str"],
        optional_params: ["size", "status", "state_code", "company",
          "client",
          "organization", "client", "categories", "min_fee", "max_fee", "min_win", "max_win", "limit"],
        chart_type: "bar",
        chart_field: "Fee",
      },

      get_projects_by_quarter: {
        sql: `SELECT * FROM "${TABLE}" 
              WHERE YEAR(TRY_CONVERT(DATE, "ConstStartDate")) = @p1
              AND DATEPART(QUARTER, TRY_CONVERT(DATE, "ConstStartDate")) = @p2
              AND "ConstStartDate" > '2000-01-01'
              {status_filter}
              {additional_filters}
              ORDER BY CAST(NULLIF("Fee", '') AS NUMERIC) DESC
              {limit_clause}`,
        params: ["year", "quarter"],
        param_types: ["int", "int"],
        optional_params: ["size", "status", "state_code", "company",
          "client",
          "organization", "client", "categories", "min_fee", "max_fee", "min_win", "max_win", "limit"],
        chart_type: "bar",
        chart_field: "Fee",
      },

      get_projects_by_years: {
        sql: `SELECT * FROM "${TABLE}" 
              WHERE YEAR(TRY_CONVERT(DATE, "ConstStartDate")) IN (SELECT value FROM STRING_SPLIT(@p1, ','))
              AND "ConstStartDate" > '2000-01-01'
              {status_filter}
              {additional_filters}
              ORDER BY "ConstStartDate", CAST(NULLIF("Fee", '') AS NUMERIC) DESC
              {limit_clause}`,
        params: ["years"],
        param_types: ["array"],
        optional_params: ["size", "status", "state_code", "company",
          "client",
          "organization", "client", "categories", "min_fee", "max_fee", "min_win", "max_win", "limit"],
        chart_type: "bar",
        chart_field: "Fee",
      },

      // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
      // PID-BASED QUERIES (for referencing specific projects)
      // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
      
      get_projects_by_pids: {
        sql: `SELECT * FROM "${TABLE}" 
              WHERE "Title" IN (SELECT value FROM STRING_SPLIT(@p1, ','))
              {status_filter}
              {additional_filters}
              ORDER BY CAST(NULLIF("Fee", '') AS NUMERIC) {sort_direction}
              {limit_clause}`,
        params: ["pids"],
        param_types: ["array"],
        optional_params: ["limit", "state_code", "states", "status", "company",
          "client",
          "organization", "client", "categories", "min_fee", "max_fee", "sort_direction"],
        chart_type: "bar",
        chart_field: "ChanceOfSuccess",
      },

      // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
      // RANKING QUERIES
      // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

      get_largest_projects: {
        sql: `SELECT * FROM "${TABLE}" 
              WHERE "Fee" IS NOT NULL AND "Fee" != ''
              {date_filter}
              {status_filter}
              {additional_filters}
              ORDER BY CAST("Fee" AS NUMERIC) DESC
              {limit_clause}`,
        params: [],
        param_types: [],
        optional_params: ["start_year", "end_year", "limit", "offset", "start_date", "end_date", "size", "status", "state_code", "states", "regions", "company",
          "client",
          "organization", "client", "categories", "project_type", "min_fee", "max_fee", "min_win", "max_win"],
        chart_type: "bar",
        chart_field: "Fee",
      },

      get_smallest_projects: {
        sql: `SELECT * FROM "${TABLE}" 
              WHERE "Fee" IS NOT NULL AND "Fee" != ''
              AND CAST("Fee" AS NUMERIC) > 0
              {date_filter}
              {status_filter}
              {additional_filters}
              ORDER BY CAST("Fee" AS NUMERIC) ASC
              {limit_clause}`,
        params: [],
        param_types: [],
        optional_params: ["start_year", "end_year", "limit", "offset", "start_date", "end_date", "size", "status", "state_code", "states", "regions", "company",
          "client",
          "organization", "client", "categories", "project_type", "min_fee", "max_fee", "min_win", "max_win"],
        chart_type: "bar",
        chart_field: "Fee",
      },

      get_largest_in_region: {
        sql: `SELECT * FROM "${TABLE}" 
              WHERE {state_filter}
              AND "Fee" IS NOT NULL AND "Fee" != ''
              {status_filter}
              {additional_filters}
              ORDER BY CAST("Fee" AS NUMERIC) DESC
              {limit_clause}`,
        params: [],
        param_types: [],
        optional_params: ["state_code", "states", "limit", "offset", "size", "status", "company",
          "client",
          "organization", "client", "categories", "min_fee", "max_fee", "min_win", "max_win", "start_date", "end_date"],
        chart_type: "bar",
        chart_field: "Fee",
      },

      get_largest_by_category: {
        sql: `SELECT * FROM "${TABLE}" 
              WHERE {category_or_type_condition}
              AND "Fee" IS NOT NULL AND "Fee" != ''
              {status_filter}
              {additional_filters}
              ORDER BY CAST("Fee" AS NUMERIC) DESC
              {limit_clause}`,
        params: [],
        param_types: [],
        optional_params: ["limit", "offset", "size", "status", "state_code", "company",
          "client",
          "organization", "client", "min_fee", "max_fee", "min_win", "max_win", "start_date", "end_date"],
        chart_type: "bar",
        chart_field: "Fee",
      },

      // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
      // CATEGORY / TYPE QUERIES
      // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

      get_projects_by_category: {
        sql: `SELECT * FROM "${TABLE}" 
              WHERE {category_or_type_condition}
              {status_filter}
              {additional_filters}
              ORDER BY CAST(NULLIF("Fee", '') AS NUMERIC) DESC
              {limit_clause}`,
        params: [],
        param_types: [],
        optional_params: ["size", "status", "state_code", "states", "company",
          "client",
          "organization", "client", "min_fee", "max_fee", "min_win", "max_win", "start_date", "end_date", "year", "limit", "department", "division"],
        chart_type: "bar",
        chart_field: "Fee",
      },

      get_projects_by_project_type: {
        sql: `SELECT * FROM "${TABLE}" 
              WHERE {project_type_condition}
              {status_filter}
              {additional_filters}
              ORDER BY CAST(NULLIF("Fee", '') AS NUMERIC) DESC
              {limit_clause}`,
        params: [],
        param_types: [],
        optional_params: ["project_type", "project_types", "size", "status", "state_code", "states", "company",
          "client",
          "organization", "client", "categories", "min_fee", "max_fee", "min_win", "max_win", "start_date", "end_date", "limit", "department", "division", "year"],
        chart_type: "bar",
        chart_field: "Fee",
      },

      get_projects_by_service_type: {
        sql: `SELECT * FROM "${TABLE}" 
              WHERE {service_type_condition}
              {status_filter}
              {additional_filters}
              ORDER BY CAST(NULLIF("Fee", '') AS NUMERIC) DESC
              {limit_clause}`,
        params: [],
        param_types: [],
        optional_params: ["service_type", "size", "status", "state_code", "states", "company",
          "client",
          "organization", "categories", "min_fee", "max_fee", "min_win", "max_win", "start_date", "end_date", "limit", "department", "division", "year"],
        chart_type: "bar",
        chart_field: "Fee",
      },

      get_projects_by_multiple_categories: {
        sql: `SELECT * FROM "${TABLE}" 
              WHERE EXISTS (SELECT 1 FROM STRING_SPLIT(@p1, ',') s WHERE "RequestCategory" LIKE '%' + LTRIM(RTRIM(s.value)) + '%')
              {status_filter}
              {additional_filters}
              ORDER BY CAST(NULLIF("Fee", '') AS NUMERIC) DESC
              {limit_clause}`,
        params: ["categories"],
        param_types: ["array"],
        optional_params: ["size", "status", "state_code", "company",
          "client",
          "organization", "client", "min_fee", "max_fee", "min_win", "max_win", "start_date", "end_date", "limit"],
        chart_type: "bar",
        chart_field: "Fee",
      },

      // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
      // TAG QUERIES
      // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•


      // Title/Project Name breakdown - most used/common project names
      get_top_titles: {
        sql: `SELECT "Title" as title,
                     COUNT(*) as project_count,
                     SUM(CAST(NULLIF("Fee", '') AS NUMERIC)) as total_value,
                     AVG(CAST(NULLIF("ChanceOfSuccess", '') AS NUMERIC)) as avg_win_rate
              FROM "${TABLE}"
              WHERE "Title" IS NOT NULL AND "Title" != ''
              {additional_filters}
              GROUP BY "Title"
              {order_by_clause}
              {limit_clause}`,
        params: [],
        param_types: [],
        optional_params: ["client", "company",
          "client",
          "organization", "status", "state_code", "categories", "min_fee", "max_fee", "start_date", "end_date", "limit", "sort_by"],
        chart_type: "bar",
        chart_field: "project_count",
      },

      // Column selection query - allows selecting specific columns from filtered results
      select_specific_columns: {
        sql: `SELECT {columns} FROM "${TABLE}" 
              WHERE 1=1
              {status_filter}
              {additional_filters}
              ORDER BY CAST(NULLIF("Fee", '') AS NUMERIC) DESC
              {limit_clause}`,
        params: [],
        param_types: [],
        optional_params: ["columns", "size", "status", "state_code", "company",
          "client",
          "organization", "client", "categories", "min_fee", "max_fee", "min_win", "max_win", "start_date", "end_date", "limit"],
        chart_type: "bar",
        chart_field: "Fee",
      },

      // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
      // COMPANY / OPCO QUERIES
      // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

      get_company_summary: {
        sql: `SELECT 
              COALESCE(MAX("Company"), @p1) as "Company",
              COUNT(*) as "Project Count",
              SUM(CAST(NULLIF("Fee", '') AS NUMERIC)) as "Total Fee",
              AVG(CAST(NULLIF("Fee", '') AS NUMERIC)) as "Average Fee",
              MIN(CAST(NULLIF("Fee", '') AS NUMERIC)) as "Min Fee",
              MAX(CAST(NULLIF("Fee", '') AS NUMERIC)) as "Max Fee",
              AVG(CAST(NULLIF("ChanceOfSuccess", '') AS NUMERIC)) as "Avg Win Rate"
              FROM "${TABLE}"
              WHERE "Company" LIKE @p1
              {additional_filters}`,
        params: ["company"],
        param_types: ["str"],
        optional_params: ["poc", "client", "state_code", "categories", "min_fee", "max_fee", "min_win", "max_win", "start_date", "end_date", "status"],
        chart_type: "bar",
        chart_field: "Total Fee",
      },

      get_projects_by_company: {
        sql: `SELECT * FROM "${TABLE}" 
              WHERE "Company" LIKE @p1
              {status_filter}
              {additional_filters}
              ORDER BY CAST(NULLIF("Fee", '') AS NUMERIC) DESC
              {limit_clause}`,
        params: ["company"],
        param_types: ["str"],
        optional_params: ["size", "status", "state_code", "client", "categories", "min_fee", "max_fee", "min_win", "max_win", "start_date", "end_date", "limit"],
        chart_type: "bar",
        chart_field: "Fee",
      },

      compare_companies: {
        sql: `SELECT "Company",
              COUNT(*) as project_count,
              SUM(CAST(NULLIF("Fee", '') AS NUMERIC)) as total_revenue,
              AVG(CAST(NULLIF("Fee", '') AS NUMERIC)) as avg_project_size,
              AVG(CAST(NULLIF("ChanceOfSuccess", '') AS NUMERIC)) as avg_win_rate
              FROM "${TABLE}"
              WHERE "Company" IS NOT NULL AND "Company" != ''
              {date_filter}
              {status_filter}
              {additional_filters}
              GROUP BY "Company"
              {having_clause}
              ORDER BY total_revenue DESC
              {limit_clause}`,
        params: [],
        param_types: [],
        optional_params: ["start_date", "end_date", "start_year", "end_year", "size", "status", "state_code", "client", "categories", "min_fee", "max_fee", "min_win", "max_win", "limit"],
        chart_type: "bar",
        chart_field: "total_revenue",
      },

      compare_opco_revenue: {
        sql: `SELECT "Company",
              COUNT(*) as project_count,
              SUM(CAST(NULLIF("Fee", '') AS NUMERIC)) as total_revenue,
              SUM(CAST(NULLIF("Fee", '') AS NUMERIC) * CAST(NULLIF("ChanceOfSuccess", '') AS NUMERIC) / 100) as predicted_revenue,
              AVG(CAST(NULLIF("ChanceOfSuccess", '') AS NUMERIC)) as avg_win_rate
              FROM "${TABLE}"
              WHERE EXISTS (SELECT 1 FROM STRING_SPLIT(@p1, ',') s WHERE "Company" LIKE '%' + LTRIM(RTRIM(s.value)) + '%')
              AND "StatusChoice" NOT IN ('Won', 'Lost')
              GROUP BY "Company"
              ORDER BY predicted_revenue DESC`,
        params: ["companies"],
        param_types: ["array"],
        chart_type: "bar",
        chart_field: "predicted_revenue",
      },

      get_companies_by_geographic_diversity: {
        sql: `SELECT "Company",
              COUNT(DISTINCT "State") as unique_states,
              COUNT(*) as project_count,
              SUM(CAST(NULLIF("Fee", '') AS NUMERIC)) as total_value,
              AVG(CAST(NULLIF("Fee", '') AS NUMERIC)) as avg_fee,
              AVG(CAST(NULLIF("ChanceOfSuccess", '') AS NUMERIC)) as avg_win_rate
              FROM "${TABLE}"
              WHERE "Company" IS NOT NULL AND "Company" != ''
              AND "State" IS NOT NULL AND "State" != ''
              {additional_filters}
              GROUP BY "Company"
              ORDER BY unique_states DESC, total_value DESC
              {limit_clause}`,
        params: [],
        param_types: [],
        optional_params: ["start_date", "end_date", "size", "status", "state_code", "states", "client", "categories", "min_fee", "max_fee", "min_win", "max_win", "limit"],
        chart_type: "bar",
        chart_field: "unique_states",
      },

      // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
      // CLIENT QUERIES
      // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

      get_client_summary: {
        sql: `SELECT 
              COALESCE(MAX("Client"), @p1) as "Client",
              COUNT(*) as "Project Count",
              SUM(CAST(NULLIF("Fee", '') AS NUMERIC)) as "Total Fee",
              AVG(CAST(NULLIF("Fee", '') AS NUMERIC)) as "Average Fee",
              MIN(CAST(NULLIF("Fee", '') AS NUMERIC)) as "Min Fee",
              MAX(CAST(NULLIF("Fee", '') AS NUMERIC)) as "Max Fee",
              AVG(CAST(NULLIF("ChanceOfSuccess", '') AS NUMERIC)) as "Avg Win Rate"
              FROM "${TABLE}"
              WHERE "Client" LIKE @p1
              {additional_filters}`,
        params: ["client"],
        param_types: ["str"],
        optional_params: ["poc", "company",
          "client",
          "organization", "state_code", "categories", "min_fee", "max_fee", "min_win", "max_win", "start_date", "end_date", "status"],
        chart_type: "bar",
        chart_field: "Total Fee",
      },

      get_projects_by_client: {
        sql: `SELECT * FROM "${TABLE}" 
              WHERE "Client" LIKE @p1
              {status_filter}
              {additional_filters}
              ORDER BY CAST(NULLIF("Fee", '') AS NUMERIC) DESC
              {limit_clause}`,
        params: ["client"],
        param_types: ["str"],
        optional_params: ["size", "status", "state_code", "company",
          "client",
          "organization", "categories", "min_fee", "max_fee", "min_win", "max_win", "start_date", "end_date", "limit"],
        chart_type: "bar",
        chart_field: "Fee",
      },

      get_projects_by_client_and_fee_range: {
        sql: `SELECT * FROM "${TABLE}" 
              WHERE "Client" LIKE @p1
              AND CAST(NULLIF("Fee", '') AS NUMERIC) >= @p2
              AND CAST(NULLIF("Fee", '') AS NUMERIC) <= @p3
              {additional_filters}
              ORDER BY CAST(NULLIF("Fee", '') AS NUMERIC) DESC`,
        params: ["client", "min_fee", "max_fee"],
        param_types: ["str", "float", "float"],
        optional_params: ["poc", "company",
          "client",
          "organization", "state_code", "categories", "min_win", "max_win", "start_date", "end_date", "status", "limit"],
        chart_type: "bar",
        chart_field: "Fee",
      },

      // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
      // DIVISION / DEPARTMENT QUERIES
      // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

      get_projects_by_division: {
        sql: `SELECT * FROM "${TABLE}" 
              WHERE "Division" LIKE @p1
              {status_filter}
              {additional_filters}
              ORDER BY CAST(NULLIF("Fee", '') AS NUMERIC) DESC
              {limit_clause}`,
        params: ["division"],
        param_types: ["str"],
        optional_params: ["size", "status", "state_code", "company",
          "client",
          "organization", "client", "categories", "min_fee", "max_fee", "min_win", "max_win", "start_date", "end_date", "department", "limit", "year"],
        chart_type: "bar",
        chart_field: "Fee",
      },

      get_projects_by_department: {
        sql: `SELECT * FROM "${TABLE}" 
              WHERE "Department" LIKE @p1
              {status_filter}
              {additional_filters}
              ORDER BY CAST(NULLIF("Fee", '') AS NUMERIC) DESC
              {limit_clause}`,
        params: ["department"],
        param_types: ["str"],
        optional_params: ["size", "status", "state_code", "company",
          "client",
          "organization", "client", "categories", "min_fee", "max_fee", "min_win", "max_win", "start_date", "end_date", "division", "limit", "year"],
        chart_type: "bar",
        chart_field: "Fee",
      },

      get_division_summary: {
        sql: `SELECT 
              COALESCE(MAX("Division"), @p1) as "Division",
              COUNT(*) as "Project Count",
              SUM(CAST(NULLIF("Fee", '') AS NUMERIC)) as "Total Fee",
              AVG(CAST(NULLIF("Fee", '') AS NUMERIC)) as "Average Fee",
              MIN(CAST(NULLIF("Fee", '') AS NUMERIC)) as "Min Fee",
              MAX(CAST(NULLIF("Fee", '') AS NUMERIC)) as "Max Fee",
              AVG(CAST(NULLIF("ChanceOfSuccess", '') AS NUMERIC)) as "Avg Win Rate"
              FROM "${TABLE}"
              WHERE "Division" LIKE @p1
              {additional_filters}`,
        params: ["division"],
        param_types: ["str"],
        optional_params: ["poc", "client", "company",
          "client",
          "organization", "state_code", "categories", "min_fee", "max_fee", "min_win", "max_win", "start_date", "end_date", "status", "department", "year"],
        chart_type: "bar",
        chart_field: "Total Fee",
      },

      get_department_summary: {
        sql: `SELECT 
              COALESCE(MAX("Department"), @p1) as "Department",
              COUNT(*) as "Project Count",
              SUM(CAST(NULLIF("Fee", '') AS NUMERIC)) as "Total Fee",
              AVG(CAST(NULLIF("Fee", '') AS NUMERIC)) as "Average Fee",
              MIN(CAST(NULLIF("Fee", '') AS NUMERIC)) as "Min Fee",
              MAX(CAST(NULLIF("Fee", '') AS NUMERIC)) as "Max Fee",
              AVG(CAST(NULLIF("ChanceOfSuccess", '') AS NUMERIC)) as "Avg Win Rate"
              FROM "${TABLE}"
              WHERE "Department" LIKE @p1
              {additional_filters}`,
        params: ["department"],
        param_types: ["str"],
        optional_params: ["poc", "client", "company",
          "client",
          "organization", "state_code", "categories", "min_fee", "max_fee", "min_win", "max_win", "start_date", "end_date", "status", "division", "year"],
        chart_type: "bar",
        chart_field: "Total Fee",
      },

      compare_divisions: {
        sql: `SELECT "Division",
              COUNT(*) as project_count,
              SUM(CAST(NULLIF("Fee", '') AS NUMERIC)) as total_revenue,
              AVG(CAST(NULLIF("Fee", '') AS NUMERIC)) as avg_project_size,
              AVG(CAST(NULLIF("ChanceOfSuccess", '') AS NUMERIC)) as avg_win_rate
              FROM "${TABLE}"
              WHERE "Division" IS NOT NULL AND "Division" != ''
              {date_filter}
              {status_filter}
              {additional_filters}
              GROUP BY "Division"
              {having_clause}
              ORDER BY total_revenue DESC
              {limit_clause}`,
        params: [],
        param_types: [],
        optional_params: ["start_date", "end_date", "start_year", "end_year", "size", "status", "state_code", "client", "company",
          "client",
          "organization", "categories", "min_fee", "max_fee", "min_win", "max_win", "department", "divisions", "limit", "year"],
        chart_type: "bar",
        chart_field: "total_revenue",
      },

      compare_departments: {
        sql: `SELECT "Department",
              COUNT(*) as project_count,
              SUM(CAST(NULLIF("Fee", '') AS NUMERIC)) as total_revenue,
              AVG(CAST(NULLIF("Fee", '') AS NUMERIC)) as avg_project_size,
              AVG(CAST(NULLIF("ChanceOfSuccess", '') AS NUMERIC)) as avg_win_rate
              FROM "${TABLE}"
              WHERE "Department" IS NOT NULL AND "Department" != ''
              {date_filter}
              {status_filter}
              {additional_filters}
              GROUP BY "Department"
              {having_clause}
              ORDER BY total_revenue DESC
              {limit_clause}`,
        params: [],
        param_types: [],
        optional_params: ["start_date", "end_date", "start_year", "end_year", "size", "status", "state_code", "client", "company",
          "client",
          "organization", "categories", "min_fee", "max_fee", "min_win", "max_win", "division", "departments", "limit", "year"],
        chart_type: "bar",
        chart_field: "total_revenue",
      },

      get_division_breakdown: {
        sql: `SELECT "Division",
              COUNT(*) as project_count,
              SUM(CAST(NULLIF("Fee", '') AS NUMERIC)) as total_value
              FROM "${TABLE}"
              WHERE "Division" IS NOT NULL AND "Division" != ''
              {date_filter}
              {additional_filters}
              GROUP BY "Division"
              ORDER BY total_value DESC`,
        params: [],
        param_types: [],
        optional_params: ["start_date", "end_date", "start_year", "end_year", "size", "status", "state_code", "company",
          "client",
          "organization", "client", "categories", "min_fee", "max_fee", "min_win", "max_win", "department", "year"],
        chart_type: "pie",
        chart_field: "project_count",
      },

      get_department_breakdown: {
        sql: `SELECT "Department",
              COUNT(*) as project_count,
              SUM(CAST(NULLIF("Fee", '') AS NUMERIC)) as total_value
              FROM "${TABLE}"
              WHERE "Department" IS NOT NULL AND "Department" != ''
              {date_filter}
              {additional_filters}
              GROUP BY "Department"
              ORDER BY total_value DESC`,
        params: [],
        param_types: [],
        optional_params: ["start_date", "end_date", "start_year", "end_year", "size", "status", "state_code", "company",
          "client",
          "organization", "client", "categories", "min_fee", "max_fee", "min_win", "max_win", "division", "year"],
        chart_type: "pie",
        chart_field: "project_count",
      },

      get_module_breakdown: {
        sql: `SELECT "ModuleName",
              COUNT(*) as project_count,
              SUM(CAST(NULLIF("Fee", '') AS NUMERIC)) as total_value
              FROM "${TABLE}"
              WHERE "ModuleName" IS NOT NULL AND "ModuleName" != ''
              {date_filter}
              {additional_filters}
              GROUP BY "ModuleName"
              ORDER BY total_value DESC`,
        params: [],
        param_types: [],
        optional_params: ["start_date", "end_date", "start_year", "end_year", "size", "status", "state_code", "company",
          "client",
          "organization", "client", "categories", "min_fee", "max_fee", "min_win", "max_win", "modules", "year"],
        chart_type: "pie",
        chart_field: "project_count",
      },

      get_revenue_by_division: {
        sql: `SELECT "Division",
              SUM(CAST(NULLIF("Fee", '') AS NUMERIC)) as total_revenue,
              COUNT(*) as project_count,
              AVG(CAST(NULLIF("Fee", '') AS NUMERIC)) as avg_fee,
              AVG(CAST(NULLIF("ChanceOfSuccess", '') AS NUMERIC)) as avg_win_rate
              FROM "${TABLE}"
              WHERE "Division" IS NOT NULL AND "Division" != ''
              {date_filter}
              {status_filter}
              {additional_filters}
              GROUP BY "Division"
              ORDER BY total_revenue DESC
              {limit_clause}`,
        params: [],
        param_types: [],
        optional_params: ["start_date", "end_date", "start_year", "end_year", "size", "status", "state_code", "client", "company",
          "client",
          "organization", "categories", "min_fee", "max_fee", "min_win", "max_win", "department", "limit", "year"],
        chart_type: "bar",
        chart_field: "total_revenue",
      },

      get_revenue_by_department: {
        sql: `SELECT "Department",
              SUM(CAST(NULLIF("Fee", '') AS NUMERIC)) as total_revenue,
              COUNT(*) as project_count,
              AVG(CAST(NULLIF("Fee", '') AS NUMERIC)) as avg_fee,
              AVG(CAST(NULLIF("ChanceOfSuccess", '') AS NUMERIC)) as avg_win_rate
              FROM "${TABLE}"
              WHERE "Department" IS NOT NULL AND "Department" != ''
              {date_filter}
              {status_filter}
              {additional_filters}
              GROUP BY "Department"
              ORDER BY total_revenue DESC
              {limit_clause}`,
        params: [],
        param_types: [],
        optional_params: ["start_date", "end_date", "start_year", "end_year", "size", "status", "state_code", "client", "company",
          "client",
          "organization", "categories", "min_fee", "max_fee", "min_win", "max_win", "division", "limit", "year"],
        chart_type: "bar",
        chart_field: "total_revenue",
      },

      // Department Fee Trend Analysis - Compare average fees across years
      get_department_fee_trend: {
        sql: `SELECT "Department",
              YEAR(TRY_CONVERT(DATE, "ClosedDate")) as year,
              COUNT(*) as project_count,
              SUM(CAST(NULLIF("Fee", '') AS NUMERIC)) as total_revenue,
              AVG(CAST(NULLIF("Fee", '') AS NUMERIC)) as avg_fee
              FROM "${TABLE}"
              WHERE "Department" IS NOT NULL AND "Department" != ''
              AND "ClosedDate" IS NOT NULL AND "ClosedDate" != ''
              AND TRY_CONVERT(DATE, "ClosedDate") IS NOT NULL
              {additional_filters}
              GROUP BY "Department", YEAR(TRY_CONVERT(DATE, "ClosedDate"))
              HAVING COUNT(*) >= 3
              ORDER BY "Department", year DESC`,
        params: [],
        param_types: [],
        optional_params: ["status", "state_code", "client", "company",
          "client",
          "organization", "categories", "min_fee", "max_fee", "division"],
        chart_type: "bar",
        chart_field: "avg_fee",
      },

      // Division Fee Trend Analysis - Compare average fees across years
      get_division_fee_trend: {
        sql: `SELECT "Division",
              YEAR(TRY_CONVERT(DATE, "ClosedDate")) as year,
              COUNT(*) as project_count,
              SUM(CAST(NULLIF("Fee", '') AS NUMERIC)) as total_revenue,
              AVG(CAST(NULLIF("Fee", '') AS NUMERIC)) as avg_fee
              FROM "${TABLE}"
              WHERE "Division" IS NOT NULL AND "Division" != ''
              AND "ClosedDate" IS NOT NULL AND "ClosedDate" != ''
              AND TRY_CONVERT(DATE, "ClosedDate") IS NOT NULL
              {additional_filters}
              GROUP BY "Division", YEAR(TRY_CONVERT(DATE, "ClosedDate"))
              HAVING COUNT(*) >= 3
              ORDER BY "Division", year DESC`,
        params: [],
        param_types: [],
        optional_params: ["status", "state_code", "client", "company",
          "client",
          "organization", "categories", "min_fee", "max_fee", "department"],
        chart_type: "bar",
        chart_field: "avg_fee",
      },

      // Fee Extremes - Find projects with largest fee differences (outliers)
      // Uses a CTE approach to avoid duplicate placeholder issues
      get_fee_extremes: {
        sql: `WITH filtered_projects AS (
              SELECT *, CAST(NULLIF("Fee", '') AS NUMERIC) as numeric_fee
              FROM "${TABLE}"
              WHERE "Fee" IS NOT NULL AND "Fee" != ''
              AND CAST(NULLIF("Fee", '') AS NUMERIC) > 0
              {additional_filters}
              )
              SELECT 'HIGHEST_FEE' as fee_category, * FROM (
                SELECT TOP 3 * FROM filtered_projects ORDER BY numeric_fee DESC
              ) h
              UNION ALL
              SELECT 'LOWEST_FEE' as fee_category, * FROM (
                SELECT TOP 3 * FROM filtered_projects ORDER BY numeric_fee ASC
              ) l`,
        params: [],
        param_types: [],
        optional_params: ["status", "state_code", "client", "company",
          "client",
          "organization", "categories", "department", "division", "start_date", "end_date"],
        chart_type: "bar",
        chart_field: "Fee",
      },

      // Fee percentile brackets - identify top/bottom X% of projects by fee
      get_fee_percentile: {
        sql: `WITH filtered_base AS (
              SELECT *, CAST(NULLIF("Fee", '') AS NUMERIC) as numeric_fee
              FROM "${TABLE}"
              WHERE "Fee" IS NOT NULL AND "Fee" != ''
              AND CAST(NULLIF("Fee", '') AS NUMERIC) > 0
              {additional_filters}
              ),
              ranked AS (
              SELECT *,
                PERCENT_RANK() OVER (ORDER BY numeric_fee DESC) as percentile_rank,
                ROW_NUMBER() OVER (ORDER BY numeric_fee DESC) as fee_rank,
                COUNT(*) OVER () as total_count
              FROM filtered_base
              )
              SELECT TOP {limit} *,
                CASE 
                  WHEN percentile_rank <= 0.10 THEN 'TOP_10_PERCENT'
                  WHEN percentile_rank <= 0.20 THEN 'TOP_20_PERCENT'
                  WHEN percentile_rank <= 0.50 THEN 'TOP_50_PERCENT'
                  WHEN percentile_rank >= 0.80 THEN 'BOTTOM_20_PERCENT'
                  WHEN percentile_rank >= 0.90 THEN 'BOTTOM_10_PERCENT'
                  ELSE 'MIDDLE'
                END as fee_bracket
              FROM ranked
              WHERE percentile_rank <= @p1
              ORDER BY numeric_fee DESC`,
        params: ["percentile_threshold"],
        param_types: ["DECIMAL"],
        optional_params: ["status", "state_code", "client", "company",
          "client",
          "organization", "categories", "department", "division", "start_date", "end_date"],
        chart_type: "bar",
        chart_field: "Fee",
      },

      // Top N% fee bracket (simplified version for common queries)
      get_top_fee_bracket: {
        sql: `WITH filtered_base AS (
              SELECT *, CAST(NULLIF("Fee", '') AS NUMERIC) as numeric_fee
              FROM "${TABLE}"
              WHERE "Fee" IS NOT NULL AND "Fee" != ''
              AND CAST(NULLIF("Fee", '') AS NUMERIC) > 0
              {additional_filters}
              ),
              ranked AS (
              SELECT *,
                NTILE(10) OVER (ORDER BY numeric_fee DESC) as decile,
                COUNT(*) OVER () as total_count
              FROM filtered_base
              )
              SELECT TOP 50 *, 'TOP_10_PERCENT' as fee_bracket
              FROM ranked
              WHERE decile = 1
              ORDER BY numeric_fee DESC`,
        params: [],
        param_types: [],
        optional_params: ["status", "state_code", "client", "company",
          "client",
          "organization", "categories", "department", "division", "start_date", "end_date"],
        chart_type: "bar",
        chart_field: "Fee",
      },

      // Bottom N% fee bracket - projects contributing least to revenue
      get_bottom_fee_bracket: {
        sql: `WITH filtered_base AS (
              SELECT *, CAST(NULLIF("Fee", '') AS NUMERIC) as numeric_fee
              FROM "${TABLE}"
              WHERE "Fee" IS NOT NULL AND "Fee" != ''
              AND CAST(NULLIF("Fee", '') AS NUMERIC) > 0
              {additional_filters}
              ),
              ranked AS (
              SELECT *,
                NTILE(5) OVER (ORDER BY numeric_fee ASC) as quintile,
                COUNT(*) OVER () as total_count
              FROM filtered_base
              )
              SELECT TOP 50 *, 'BOTTOM_20_PERCENT' as fee_bracket
              FROM ranked
              WHERE quintile = 1
              ORDER BY numeric_fee ASC`,
        params: [],
        param_types: [],
        optional_params: ["status", "state_code", "client", "company",
          "client",
          "organization", "categories", "department", "division", "start_date", "end_date"],
        chart_type: "bar",
        chart_field: "Fee",
      },

      // Compare average fee of top N vs bottom N projects
      get_top_vs_bottom_fee_comparison: {
        sql: `WITH filtered_base AS (
              SELECT *, CAST(NULLIF("Fee", '') AS NUMERIC) as numeric_fee
              FROM "${TABLE}"
              WHERE "Fee" IS NOT NULL AND "Fee" != ''
              AND CAST(NULLIF("Fee", '') AS NUMERIC) > 0
              {additional_filters}
              ),
              top_projects AS (
              SELECT TOP 5 'TOP_5' as group_name, * FROM filtered_base ORDER BY numeric_fee DESC
              ),
              bottom_projects AS (
              SELECT TOP 5 'BOTTOM_5' as group_name, * FROM filtered_base ORDER BY numeric_fee ASC
              ),
              combined AS (
              SELECT * FROM top_projects UNION ALL SELECT * FROM bottom_projects
              )
              SELECT * FROM combined ORDER BY group_name, numeric_fee DESC`,
        params: [],
        param_types: [],
        optional_params: ["status", "state_code", "client", "company",
          "client",
          "organization", "categories", "department", "division", "start_date", "end_date"],
        chart_type: "bar",
        chart_field: "Fee",
      },

      // Revenue concentration - what % of total revenue comes from top projects
      get_revenue_concentration: {
        sql: `WITH filtered_base AS (
              SELECT *, CAST(NULLIF("Fee", '') AS NUMERIC) as numeric_fee
              FROM "${TABLE}"
              WHERE "Fee" IS NOT NULL AND "Fee" != ''
              AND CAST(NULLIF("Fee", '') AS NUMERIC) > 0
              {additional_filters}
              ),
              totals AS (
              SELECT SUM(numeric_fee) as total_revenue, COUNT(*) as total_count FROM filtered_base
              ),
              ranked AS (
              SELECT fb.*,
                ROW_NUMBER() OVER (ORDER BY numeric_fee DESC) as revenue_rank,
                SUM(numeric_fee) OVER (ORDER BY numeric_fee DESC) as cumulative_revenue,
                (SELECT total_revenue FROM totals) as total_revenue,
                (SELECT total_count FROM totals) as total_count
              FROM filtered_base fb
              )
              SELECT TOP 20 *,
                CAST(cumulative_revenue * 100.0 / NULLIF(total_revenue, 0) AS DECIMAL(5,2)) as cumulative_pct,
                CAST(numeric_fee * 100.0 / NULLIF(total_revenue, 0) AS DECIMAL(5,2)) as individual_pct
              FROM ranked
              ORDER BY revenue_rank`,
        params: [],
        param_types: [],
        optional_params: ["status", "state_code", "client", "company",
          "client",
          "organization", "categories", "department", "division", "start_date", "end_date"],
        chart_type: "bar",
        chart_field: "Fee",
      },

      // Median fee comparison - projects above/below median
      get_projects_vs_median: {
        sql: `WITH filtered_base AS (
              SELECT *, CAST(NULLIF("Fee", '') AS NUMERIC) as numeric_fee
              FROM "${TABLE}"
              WHERE "Fee" IS NOT NULL AND "Fee" != ''
              AND CAST(NULLIF("Fee", '') AS NUMERIC) > 0
              {additional_filters}
              ),
              median_calc AS (
              SELECT DISTINCT PERCENTILE_CONT(0.5) WITHIN GROUP (ORDER BY numeric_fee) OVER () as median_fee
              FROM filtered_base
              ),
              classified AS (
              SELECT fb.*,
                (SELECT median_fee FROM median_calc) as overall_median_fee,
                CASE 
                  WHEN fb.numeric_fee > (SELECT median_fee FROM median_calc) THEN 'ABOVE_MEDIAN'
                  WHEN fb.numeric_fee < (SELECT median_fee FROM median_calc) THEN 'BELOW_MEDIAN'
                  ELSE 'AT_MEDIAN'
                END as median_classification,
                COUNT(*) OVER (PARTITION BY CASE WHEN fb.numeric_fee > (SELECT median_fee FROM median_calc) THEN 'ABOVE' ELSE 'BELOW' END) as group_count
              FROM filtered_base fb
              )
              SELECT TOP 50 * FROM classified
              ORDER BY numeric_fee DESC`,
        params: [],
        param_types: [],
        optional_params: ["status", "state_code", "client", "company",
          "client",
          "organization", "categories", "department", "division", "start_date", "end_date"],
        chart_type: "bar",
        chart_field: "Fee",
      },

      // Fee distribution statistics - skewness, clustering, spread
      get_fee_distribution_stats: {
        sql: `WITH filtered_base AS (
              SELECT CAST(NULLIF("Fee", '') AS NUMERIC) as numeric_fee
              FROM "${TABLE}"
              WHERE "Fee" IS NOT NULL AND "Fee" != ''
              AND CAST(NULLIF("Fee", '') AS NUMERIC) > 0
              {additional_filters}
              )
              SELECT 
                COUNT(*) as total_projects,
                MIN(numeric_fee) as min_fee,
                MAX(numeric_fee) as max_fee,
                AVG(numeric_fee) as avg_fee,
                STDEV(numeric_fee) as std_dev,
                VAR(numeric_fee) as variance,
                (SELECT DISTINCT PERCENTILE_CONT(0.5) WITHIN GROUP (ORDER BY numeric_fee) OVER () FROM filtered_base) as median_fee,
                (SELECT DISTINCT PERCENTILE_CONT(0.25) WITHIN GROUP (ORDER BY numeric_fee) OVER () FROM filtered_base) as q1_fee,
                (SELECT DISTINCT PERCENTILE_CONT(0.75) WITHIN GROUP (ORDER BY numeric_fee) OVER () FROM filtered_base) as q3_fee,
                MAX(numeric_fee) - MIN(numeric_fee) as fee_range,
                CASE 
                  WHEN AVG(numeric_fee) > (SELECT DISTINCT PERCENTILE_CONT(0.5) WITHIN GROUP (ORDER BY numeric_fee) OVER () FROM filtered_base) 
                  THEN 'SKEWED_TOWARD_HIGHER_VALUES'
                  ELSE 'SKEWED_TOWARD_LOWER_VALUES'
                END as skew_direction
              FROM filtered_base`,
        params: [],
        param_types: [],
        optional_params: ["status", "state_code", "client", "company",
          "client",
          "organization", "categories", "department", "division", "start_date", "end_date"],
        chart_type: "bar",
        chart_field: "avg_fee",
      },

      // Fee clustering - group projects by fee ranges to see distribution
      get_fee_clustering: {
        sql: `WITH filtered_base AS (
              SELECT *, CAST(NULLIF("Fee", '') AS NUMERIC) as numeric_fee
              FROM "${TABLE}"
              WHERE "Fee" IS NOT NULL AND "Fee" != ''
              AND CAST(NULLIF("Fee", '') AS NUMERIC) > 0
              {additional_filters}
              ),
              fee_ranges AS (
              SELECT *,
                CASE 
                  WHEN numeric_fee < 100000 THEN 'Under $100K'
                  WHEN numeric_fee < 500000 THEN '$100K-$500K'
                  WHEN numeric_fee < 1000000 THEN '$500K-$1M'
                  WHEN numeric_fee < 5000000 THEN '$1M-$5M'
                  WHEN numeric_fee < 10000000 THEN '$5M-$10M'
                  WHEN numeric_fee < 50000000 THEN '$10M-$50M'
                  WHEN numeric_fee < 100000000 THEN '$50M-$100M'
                  ELSE 'Over $100M'
                END as fee_range,
                CASE 
                  WHEN numeric_fee < 100000 THEN 1
                  WHEN numeric_fee < 500000 THEN 2
                  WHEN numeric_fee < 1000000 THEN 3
                  WHEN numeric_fee < 5000000 THEN 4
                  WHEN numeric_fee < 10000000 THEN 5
                  WHEN numeric_fee < 50000000 THEN 6
                  WHEN numeric_fee < 100000000 THEN 7
                  ELSE 8
                END as range_order
              FROM filtered_base
              )
              SELECT fee_range, COUNT(*) as project_count, 
                SUM(numeric_fee) as total_fee_in_range,
                AVG(numeric_fee) as avg_fee_in_range,
                MIN(numeric_fee) as min_fee_in_range,
                MAX(numeric_fee) as max_fee_in_range
              FROM fee_ranges
              GROUP BY fee_range, range_order
              ORDER BY range_order`,
        params: [],
        param_types: [],
        optional_params: ["status", "state_code", "client", "company",
          "client",
          "organization", "categories", "department", "division", "start_date", "end_date"],
        chart_type: "bar",
        chart_field: "project_count",
      },

      // Project closest to average fee
      get_project_closest_to_average: {
        sql: `WITH filtered_base AS (
              SELECT *, CAST(NULLIF("Fee", '') AS NUMERIC) as numeric_fee
              FROM "${TABLE}"
              WHERE "Fee" IS NOT NULL AND "Fee" != ''
              AND CAST(NULLIF("Fee", '') AS NUMERIC) > 0
              {additional_filters}
              ),
              avg_calc AS (
              SELECT AVG(numeric_fee) as avg_fee FROM filtered_base
              ),
              with_deviation AS (
              SELECT fb.*,
                (SELECT avg_fee FROM avg_calc) as overall_avg_fee,
                ABS(fb.numeric_fee - (SELECT avg_fee FROM avg_calc)) as deviation_from_avg
              FROM filtered_base fb
              )
              SELECT TOP 10 * FROM with_deviation
              ORDER BY deviation_from_avg ASC`,
        params: [],
        param_types: [],
        optional_params: ["status", "state_code", "client", "company",
          "client",
          "organization", "categories", "department", "division", "start_date", "end_date"],
        chart_type: "bar",
        chart_field: "Fee",
      },

      // Project in the middle (between highest and lowest)
      get_middle_fee_project: {
        sql: `WITH filtered_base AS (
              SELECT *, CAST(NULLIF("Fee", '') AS NUMERIC) as numeric_fee
              FROM "${TABLE}"
              WHERE "Fee" IS NOT NULL AND "Fee" != ''
              AND CAST(NULLIF("Fee", '') AS NUMERIC) > 0
              {additional_filters}
              ),
              extremes AS (
              SELECT MIN(numeric_fee) as min_fee, MAX(numeric_fee) as max_fee,
                (MIN(numeric_fee) + MAX(numeric_fee)) / 2 as midpoint
              FROM filtered_base
              ),
              with_distance AS (
              SELECT fb.*,
                (SELECT min_fee FROM extremes) as min_fee,
                (SELECT max_fee FROM extremes) as max_fee,
                (SELECT midpoint FROM extremes) as midpoint_fee,
                ABS(fb.numeric_fee - (SELECT midpoint FROM extremes)) as distance_from_midpoint
              FROM filtered_base fb
              )
              SELECT TOP 10 * FROM with_distance
              ORDER BY distance_from_midpoint ASC`,
        params: [],
        param_types: [],
        optional_params: ["status", "state_code", "client", "company",
          "client",
          "organization", "categories", "department", "division", "start_date", "end_date"],
        chart_type: "bar",
        chart_field: "Fee",
      },

      // Fee variance within same category - finds projects with similar scope but different fees
      // Groups by RequestCategory, calculates category average, then finds outliers
      get_fee_variance_by_scope: {
        sql: `WITH filtered_base AS (
              SELECT *, CAST(NULLIF("Fee", '') AS NUMERIC) as numeric_fee
              FROM "${TABLE}"
              WHERE "Fee" IS NOT NULL AND "Fee" != ''
              AND CAST(NULLIF("Fee", '') AS NUMERIC) > 0
              AND "RequestCategory" IS NOT NULL AND "RequestCategory" != ''
              {additional_filters}
              ),
              category_stats AS (
              SELECT "RequestCategory", 
                AVG(numeric_fee) as category_avg_fee,
                STDEV(numeric_fee) as category_stdev,
                MIN(numeric_fee) as category_min_fee,
                MAX(numeric_fee) as category_max_fee,
                COUNT(*) as category_count
              FROM filtered_base 
              GROUP BY "RequestCategory"
              HAVING COUNT(*) >= 3
              ),
              with_variance AS (
              SELECT fb.*,
                cs.category_avg_fee,
                cs.category_min_fee,
                cs.category_max_fee,
                cs.category_count,
                ABS(fb.numeric_fee - cs.category_avg_fee) as fee_deviation,
                CASE 
                  WHEN fb.numeric_fee > cs.category_avg_fee * 2 THEN 'SIGNIFICANTLY_ABOVE'
                  WHEN fb.numeric_fee < cs.category_avg_fee * 0.5 THEN 'SIGNIFICANTLY_BELOW'
                  ELSE 'NORMAL_RANGE'
                END as fee_variance_status
              FROM filtered_base fb
              JOIN category_stats cs ON fb."RequestCategory" = cs."RequestCategory"
              )
              SELECT TOP 50 * FROM with_variance
              WHERE fee_variance_status != 'NORMAL_RANGE'
              ORDER BY fee_deviation DESC`,
        params: [],
        param_types: [],
        optional_params: ["status", "state_code", "client", "company",
          "client",
          "organization", "categories", "department", "division", "start_date", "end_date"],
        chart_type: "bar",
        chart_field: "Fee",
      },

      // Projects above/below average fee - classifies projects relative to the overall average
      // Uses a single CTE to apply filters once, then calculates average and classifies
      get_projects_vs_average: {
        sql: `WITH filtered_base AS (
              SELECT *, CAST(NULLIF("Fee", '') AS NUMERIC) as numeric_fee
              FROM "${TABLE}"
              WHERE "Fee" IS NOT NULL AND "Fee" != ''
              AND CAST(NULLIF("Fee", '') AS NUMERIC) > 0
              {additional_filters}
              ),
              avg_stats AS (
              SELECT AVG(numeric_fee) as avg_fee FROM filtered_base
              ),
              classified AS (
              SELECT fb.*,
                (SELECT avg_fee FROM avg_stats) as overall_avg_fee,
                CASE 
                  WHEN fb.numeric_fee > (SELECT avg_fee FROM avg_stats) THEN 'ABOVE_AVERAGE'
                  WHEN fb.numeric_fee < (SELECT avg_fee FROM avg_stats) THEN 'BELOW_AVERAGE'
                  ELSE 'AT_AVERAGE'
                END as fee_classification
              FROM filtered_base fb
              )
              SELECT TOP 50 * FROM classified
              ORDER BY numeric_fee DESC`,
        params: [],
        param_types: [],
        optional_params: ["status", "state_code", "client", "company",
          "client",
          "organization", "categories", "department", "division", "start_date", "end_date"],
        chart_type: "bar",
        chart_field: "Fee",
      },

      // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
      // STATUS QUERIES
      // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

      get_projects_by_status: {
        sql: `SELECT * FROM "${TABLE}" 
              WHERE 1=1
              {status_filter}
              {additional_filters}
              ORDER BY CAST(NULLIF("Fee", '') AS NUMERIC) DESC
              {limit_clause}`,
        params: [],
        param_types: [],
        optional_params: ["status", "size", "state_code", "company",
          "client",
          "organization", "client", "categories", "min_fee", "max_fee", "min_win", "max_win", "start_date", "end_date", "is_updated", "limit"],
        chart_type: "bar",
        chart_field: "Fee",
      },

      get_projects_by_status_and_win_rate: {
        sql: `SELECT * FROM "${TABLE}" 
              WHERE "StatusChoice" LIKE @p1
              {win_rate_filter}
              {additional_filters}
              ORDER BY CAST(NULLIF("ChanceOfSuccess", '') AS NUMERIC) DESC,
                       CAST(NULLIF("Fee", '') AS NUMERIC) DESC`,
        params: ["status"],
        param_types: ["str"],
        optional_params: ["min_win", "max_win", "poc", "client", "company",
          "client",
          "organization", "state_code", "categories", "min_fee", "max_fee", "start_date", "end_date", "limit"],
        chart_type: "bar",
        chart_field: "Fee",
      },

      get_status_breakdown: {
        sql: `SELECT "StatusChoice",
              COUNT(*) as project_count,
              SUM(CAST(NULLIF("Fee", '') AS NUMERIC)) as total_value
              FROM "${TABLE}"
              WHERE "StatusChoice" IS NOT NULL AND "StatusChoice" != ''
              {date_filter}
              {additional_filters}
              GROUP BY "StatusChoice"
              ORDER BY total_value DESC`,
        params: [],
        param_types: [],
        optional_params: ["start_date", "end_date", "start_year", "end_year", "size", "status", "state_code", "company",
          "client",
          "organization", "client", "categories", "min_fee", "max_fee", "min_win", "max_win"],
        chart_type: "pie",
        chart_field: "project_count",
      },

      get_overoptimistic_losses: {
        sql: `SELECT * FROM "${TABLE}" 
              WHERE "StatusChoice" NOT LIKE 'Won'
              AND CAST(NULLIF("ChanceOfSuccess", '') AS NUMERIC) > 70
              {additional_filters}
              ORDER BY CAST(NULLIF("ChanceOfSuccess", '') AS NUMERIC) DESC,
                       CAST(NULLIF("Fee", '') AS NUMERIC) DESC`,
        params: [],
        param_types: [],
        optional_params: ["poc", "client", "company",
          "client",
          "organization", "state_code", "categories", "min_fee", "max_fee", "start_date", "end_date", "limit"],
        chart_type: "bar",
        chart_field: "Fee",
      },

      get_top_predicted_wins: {
        sql: `SELECT * FROM "${TABLE}" 
              WHERE {status_filter_for_wins}
              AND "ChanceOfSuccess" IS NOT NULL
              {date_filter}
              {additional_filters}
              ORDER BY CAST("ChanceOfSuccess" AS NUMERIC) DESC,
                       CAST(NULLIF("Fee", '') AS NUMERIC) DESC
              {limit_clause}`,
        params: [],
        param_types: [],
        optional_params: ["limit", "start_date", "end_date", "min_fee", "max_fee", "min_win", "max_win", "size", "status", "state_code", "company",
          "client",
          "organization", "client", "categories"],
        chart_type: "bar",
        chart_field: "Fee",
      },

      // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
      // WIN RATE QUERIES
      // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

      get_project_win_rate: {
        sql: `SELECT TOP 1 *, "ChanceOfSuccess" as win_rate FROM "${TABLE}" 
              WHERE CAST("Title" AS NVARCHAR(MAX)) LIKE @p1`,
        params: ["project_name"],
        param_types: ["str"],
        chart_type: "bar",
        chart_field: "win_rate",
      },

      get_projects_by_win_range: {
        sql: `SELECT * FROM "${TABLE}" 
              WHERE CAST(NULLIF("ChanceOfSuccess", '') AS NUMERIC) >= @p1
              {max_win_filter}
              {additional_filters}
              ORDER BY CAST(NULLIF("ChanceOfSuccess", '') AS NUMERIC) DESC,
                       CAST(NULLIF("Fee", '') AS NUMERIC) DESC`,
        params: ["min_win"],
        param_types: ["int"],
        optional_params: ["max_win", "start_date", "end_date", "min_fee", "max_fee", "size", "status", "state_code", "company",
          "client",
          "organization", "client", "categories", "year"],
        chart_type: "bar",
        chart_field: "Fee",
      },

      get_projects_by_category_and_win_range: {
        sql: `SELECT * FROM "${TABLE}" 
              WHERE "RequestCategory" LIKE @p1
              AND CAST(NULLIF("ChanceOfSuccess", '') AS NUMERIC) >= @p2
              {max_win_filter}
              {additional_filters}
              ORDER BY CAST(NULLIF("ChanceOfSuccess", '') AS NUMERIC) DESC,
                       CAST(NULLIF("Fee", '') AS NUMERIC) DESC`,
        params: ["category", "min_win"],
        param_types: ["str", "int"],
        optional_params: ["max_win", "poc", "client", "company",
          "client",
          "organization", "state_code", "min_fee", "max_fee", "start_date", "end_date", "limit"],
        chart_type: "bar",
        chart_field: "Fee",
      },

      get_projects_by_client_status_win_range: {
        sql: `SELECT * FROM "${TABLE}" 
              WHERE "Client" LIKE @p1
              AND "StatusChoice" LIKE @p2
              AND CAST(NULLIF("ChanceOfSuccess", '') AS NUMERIC) >= @p3
              AND CAST(NULLIF("ChanceOfSuccess", '') AS NUMERIC) <= @p4
              {additional_filters}
              ORDER BY CAST(NULLIF("ChanceOfSuccess", '') AS NUMERIC) DESC,
                       CAST(NULLIF("Fee", '') AS NUMERIC) DESC`,
        params: ["client", "status", "min_win", "max_win"],
        param_types: ["str", "str", "int", "int"],
        optional_params: ["poc", "company",
          "client",
          "organization", "state_code", "categories", "min_fee", "max_fee", "start_date", "end_date", "limit"],
        chart_type: "bar",
        chart_field: "Fee",
      },

      get_clients_by_highest_win_rate: {
        sql: `SELECT "Client",
              COUNT(*) as project_count,
              AVG(CAST(NULLIF("ChanceOfSuccess", '') AS NUMERIC)) as avg_win_rate,
              SUM(CAST(NULLIF("Fee", '') AS NUMERIC)) as total_value
              FROM "${TABLE}"
              WHERE "StatusChoice" NOT IN ('Won', 'Lost')
              AND "ChanceOfSuccess" IS NOT NULL AND "ChanceOfSuccess" != ''
              AND "Client" IS NOT NULL AND "Client" != ''
              {additional_filters}
              GROUP BY "Client"
              {having_clause}
              ORDER BY avg_win_rate DESC
              {limit_clause}`,
        params: [],
        param_types: [],
        optional_params: ["poc", "company",
          "client",
          "organization", "state_code", "categories", "min_fee", "max_fee", "start_date", "end_date", "limit", "min_win", "max_win"],
        chart_type: "bar",
        chart_field: "avg_win_rate",
      },

      get_top_projects_by_win_rate: {
        sql: `SELECT * FROM "${TABLE}"
              WHERE "ChanceOfSuccess" IS NOT NULL AND "ChanceOfSuccess" != ''
              {start_date_filter}
              {end_date_filter}
              {additional_filters}
              ORDER BY CAST(NULLIF("ChanceOfSuccess", '') AS NUMERIC) DESC,
                       CAST(NULLIF("Fee", '') AS NUMERIC) DESC
              {limit_clause}`,
        params: [],
        param_types: [],
        optional_params: ["start_date", "end_date", "limit", "size", "status", "state_code", "company",
          "client",
          "organization", "client", "categories", "min_fee", "max_fee"],
        chart_type: "bar",
        chart_field: "ChanceOfSuccess",
      },

      get_clients_by_status_count: {
        sql: `SELECT "Client",
              COUNT(*) as project_count,
              SUM(CAST(NULLIF("Fee", '') AS NUMERIC)) as total_value,
              AVG(CAST(NULLIF("ChanceOfSuccess", '') AS NUMERIC)) as avg_win_rate
              FROM "${TABLE}"
              WHERE "StatusChoice" LIKE @p1
              AND "Client" IS NOT NULL AND "Client" != ''
              {additional_filters}
              GROUP BY "Client"
              ORDER BY project_count DESC
              {limit_clause}`,
        params: ["status"],
        param_types: ["str"],
        optional_params: ["poc", "company",
          "client",
          "organization", "state_code", "categories", "min_fee", "max_fee", "min_win", "max_win", "start_date", "end_date", "limit"],
        chart_type: "bar",
        chart_field: "project_count",
      },

      // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
      // FEE/SIZE QUERIES
      // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

      get_projects_by_fee_range: {
        sql: `SELECT * FROM "${TABLE}" 
              WHERE CAST(NULLIF("Fee", '') AS NUMERIC) >= @p1
              {max_fee_filter}
              {date_filter}
              {status_filter}
              {additional_filters}
              ORDER BY CAST(NULLIF("Fee", '') AS NUMERIC) {sort_direction}
              {limit_clause}`,
        params: ["min_fee"],
        param_types: ["float"],
        optional_params: ["max_fee", "start_date", "end_date", "min_win", "max_win", "size", "status", "state_code", "company",
          "client",
          "organization", "client", "categories", "limit", "sort_direction"],
        chart_type: "bar",
        chart_field: "Fee",
      },

      get_projects_by_size: {
        sql: `SELECT * FROM "${TABLE}" 
              WHERE {size_condition}
              AND "Fee" IS NOT NULL AND "Fee" != ''
              {additional_filters}
              ORDER BY CAST("Fee" AS NUMERIC) DESC
              {limit_clause}`,
        params: ["size"],
        param_types: ["str"],
        optional_params: ["poc", "client", "company",
          "client",
          "organization", "state_code", "categories", "min_win", "max_win", "start_date", "end_date", "status", "limit"],
        chart_type: "bar",
        chart_field: "Fee",
      },

      get_size_distribution: {
        sql: `SELECT {size_case} as size_tier,
              COUNT(*) as project_count,
              SUM(CAST(NULLIF("Fee", '') AS NUMERIC)) as total_value
              FROM "${TABLE}"
              WHERE "Fee" IS NOT NULL AND "Fee" != ''
              AND CAST(NULLIF("Fee", '') AS NUMERIC) > 0
              {additional_filters}
              GROUP BY size_tier
              ORDER BY MIN(CAST(NULLIF("Fee", '') AS NUMERIC))`,
        params: [],
        param_types: [],
        optional_params: ["poc", "client", "company",
          "client",
          "organization", "state_code", "categories", "min_win", "max_win", "start_date", "end_date", "status"],
        chart_type: "pie",
        chart_field: "project_count",
      },

      // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
      // REGION QUERIES
      // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

      get_projects_by_state: {
        sql: `SELECT * FROM "${TABLE}" 
              WHERE "State" LIKE @p1
              {status_filter}
              {additional_filters}
              ORDER BY CAST(NULLIF("Fee", '') AS NUMERIC) DESC
              {limit_clause}`,
        params: ["state_code"],
        param_types: ["str"],
        optional_params: ["size", "status", "company",
          "client",
          "organization", "client", "categories", "min_fee", "max_fee", "min_win", "max_win", "start_date", "end_date", "limit"],
        chart_type: "bar",
        chart_field: "Fee",
      },

      get_projects_by_city: {
        sql: `SELECT * FROM "${TABLE}" 
              WHERE "City" LIKE @p1
              {status_filter}
              {additional_filters}
              ORDER BY CAST(NULLIF("Fee", '') AS NUMERIC) DESC
              {limit_clause}`,
        params: ["city"],
        param_types: ["str"],
        optional_params: ["size", "status", "company", "client", "organization", "categories", "min_fee", "max_fee", "min_win", "max_win", "start_date", "end_date", "limit"],
        chart_type: "bar",
        chart_field: "Fee",
      },

      // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
      // COMBINED FILTERS
      // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

      get_projects_by_combined_filters: {
        sql: `SELECT * FROM "${TABLE}" 
              WHERE 1=1
              {filters}
              {order_by_clause}
              {limit_clause}`,
        params: [],
        param_types: [],
        optional_params: [
          "size",
          "categories",
          
          "exclude_categories",
          "title",
          
          
          "status",
          "company",
          "client",
          "organization",
          "division",
          "divisions",
          "department",
          "departments",
          "state_code",
          "states",
          "region",
          "regions",
          "countries",
          "is_updated",
          "project_type",
          "project_types",
          "min_fee",
          "max_fee",
          "min_win",
          "max_win",
          "start_date",
          "end_date",
          "year",
          "limit",
          "sort_field",
          "sort_direction",
        ],
        chart_type: "bar",
        chart_field: "Fee",
      },

      // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
      // AGGREGATION QUERIES
      // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

      get_revenue_by_category: {
        sql: `SELECT "RequestCategory",
              COUNT(*) as project_count,
              SUM(CAST(NULLIF("Fee", '') AS NUMERIC)) as total_revenue
              FROM "${TABLE}"
              WHERE "RequestCategory" LIKE @p1
              {status_filter}
              {additional_filters}
              GROUP BY "RequestCategory"`,
        params: ["category"],
        param_types: ["str"],
        optional_params: ["status", "poc", "client", "company",
          "client",
          "organization", "state_code", "min_fee", "max_fee", "start_date", "end_date"],
        chart_type: "bar",
        chart_field: "total_revenue",
      },

      get_weighted_revenue_projection: {
        sql: `SELECT {group_by_column},
              COUNT(*) as project_count,
              SUM(CAST(NULLIF("Fee", '') AS NUMERIC)) as total_value,
              SUM(CAST(NULLIF("Fee", '') AS NUMERIC) * CAST(NULLIF("ChanceOfSuccess", '') AS NUMERIC) / 100) as weighted_revenue
              FROM "${TABLE}"
              WHERE 1=1
              {status_filter}
              {additional_filters}
              GROUP BY {group_by_column}
              ORDER BY weighted_revenue DESC`,
        params: [],
        param_types: [],
        optional_params: ["status", "group_by", "poc", "client", "company",
          "client",
          "organization", "state_code", "categories", "min_fee", "max_fee", "start_date", "end_date"],
        chart_type: "bar",
        chart_field: "weighted_revenue",
      },

      compare_years: {
        sql: `SELECT 
              YEAR(TRY_CONVERT(DATE, "ConstStartDate")) as year,
              COUNT(*) as project_count,
              SUM(CAST(NULLIF("Fee", '') AS NUMERIC)) as total_revenue,
              AVG(CAST(NULLIF("Fee", '') AS NUMERIC)) as avg_fee,
              COUNT(CASE WHEN "StatusChoice" = 'Won' THEN 1 END) as won_count,
              COUNT(CASE WHEN "StatusChoice" = 'Submitted' THEN 1 END) as submitted_count
              FROM "${TABLE}"
              WHERE "ConstStartDate" IS NOT NULL
              {year_filter}
              {status_filter}
              {additional_filters}
              GROUP BY year
              ORDER BY {order_by}`,
        params: [],
        param_types: [],
        optional_params: ["year1", "year2", "status", "limit", "poc", "client", "company",
          "client",
          "organization", "state_code", "categories", "min_fee", "max_fee"],
        chart_type: "bar",
        chart_field: "total_revenue",
      },

      // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
      // POC (POINT OF CONTACT) ANALYSIS
      // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

      get_top_pocs: {
        sql: `SELECT "PointOfContact" as poc,
              COUNT(*) as project_count,
              SUM(CAST(NULLIF("Fee", '') AS NUMERIC)) as total_value,
              AVG(CAST(NULLIF("Fee", '') AS NUMERIC)) as avg_project_value,
              AVG(CAST(NULLIF("ChanceOfSuccess", '') AS NUMERIC)) as avg_win_rate,
              COUNT(CASE WHEN "StatusChoice" = 'Won' THEN 1 END) as won_count,
              COUNT(CASE WHEN "StatusChoice" = 'Lost' THEN 1 END) as lost_count
              FROM "${TABLE}"
              WHERE "PointOfContact" IS NOT NULL AND "PointOfContact" != ''
              {additional_filters}
              GROUP BY "PointOfContact"
              ORDER BY total_value DESC
              {limit_clause}`,
        params: [],
        param_types: [],
        optional_params: ["client", "company",
          "client",
          "organization", "status", "state_code", "categories", "category", "project_type", "project_types", "min_fee", "max_fee", "start_date", "end_date", "year", "limit"],
        chart_type: "bar",
        chart_field: "total_value",
      },

      get_projects_by_poc: {
        sql: `SELECT * FROM "${TABLE}" 
              WHERE {poc_condition}
              {status_filter}
              {additional_filters}
              ORDER BY CAST(NULLIF("Fee", '') AS NUMERIC) DESC
              {limit_clause}`,
        params: [],
        param_types: [],
        optional_params: ["poc", "pocs", "size", "status", "state_code", "company",
          "client",
          "organization", "client", "categories", "category", "project_type", "project_types", "min_fee", "max_fee", "min_win", "max_win", "start_date", "end_date", "year", "limit"],
        chart_type: "bar",
        chart_field: "Fee",
      },

      get_projects_with_same_attribute: {
        sql: `-- This is a two-step query handled specially in executeQuery
              -- Step 1: Look up reference project
              -- Step 2: Find all projects with matching attribute`,
        params: ["reference_pid", "attribute"],
        param_types: ["str", "str"],
        optional_params: ["min_fee", "max_fee", "start_date", "end_date", "exclude_category", "exclude_status", "exclude_client", "state_code", "states"],
        chart_type: "bar",
        chart_field: "Fee",
      },

      compare_pocs: {
        sql: `SELECT 
              "PointOfContact" as poc,
              COUNT(*) as project_count,
              SUM(CAST(NULLIF("Fee", '') AS NUMERIC)) as total_value,
              AVG(CAST(NULLIF("Fee", '') AS NUMERIC)) as avg_project_value,
              AVG(CAST(NULLIF("ChanceOfSuccess", '') AS NUMERIC)) as avg_win_rate,
              COUNT(CASE WHEN "StatusChoice" = 'Won' THEN 1 END) as won_count,
              COUNT(CASE WHEN "StatusChoice" = 'Lost' THEN 1 END) as lost_count
              FROM "${TABLE}"
              WHERE ("PointOfContact" LIKE @p1 OR "PointOfContact" LIKE @p2)
              {additional_filters}
              GROUP BY "PointOfContact"
              ORDER BY total_value DESC`,
        params: ["poc1", "poc2"],
        param_types: ["str", "str"],
        optional_params: ["start_date", "end_date", "status", "company",
          "client",
          "organization", "state_code", "client", "categories", "min_fee", "max_fee"],
        chart_type: "bar",
        chart_field: "total_value",
      },

      // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
      // DESCRIPTION SEARCH
      // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

      search_description: {
        sql: `SELECT * FROM "${TABLE}" 
              WHERE "Title" LIKE @p1
              {status_filter}
              {additional_filters}
              ORDER BY CAST(NULLIF("Fee", '') AS NUMERIC) DESC
              {limit_clause}`,
        params: ["keyword"],
        param_types: ["str"],
        optional_params: ["size", "status", "state_code", "company",
          "client",
          "organization", "client", "categories", "min_fee", "max_fee", "min_win", "max_win", "start_date", "end_date", "limit"],
        chart_type: "bar",
        chart_field: "Fee",
      },

      // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
      // MONTH-BASED QUERIES
      // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

      get_projects_by_month: {
        sql: `SELECT * FROM "${TABLE}" 
              WHERE YEAR(TRY_CONVERT(DATE, "ConstStartDate")) = @p1
              AND MONTH(TRY_CONVERT(DATE, "ConstStartDate")) = @p2
              AND "ConstStartDate" > '2000-01-01'
              {additional_filters}
              ORDER BY CAST(NULLIF("Fee", '') AS NUMERIC) DESC
              {limit_clause}`,
        params: ["year", "month"],
        param_types: ["int", "int"],
        optional_params: ["size", "status", "state_code", "company",
          "client",
          "organization", "client", "categories", "min_fee", "max_fee", "min_win", "max_win", "limit"],
        chart_type: "bar",
        chart_field: "Fee",
      },

      get_revenue_by_month: {
        sql: `SELECT 
              YEAR(TRY_CONVERT(DATE, "ConstStartDate")) as year,
              MONTH(TRY_CONVERT(DATE, "ConstStartDate")) as month,
              COUNT(*) as project_count,
              SUM(CAST(NULLIF("Fee", '') AS NUMERIC)) as total_revenue,
              AVG(CAST(NULLIF("Fee", '') AS NUMERIC)) as avg_fee
              FROM "${TABLE}"
              WHERE YEAR(TRY_CONVERT(DATE, "ConstStartDate")) = @p1
              AND "ConstStartDate" > '2000-01-01'
              {additional_filters}
              GROUP BY year, month
              ORDER BY month`,
        params: ["year"],
        param_types: ["int"],
        optional_params: ["poc", "client", "company",
          "client",
          "organization", "state_code", "categories", "min_fee", "max_fee", "min_win", "max_win", "status", "quarter"],
        chart_type: "line",
        chart_field: "total_revenue",
      },

      // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
      // TREND ANALYSIS
      // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

      get_yoy_growth: {
        sql: `WITH yearly_stats AS (
                SELECT 
                  YEAR(TRY_CONVERT(DATE, "ConstStartDate")) as year,
                  COUNT(*) as project_count,
                  SUM(CAST(NULLIF("Fee", '') AS NUMERIC)) as total_revenue,
                  AVG(CAST(NULLIF("Fee", '') AS NUMERIC)) as avg_fee
                FROM "${TABLE}"
                WHERE YEAR(TRY_CONVERT(DATE, "ConstStartDate")) IN (@p1, @p2)
                AND "ConstStartDate" > '2000-01-01'
                {additional_filters}
                GROUP BY year
              )
              SELECT 
                year,
                project_count,
                total_revenue,
                avg_fee,
                LAG(total_revenue) OVER (ORDER BY year) as prev_year_revenue,
                CASE 
                  WHEN LAG(total_revenue) OVER (ORDER BY year) > 0 
                  THEN ((total_revenue - LAG(total_revenue) OVER (ORDER BY year)) / LAG(total_revenue) OVER (ORDER BY year)) * 100
                  ELSE NULL
                END as yoy_growth_pct
              FROM yearly_stats
              ORDER BY year`,
        params: ["year1", "year2"],
        param_types: ["int", "int"],
        optional_params: ["poc", "client", "company",
          "client",
          "organization", "state_code", "categories", "min_fee", "max_fee", "min_win", "max_win", "status"],
        chart_type: "bar",
        chart_field: "total_revenue",
      },

      // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
      // REGIONAL PERFORMANCE
      // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

      get_revenue_by_state: {
        sql: `SELECT "State" as state,
              COUNT(*) as project_count,
              SUM(CAST(NULLIF("Fee", '') AS NUMERIC)) as total_revenue,
              AVG(CAST(NULLIF("Fee", '') AS NUMERIC)) as avg_project_value,
              AVG(CAST(NULLIF("ChanceOfSuccess", '') AS NUMERIC)) as avg_win_rate,
              COUNT(CASE WHEN "StatusChoice" = 'Won' THEN 1 END) as won_count
              FROM "${TABLE}"
              WHERE "State" IS NOT NULL AND "State" != ''
              {additional_filters}
              GROUP BY "State"
              ORDER BY total_revenue DESC
              {limit_clause}`,
        params: [],
        param_types: [],
        optional_params: ["poc", "client", "company",
          "client",
          "organization", "status", "state_code", "states", "categories", "min_fee", "max_fee", "min_win", "max_win", "start_date", "end_date", "limit"],
        chart_type: "bar",
        chart_field: "total_revenue",
      },

      // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
      // CLIENT ANALYSIS
      // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

      get_repeat_clients: {
        sql: `SELECT "Client",
              COUNT(*) as project_count,
              SUM(CAST(NULLIF("Fee", '') AS NUMERIC)) as total_value,
              AVG(CAST(NULLIF("Fee", '') AS NUMERIC)) as avg_project_value,
              MIN("ConstStartDate") as first_project,
              MAX("ConstStartDate") as latest_project
              FROM "${TABLE}"
              WHERE "Client" IS NOT NULL AND "Client" != ''
              {additional_filters}
              GROUP BY "Client"
              HAVING COUNT(*) > 1
              ORDER BY project_count DESC
              {limit_clause}`,
        params: [],
        param_types: [],
        optional_params: ["poc", "company",
          "client",
          "organization", "status", "state_code", "categories", "min_fee", "max_fee", "min_win", "max_win", "start_date", "end_date", "limit"],
        chart_type: "bar",
        chart_field: "total_value",
      },

      // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
      // RISK ANALYSIS
      // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

      get_high_risk_opportunities: {
        sql: `SELECT * FROM "${TABLE}" 
              WHERE CAST(NULLIF("Fee", '') AS NUMERIC) > @p1
              AND CAST(NULLIF("ChanceOfSuccess", '') AS NUMERIC) < @p2
              AND "StatusChoice" NOT IN ('Won', 'Lost')
              {additional_filters}
              ORDER BY CAST(NULLIF("Fee", '') AS NUMERIC) DESC
              {limit_clause}`,
        params: ["min_fee", "max_win"],
        param_types: ["float", "int"],
        optional_params: ["poc", "client", "company",
          "client",
          "organization", "state_code", "categories", "start_date", "end_date", "limit"],
        chart_type: "bar",
        chart_field: "Fee",
      },

      // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
      // PROJECT TYPE ANALYSIS
      // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

      get_project_type_breakdown: {
        sql: `SELECT "ProjectType" as project_type,
              COUNT(*) as project_count,
              SUM(CAST(NULLIF("Fee", '') AS NUMERIC)) as total_revenue,
              AVG(CAST(NULLIF("Fee", '') AS NUMERIC)) as avg_fee,
              AVG(CAST(NULLIF("ChanceOfSuccess", '') AS NUMERIC)) as avg_win_rate
              FROM "${TABLE}"
              WHERE "ProjectType" IS NOT NULL AND "ProjectType" != ''
              {additional_filters}
              GROUP BY "ProjectType"
              ORDER BY project_count DESC
              {limit_clause}`,
        params: [],
        param_types: [],
        optional_params: ["client", "company",
          "client",
          "organization", "status", "state_code", "categories", "min_fee", "max_fee", "start_date", "end_date", "limit"],
        chart_type: "bar",
        chart_field: "project_count",
      },

      get_revenue_by_project_type: {
        sql: `SELECT "ProjectType",
              COUNT(*) as project_count,
              SUM(CAST(NULLIF("Fee", '') AS NUMERIC)) as total_revenue,
              AVG(CAST(NULLIF("Fee", '') AS NUMERIC)) as avg_fee,
              AVG(CAST(NULLIF("ChanceOfSuccess", '') AS NUMERIC)) as avg_win_rate
              FROM "${TABLE}"
              WHERE "ProjectType" IS NOT NULL AND "ProjectType" != ''
              {additional_filters}
              GROUP BY "ProjectType"
              ORDER BY total_revenue DESC
              {limit_clause}`,
        params: [],
        param_types: [],
        optional_params: ["client", "company",
          "client",
          "organization", "status", "state_code", "categories", "min_fee", "max_fee", "start_date", "end_date", "limit"],
        chart_type: "bar",
        chart_field: "total_revenue",
      },

      get_project_type_yoy_growth: {
        sql: `WITH yearly_project_types AS (
                SELECT 
                  "ProjectType" as project_type
                  YEAR(TRY_CONVERT(DATE, "ConstStartDate")) as year,
                  COUNT(*) as project_count,
                  SUM(CAST(NULLIF("Fee", '') AS NUMERIC)) as total_revenue
                FROM "${TABLE}"
                WHERE "ProjectType" IS NOT NULL AND "ProjectType" != ''
                  AND "ConstStartDate" > '2000-01-01'
                  {year_filter}
                  {additional_filters}
                GROUP BY "ProjectType", year
              ),
              with_lag AS (
                SELECT 
                  project_type,
                  year,
                  project_count,
                  total_revenue,
                  LAG(project_count) OVER (PARTITION BY project_type ORDER BY year) as prev_year_count,
                  LAG(total_revenue) OVER (PARTITION BY project_type ORDER BY year) as prev_year_revenue
                FROM yearly_project_types
              )
              SELECT 
                project_type,
                year,
                project_count,
                prev_year_count,
                (project_count - prev_year_count) as count_change,
                ROUND(((project_count - prev_year_count), DECIMAL(18,2)) / NULLIF(prev_year_count, 0) * 100), 2) as growth_pct,
                total_revenue,
                prev_year_revenue,
                (total_revenue - prev_year_revenue) as revenue_change
              FROM with_lag
              WHERE prev_year_count IS NOT NULL
                {growth_filter}
              ORDER BY growth_pct DESC
              {limit_clause}`,
        params: [],
        param_types: [],
        optional_params: ["year1", "year2", "show_only_increases", "show_only_decreases", "client", "company",
          "client",
          "organization", "status", "state_code", "categories", "min_fee", "max_fee", "limit"],
        chart_type: "bar",
        chart_field: "growth_pct",
      },

      // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
      // UTILITY QUERIES
      // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

      get_all_projects: {
        sql: `SELECT * FROM "${TABLE}" 
              WHERE 1=1
              {status_filter}
              {additional_filters}
              ORDER BY CAST(NULLIF("Fee", '') AS NUMERIC) DESC
              {limit_clause}`,
        params: [],
        param_types: [],
        optional_params: ["limit", "status", "size", "state_code", "company", "modules",
          "client",
          "organization", "categories", "min_fee", "max_fee", "min_win", "max_win"],
        chart_type: "bar",
        chart_field: "Fee",
      },

      get_project_by_id: {
        sql: `SELECT * FROM "${TABLE}" 
              WHERE (
                {pid_single_filter}
                {pid_range_filter}
              )
              ORDER BY TRY_CAST(SUBSTRING("Title", PATINDEX('%[0-9]%', "Title"), LEN("Title")) AS INT) ASC`,
        params: [],
        param_types: [],
        optional_params: ["project_name", "pid_start", "pid_end"],
        chart_type: "bar",
        chart_field: "Fee",
      },
      
      get_project_column_by_id: {
        sql: `SELECT TOP 1 "{column_name}" FROM "${TABLE}" 
              WHERE REPLACE(CAST("Title" AS NVARCHAR(MAX)), ' ', '') LIKE REPLACE(@p1, ' ', '')
              OR REPLACE(CAST("InternalId" AS NVARCHAR(MAX)), ' ', '') LIKE REPLACE(@p1, ' ', '')`,
        params: ["project_name"],
        param_types: ["str"],
        chart_type: "bar",
        chart_field: "Fee",
      },

      // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
      // TEXT / KEYWORD SEARCH QUERIES
      // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

      search_projects_by_keyword: {
        sql: `SELECT * FROM "${TABLE}" 
              WHERE "Title" LIKE @p1
              {status_filter}
              {additional_filters}
              ORDER BY CAST(NULLIF("Fee", '') AS NUMERIC) DESC
              {limit_clause}`,
        params: ["keyword"],
        param_types: ["str"],
        optional_params: ["size", "status", "state_code", "company",
          "client",
          "organization", "client", "categories", "min_fee", "max_fee", "min_win", "max_win", "start_date", "end_date", "limit"],
        chart_type: "bar",
        chart_field: "Fee",
      },

      // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
      // PHASE 1: HIGH-VALUE COMPARISONS
      // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

      compare_states: {
        sql: `SELECT 
              CASE 
                WHEN "State" IS NULL OR "State" = '' OR "State" = 'NULL' THEN 'Unknown'
                ELSE "State"
              END as state,
              COUNT(*) as project_count,
              SUM(CAST(NULLIF("Fee", '') AS NUMERIC)) as total_value,
              AVG(CAST(NULLIF("Fee", '') AS NUMERIC)) as avg_project_value,
              AVG(CAST(NULLIF("ChanceOfSuccess", '') AS NUMERIC)) as avg_win_rate,
              COUNT(CASE WHEN "StatusChoice" = 'Won' THEN 1 END) as won_count,
              COUNT(CASE WHEN "StatusChoice" = 'Lost' THEN 1 END) as lost_count
              FROM "${TABLE}"
              WHERE 1=1
              {state_filter}
              {status_filter}
              {additional_filters}
              GROUP BY CASE 
                WHEN "State" IS NULL OR "State" = '' OR "State" = 'NULL' THEN 'Unknown'
                ELSE "State"
              END
              ORDER BY total_value DESC`,
        params: [],
        param_types: [],
        optional_params: ["states", "project_type", "client", "company",
          "client",
          "organization", "start_date", "end_date", "status", "categories"],
        chart_type: "bar",
        chart_field: "total_value",
      },

      compare_regions: {
        sql: `SELECT 
              COALESCE(NULLIF(NULLIF("Region", ''), 'NULL'), 'Unknown') as region,
              COUNT(*) as project_count,
              SUM(CAST(NULLIF("Fee", '') AS NUMERIC)) as total_value,
              AVG(CAST(NULLIF("Fee", '') AS NUMERIC)) as avg_project_value,
              AVG(CAST(NULLIF("ChanceOfSuccess", '') AS NUMERIC)) as avg_win_rate,
              COUNT(CASE WHEN "StatusChoice" = 'Won' THEN 1 END) as won_count,
              COUNT(CASE WHEN "StatusChoice" = 'Lost' THEN 1 END) as lost_count
              FROM "${TABLE}"
              WHERE 1=1
              {status_filter}
              {additional_filters}
              GROUP BY COALESCE(NULLIF(NULLIF("Region", ''), 'NULL'), 'Unknown')
              ORDER BY total_value DESC`,
        params: [],
        param_types: [],
        optional_params: ["project_type", "client", "company",
          "client",
          "organization", "start_date", "end_date", "status", "categories"],
        chart_type: "bar",
        chart_field: "total_value",
      },

      compare_countries: {
        sql: `SELECT 
              COALESCE(NULLIF(NULLIF("Country", ''), 'NULL'), 'Unknown') as country,
              COUNT(*) as project_count,
              SUM(CAST(NULLIF("Fee", '') AS NUMERIC)) as total_value,
              AVG(CAST(NULLIF("Fee", '') AS NUMERIC)) as avg_project_value,
              AVG(CAST(NULLIF("ChanceOfSuccess", '') AS NUMERIC)) as avg_win_rate,
              COUNT(CASE WHEN "StatusChoice" = 'Won' THEN 1 END) as won_count,
              COUNT(CASE WHEN "StatusChoice" = 'Lost' THEN 1 END) as lost_count
              FROM "${TABLE}"
              WHERE 1=1
              {status_filter}
              {additional_filters}
              GROUP BY COALESCE(NULLIF(NULLIF("Country", ''), 'NULL'), 'Unknown')
              ORDER BY total_value DESC`,
        params: [],
        param_types: [],
        optional_params: ["project_type", "client", "company",
          "client",
          "organization", "start_date", "end_date", "status", "categories", "region"],
        chart_type: "bar",
        chart_field: "total_value",
      },

      get_category_breakdown: {
        sql: `SELECT "RequestCategory" as "Category",
              COUNT(*) as "Project Count",
              SUM(CAST(NULLIF("Fee", '') AS NUMERIC)) as "Total Fee",
              AVG(CAST(NULLIF("Fee", '') AS NUMERIC)) as "Average Fee",
              AVG(CAST(NULLIF("ChanceOfSuccess", '') AS NUMERIC)) as "Avg Win Rate",
              COUNT(CASE WHEN "StatusChoice" = 'Won' THEN 1 END) as "Won",
              COUNT(CASE WHEN "StatusChoice" = 'Lost' THEN 1 END) as "Lost"
              FROM "${TABLE}"
              WHERE "RequestCategory" IS NOT NULL AND "RequestCategory" != ''
              {status_filter}
              {additional_filters}
              GROUP BY "RequestCategory"
              {having_clause}
              ORDER BY COUNT(*) DESC
              {limit_clause}`,
        params: [],
        param_types: [],
        optional_params: ["start_date", "end_date", "status", "state_code", "company",
          "client",
          "organization", "client", "poc", "min_fee", "max_fee", "min_win", "max_win", "limit"],
        chart_type: "bar",
        chart_field: "Project Count",
      },

      compare_categories: {
        sql: `SELECT "RequestCategory" as category,
              COUNT(*) as project_count,
              SUM(CAST(NULLIF("Fee", '') AS NUMERIC)) as total_value,
              AVG(CAST(NULLIF("Fee", '') AS NUMERIC)) as avg_project_value,
              AVG(CAST(NULLIF("ChanceOfSuccess", '') AS NUMERIC)) as avg_win_rate,
              COUNT(CASE WHEN "StatusChoice" = 'Won' THEN 1 END) as won_count,
              COUNT(CASE WHEN "StatusChoice" = 'Lost' THEN 1 END) as lost_count
              FROM "${TABLE}"
              WHERE EXISTS (SELECT 1 FROM STRING_SPLIT(@p1, ',') s WHERE "RequestCategory" LIKE '%' + LTRIM(RTRIM(s.value)) + '%')
              {status_filter}
              {additional_filters}
              GROUP BY "RequestCategory"
              ORDER BY total_value DESC`,
        params: ["categories"],
        param_types: ["array"],
        optional_params: ["start_date", "end_date", "status", "state_code", "company"],
        chart_type: "bar",
        chart_field: "total_value",
      },

      get_top_clients: {
        sql: `SELECT "Client",
              COUNT(*) as project_count,
              SUM(CAST(NULLIF("Fee", '') AS NUMERIC)) as total_value,
              AVG(CAST(NULLIF("Fee", '') AS NUMERIC)) as avg_project_value,
              AVG(CAST(NULLIF("ChanceOfSuccess", '') AS NUMERIC)) as avg_win_rate,
              COUNT(CASE WHEN "StatusChoice" = 'Won' THEN 1 END) as won_count,
              COUNT(CASE WHEN "StatusChoice" = 'Lost' THEN 1 END) as lost_count,
              MAX("ConstStartDate") as latest_project
              FROM "${TABLE}"
              WHERE "Client" IS NOT NULL AND "Client" != ''
              {status_filter}
              {additional_filters}
              GROUP BY "Client"
              {having_clause}
              {order_by_clause}
              {limit_clause}`,
        params: [],
        param_types: [],
        optional_params: ["project_type", "start_date", "end_date", "status", "state_code", "company",
          "client",
          "organization", "categories", "min_fee", "max_fee", "min_win", "max_win", "min_project_count", "limit", "sort_by"],
        chart_type: "bar",
        chart_field: "total_value",
      },

      compare_clients: {
        sql: `SELECT "Client",
              COUNT(*) as project_count,
              SUM(CAST(NULLIF("Fee", '') AS NUMERIC)) as total_value,
              AVG(CAST(NULLIF("Fee", '') AS NUMERIC)) as avg_project_value,
              AVG(CAST(NULLIF("ChanceOfSuccess", '') AS NUMERIC)) as avg_win_rate,
              COUNT(CASE WHEN "StatusChoice" = 'Won' THEN 1 END) as won_count,
              COUNT(CASE WHEN "StatusChoice" = 'Lost' THEN 1 END) as lost_count,
              MAX("ConstStartDate") as latest_project
              FROM "${TABLE}"
              WHERE EXISTS (SELECT 1 FROM STRING_SPLIT(@p1, ',') s WHERE "Client" LIKE '%' + LTRIM(RTRIM(s.value)) + '%')
              {status_filter}
              {additional_filters}
              GROUP BY "Client"
              ORDER BY total_value DESC`,
        params: ["clients"],
        param_types: ["array"],
        optional_params: ["start_date", "end_date", "status", "state_code", "company"],
        chart_type: "bar",
        chart_field: "total_value",
      },

      compare_quarters: {
        sql: `SELECT 
              YEAR(TRY_CONVERT(DATE, "ConstStartDate")) as year,
              DATEPART(QUARTER, TRY_CONVERT(DATE, "ConstStartDate")) as quarter,
              CONCAT('Q', DATEPART(QUARTER, TRY_CONVERT(DATE, "ConstStartDate")), ' ', YEAR(TRY_CONVERT(DATE, "ConstStartDate"))) as period,
              COUNT(*) as project_count,
              SUM(CAST(NULLIF("Fee", '') AS NUMERIC)) as total_revenue,
              AVG(CAST(NULLIF("Fee", '') AS NUMERIC)) as avg_fee,
              AVG(CAST(NULLIF("ChanceOfSuccess", '') AS NUMERIC)) as avg_win_rate
              FROM "${TABLE}"
              WHERE (YEAR(TRY_CONVERT(DATE, "ConstStartDate")) = @p1 AND DATEPART(QUARTER, TRY_CONVERT(DATE, "ConstStartDate")) = @p2)
                 OR (YEAR(TRY_CONVERT(DATE, "ConstStartDate")) = @p3 AND DATEPART(QUARTER, TRY_CONVERT(DATE, "ConstStartDate")) = @p4)
              AND "ConstStartDate" > '2000-01-01'
              {status_filter}
              {additional_filters}
              GROUP BY year, quarter
              ORDER BY year, quarter`,
        params: ["year1", "quarter1", "year2", "quarter2"],
        param_types: ["int", "int", "int", "int"],
        optional_params: ["status", "company",
          "client",
          "organization", "state_code", "categories"],
        chart_type: "bar",
        chart_field: "total_revenue",
      },

      compare_months_across_years: {
        sql: `SELECT 
              YEAR(TRY_CONVERT(DATE, "ConstStartDate")) as year,
              MONTH(TRY_CONVERT(DATE, "ConstStartDate")) as month,
              FORMAT(TRY_CONVERT(DATE, "ConstStartDate"), 'MMM yyyy') as period,
              COUNT(*) as project_count,
              SUM(CAST(NULLIF("Fee", '') AS NUMERIC)) as total_revenue,
              AVG(CAST(NULLIF("Fee", '') AS NUMERIC)) as avg_fee
              FROM "${TABLE}"
              WHERE MONTH(TRY_CONVERT(DATE, "ConstStartDate")) = @p1
              AND YEAR(TRY_CONVERT(DATE, "ConstStartDate")) IN (SELECT value FROM STRING_SPLIT(@p2, ','))
              AND "ConstStartDate" > '2000-01-01'
              {status_filter}
              {additional_filters}
              GROUP BY year, month
              ORDER BY year`,
        params: ["month", "years"],
        param_types: ["int", "array"],
        optional_params: ["status", "company",
          "client",
          "organization", "state_code"],
        chart_type: "bar",
        chart_field: "total_revenue",
      },

      compare_to_average: {
        sql: `WITH segment_stats AS (
                SELECT 
                  CASE 
                    WHEN @p1 = 'company' THEN "Company"
                    WHEN @p1 = 'state' THEN "State"
                    WHEN @p1 = 'category' THEN "RequestCategory"
                    WHEN @p1 = 'poc' THEN "PointOfContact"
                  END as segment,
                  COUNT(*) as project_count,
                  SUM(CAST(NULLIF("Fee", '') AS NUMERIC)) as total_value,
                  AVG(CAST(NULLIF("Fee", '') AS NUMERIC)) as avg_project_value,
                  AVG(CAST(NULLIF("ChanceOfSuccess", '') AS NUMERIC)) as avg_win_rate
                FROM "${TABLE}"
                WHERE CASE 
                  WHEN @p1 = 'company' THEN "Company" IS NOT NULL
                  WHEN @p1 = 'state' THEN "State" IS NOT NULL
                  WHEN @p1 = 'category' THEN "RequestCategory" IS NOT NULL
                  WHEN @p1 = 'poc' THEN "PointOfContact" IS NOT NULL
                END
                GROUP BY segment
              ),
              overall_avg AS (
                SELECT 
                  AVG(avg_project_value) as overall_avg_value,
                  AVG(avg_win_rate) as overall_avg_win_rate
                FROM segment_stats
              )
              SELECT 
                s.segment,
                s.project_count,
                s.total_value,
                s.avg_project_value,
                s.avg_win_rate,
                o.overall_avg_value,
                o.overall_avg_win_rate,
                ROUND(((s.avg_project_value - o.overall_avg_value) / NULLIF(o.overall_avg_value, 0) * 100), DECIMAL(18,2)), 2) as pct_diff_from_avg
              FROM segment_stats s, overall_avg o
              WHERE s.segment LIKE @p2
              ORDER BY s.total_value DESC`,
        params: ["dimension", "value"],
        param_types: ["str", "str"],
        chart_type: "bar",
        chart_field: "total_value",
      },

      rank_all_pocs: {
        sql: `WITH poc_stats AS (
                SELECT 
                  "PointOfContact" as poc,
                  COUNT(*) as project_count,
                  SUM(CAST(NULLIF("Fee", '') AS NUMERIC)) as total_value,
                  AVG(CAST(NULLIF("Fee", '') AS NUMERIC)) as avg_project_value,
                  AVG(CAST(NULLIF("ChanceOfSuccess", '') AS NUMERIC)) as avg_win_rate,
                  COUNT(CASE WHEN "StatusChoice" = 'Won' THEN 1 END) as won_count,
                  COUNT(CASE WHEN "StatusChoice" = 'Lost' THEN 1 END) as lost_count,
                  ROUND((COUNT(CASE WHEN "StatusChoice" = 'Won' THEN 1 END), DECIMAL(18,2)) / 
                         NULLIF(COUNT(CASE WHEN "StatusChoice" IN ('Won', 'Lost') THEN 1 END), 0) * 100), DECIMAL(18,2)), 2) as actual_win_rate
                FROM "${TABLE}"
                WHERE "PointOfContact" IS NOT NULL AND "PointOfContact" != ''
                {date_filter}
                {additional_filters}
                GROUP BY "PointOfContact"
              )
              SELECT 
                ROW_NUMBER() OVER (ORDER BY total_value DESC) as rank,
                poc,
                project_count,
                total_value,
                avg_project_value,
                avg_win_rate,
                won_count,
                lost_count,
                actual_win_rate
              FROM poc_stats
              ORDER BY total_value DESC
              {limit_clause}`,
        params: [],
        param_types: [],
        optional_params: ["start_date", "end_date", "start_year", "end_year", "company",
          "client",
          "organization", "state_code", "size", "status", "client", "categories", "min_fee", "max_fee", "min_win", "max_win", "limit"],
        chart_type: "bar",
        chart_field: "total_value",
      },

      get_state_performance_ranking: {
        sql: `WITH state_stats AS (
                SELECT 
                  "State" as state,
                  COUNT(*) as project_count,
                  SUM(CAST(NULLIF("Fee", '') AS NUMERIC)) as total_value,
                  AVG(CAST(NULLIF("Fee", '') AS NUMERIC)) as avg_project_value,
                  AVG(CAST(NULLIF("ChanceOfSuccess", '') AS NUMERIC)) as avg_win_rate,
                  COUNT(CASE WHEN "StatusChoice" = 'Won' THEN 1 END) as won_count
                FROM "${TABLE}"
                WHERE "State" IS NOT NULL AND "State" != ''
                {date_filter}
                {additional_filters}
                GROUP BY "State"
              )
              SELECT 
                ROW_NUMBER() OVER (ORDER BY total_value DESC) as rank,
                state,
                project_count,
                total_value,
                avg_project_value,
                avg_win_rate,
                won_count
              FROM state_stats
              ORDER BY total_value DESC
              {limit_clause}`,
        params: [],
        param_types: [],
        optional_params: ["start_date", "end_date", "start_year", "end_year", "company",
          "client",
          "organization", "status", "state_code", "states", "size", "client", "categories", "min_fee", "max_fee", "min_win", "max_win", "limit"],
        chart_type: "bar",
        chart_field: "total_value",
      },

      get_client_lifetime_value: {
        sql: `SELECT "Client",
              COUNT(*) as project_count,
              SUM(CAST(NULLIF("Fee", '') AS NUMERIC)) as lifetime_value,
              AVG(CAST(NULLIF("Fee", '') AS NUMERIC)) as avg_project_value,
              MIN("ConstStartDate") as first_project_date,
              MAX("ConstStartDate") as latest_project_date,
              DATEDIFF(DAY, MIN(TRY_CONVERT(DATE, "ConstStartDate")), MAX(TRY_CONVERT(DATE, "ConstStartDate"))) as relationship_days,
              COUNT(CASE WHEN "StatusChoice" = 'Won' THEN 1 END) as won_count
              FROM "${TABLE}"
              WHERE "Client" IS NOT NULL AND "Client" != ''
              {additional_filters}
              GROUP BY "Client"
              ORDER BY lifetime_value DESC
              {limit_clause}`,
        params: [],
        param_types: [],
        optional_params: ["start_date", "end_date", "company",
          "client",
          "organization", "state_code", "limit"],
        chart_type: "bar",
        chart_field: "lifetime_value",
      },

      get_client_win_rate_by_type: {
        sql: `SELECT 
              CASE 
                WHEN project_count >= 10 THEN 'Enterprise'
                WHEN project_count >= 5 THEN 'Mid-Market'
                ELSE 'Small'
              END as client_tier,
              COUNT(DISTINCT "Client") as client_count,
              SUM(project_count) as total_projects,
              AVG(avg_win_rate) as avg_win_rate,
              SUM(total_value) as total_value
              FROM (
                SELECT 
                  "Client",
                  COUNT(*) as project_count,
                  SUM(CAST(NULLIF("Fee", '') AS NUMERIC)) as total_value,
                  AVG(CAST(NULLIF("ChanceOfSuccess", '') AS NUMERIC)) as avg_win_rate
                FROM "${TABLE}"
                WHERE "Client" IS NOT NULL AND "Client" != ''
                GROUP BY "Client"
              ) client_stats
              GROUP BY client_tier
              ORDER BY 
                CASE client_tier 
                  WHEN 'Enterprise' THEN 1 
                  WHEN 'Mid-Market' THEN 2 
                  ELSE 3 
                END`,
        params: [],
        param_types: [],
        chart_type: "bar",
        chart_field: "total_value",
      },

      get_poc_efficiency: {
        sql: `SELECT 
              "PointOfContact" as poc,
              COUNT(*) as project_count,
              SUM(CAST(NULLIF("Fee", '') AS NUMERIC)) as total_value,
              ROUND((SUM(CAST(NULLIF("Fee", '') AS NUMERIC)) / NULLIF(COUNT(*), 0)), DECIMAL(18,2)), 2) as revenue_per_project,
              AVG(CAST(NULLIF("ChanceOfSuccess", '') AS NUMERIC)) as avg_win_rate,
              COUNT(CASE WHEN "StatusChoice" = 'Won' THEN 1 END) as won_count,
              COUNT(CASE WHEN "StatusChoice" = 'Lost' THEN 1 END) as lost_count
              FROM "${TABLE}"
              WHERE "PointOfContact" IS NOT NULL AND "PointOfContact" != ''
              {additional_filters}
              GROUP BY "PointOfContact"
              ORDER BY revenue_per_project DESC
              {limit_clause}`,
        params: [],
        param_types: [],
        optional_params: ["start_date", "end_date", "company",
          "client",
          "organization", "state_code", "limit"],
        chart_type: "bar",
        chart_field: "revenue_per_project",
      },

      get_poc_win_rate_trend: {
        sql: `SELECT 
              "PointOfContact" as poc,
              YEAR(TRY_CONVERT(DATE, "ConstStartDate")) as year,
              DATEPART(QUARTER, TRY_CONVERT(DATE, "ConstStartDate")) as quarter,
              COUNT(*) as project_count,
              AVG(CAST(NULLIF("ChanceOfSuccess", '') AS NUMERIC)) as avg_predicted_win_rate,
              COUNT(CASE WHEN "StatusChoice" = 'Won' THEN 1 END) as won_count,
              COUNT(CASE WHEN "StatusChoice" IN ('Won', 'Lost') THEN 1 END) as closed_count,
              ROUND((COUNT(CASE WHEN "StatusChoice" = 'Won' THEN 1 END), DECIMAL(18,2)) / 
                     NULLIF(COUNT(CASE WHEN "StatusChoice" IN ('Won', 'Lost') THEN 1 END), 0) * 100), DECIMAL(18,2)), 2) as actual_win_rate
              FROM "${TABLE}"
              WHERE "PointOfContact" LIKE @p1
              AND "ConstStartDate" > '2000-01-01'
              GROUP BY "PointOfContact", year, quarter
              ORDER BY year DESC, quarter DESC`,
        params: ["poc"],
        param_types: ["str"],
        chart_type: "line",
        chart_field: "actual_win_rate",
      },

      get_top_bottom_performers: {
        sql: `WITH poc_performance AS (
                SELECT 
                  "PointOfContact" as poc,
                  COUNT(*) as project_count,
                  SUM(CAST(NULLIF("Fee", '') AS NUMERIC)) as total_value,
                  AVG(CAST(NULLIF("Fee", '') AS NUMERIC)) as avg_project_value,
                  AVG(CAST(NULLIF("ChanceOfSuccess", '') AS NUMERIC)) as avg_win_rate
                FROM "${TABLE}"
                WHERE "PointOfContact" IS NOT NULL AND "PointOfContact" != ''
                {additional_filters}
                GROUP BY "PointOfContact"
                HAVING COUNT(*) >= 3
              ),
              ranked AS (
                SELECT 
                  poc,
                  project_count,
                  total_value,
                  avg_project_value,
                  avg_win_rate,
                  ROW_NUMBER() OVER (ORDER BY total_value DESC) as rank_desc,
                  ROW_NUMBER() OVER (ORDER BY total_value ASC) as rank_asc
                FROM poc_performance
              )
              SELECT 
                poc,
                project_count,
                total_value,
                avg_project_value,
                avg_win_rate,
                CASE WHEN rank_desc <= 5 THEN 'Top Performer'
                     WHEN rank_asc <= 5 THEN 'Needs Improvement'
                     ELSE 'Average'
                END as performance_tier
              FROM ranked
              WHERE rank_desc <= 5 OR rank_asc <= 5
              ORDER BY total_value DESC`,
        params: [],
        param_types: [],
        optional_params: ["start_date", "end_date", "company",
          "client",
          "organization", "state_code"],
        chart_type: "bar",
        chart_field: "total_value",
      },

      get_category_by_state_matrix: {
        sql: `SELECT 
              "State" as state,
              "RequestCategory" as category,
              COUNT(*) as project_count,
              SUM(CAST(NULLIF("Fee", '') AS NUMERIC)) as total_value,
              AVG(CAST(NULLIF("ChanceOfSuccess", '') AS NUMERIC)) as avg_win_rate
              FROM "${TABLE}"
              WHERE "State" IS NOT NULL AND "State" != ''
              AND "RequestCategory" IS NOT NULL AND "RequestCategory" != ''
              {additional_filters}
              GROUP BY "State", "RequestCategory"
              ORDER BY total_value DESC
              {limit_clause}`,
        params: [],
        param_types: [],
        optional_params: ["start_date", "end_date", "company",
          "client",
          "organization", "status", "state_code", "states", "limit"],
        chart_type: "bar",
        chart_field: "total_value",
      },

      get_status_by_category_matrix: {
        sql: `SELECT 
              "RequestCategory" as category,
              "StatusChoice",
              COUNT(*) as project_count,
              SUM(CAST(NULLIF("Fee", '') AS NUMERIC)) as total_value,
              AVG(CAST(NULLIF("ChanceOfSuccess", '') AS NUMERIC)) as avg_win_rate,
              ROUND((COUNT(*), DECIMAL(18,2)) / SUM(COUNT(*)) OVER (PARTITION BY "RequestCategory") * 100), DECIMAL(18,2)), 2) as pct_of_category
              FROM "${TABLE}"
              WHERE "RequestCategory" IS NOT NULL AND "RequestCategory" != ''
              AND "StatusChoice" IS NOT NULL AND "StatusChoice" != ''
              {additional_filters}
              GROUP BY "RequestCategory", "StatusChoice"
              ORDER BY "RequestCategory", total_value DESC`,
        params: [],
        param_types: [],
        optional_params: ["start_date", "end_date", "company",
          "client",
          "organization", "state_code"],
        chart_type: "bar",
        chart_field: "total_value",
      },

      // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
      // PHASE 2: TREND & FORECASTING
      // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

      get_quarterly_trends: {
        sql: `WITH quarterly_data AS (
                SELECT 
                  YEAR(TRY_CONVERT(DATE, "ConstStartDate")) as year,
                  DATEPART(QUARTER, TRY_CONVERT(DATE, "ConstStartDate")) as quarter,
                  CONCAT('Q', DATEPART(QUARTER, TRY_CONVERT(DATE, "ConstStartDate")), ' ', YEAR(TRY_CONVERT(DATE, "ConstStartDate"))) as period,
                  COUNT(*) as project_count,
                  SUM(CAST(NULLIF("Fee", '') AS NUMERIC)) as total_revenue,
                  AVG(CAST(NULLIF("ChanceOfSuccess", '') AS NUMERIC)) as avg_win_rate
                FROM "${TABLE}"
                WHERE "ConstStartDate" > '2000-01-01'
                {additional_filters}
                GROUP BY year, quarter
              ),
              with_lag AS (
                SELECT 
                  period,
                  year,
                  quarter,
                  project_count,
                  total_revenue,
                  avg_win_rate,
                  LAG(total_revenue) OVER (ORDER BY year, quarter) as prev_revenue
                FROM quarterly_data
              )
              SELECT 
                period,
                year,
                quarter,
                project_count,
                total_revenue,
                avg_win_rate,
                prev_revenue,
                ROUND(((total_revenue - prev_revenue) / NULLIF(prev_revenue, 0) * 100), DECIMAL(18,2)), 2) as growth_rate_pct
              FROM with_lag
              ORDER BY year DESC, quarter DESC
              {limit_clause}`,
        params: [],
        param_types: [],
        optional_params: ["start_date", "end_date", "company",
          "client",
          "organization", "state_code", "status", "limit"],
        chart_type: "line",
        chart_field: "total_revenue",
      },

      get_best_worst_quarters: {
        sql: `WITH quarterly_revenue AS (
                SELECT 
                  YEAR(TRY_CONVERT(DATE, "ConstStartDate")) as year,
                  DATEPART(QUARTER, TRY_CONVERT(DATE, "ConstStartDate")) as quarter,
                  CONCAT('Q', DATEPART(QUARTER, TRY_CONVERT(DATE, "ConstStartDate")), ' ', YEAR(TRY_CONVERT(DATE, "ConstStartDate"))) as period,
                  SUM(CAST(NULLIF("Fee", '') AS NUMERIC)) as total_revenue,
                  COUNT(*) as project_count
                FROM "${TABLE}"
                WHERE "ConstStartDate" > '2000-01-01'
                {additional_filters}
                GROUP BY year, quarter
              ),
              ranked AS (
                SELECT 
                  period,
                  total_revenue,
                  project_count,
                  ROW_NUMBER() OVER (ORDER BY total_revenue DESC) as rank_desc,
                  ROW_NUMBER() OVER (ORDER BY total_revenue ASC) as rank_asc
                FROM quarterly_revenue
              )
              SELECT 
                period,
                total_revenue,
                project_count,
                CASE 
                  WHEN rank_desc <= 3 THEN 'Peak Quarter'
                  WHEN rank_asc <= 3 THEN 'Trough Quarter'
                END as quarter_type
              FROM ranked
              WHERE rank_desc <= 3 OR rank_asc <= 3
              ORDER BY total_revenue DESC`,
        params: [],
        param_types: [],
        optional_params: ["start_date", "end_date", "company",
          "client",
          "organization", "state_code"],
        chart_type: "bar",
        chart_field: "total_revenue",
      },

      get_monthly_momentum: {
        sql: `WITH monthly_data AS (
                SELECT 
                  YEAR(TRY_CONVERT(DATE, "ConstStartDate")) as year,
                  MONTH(TRY_CONVERT(DATE, "ConstStartDate")) as month,
                  FORMAT(TRY_CONVERT(DATE, "ConstStartDate"), 'MMM yyyy') as period,
                  SUM(CAST(NULLIF("Fee", '') AS NUMERIC)) as total_revenue,
                  COUNT(*) as project_count
                FROM "${TABLE}"
                WHERE "ConstStartDate" > '2000-01-01'
                {additional_filters}
                GROUP BY YEAR(TRY_CONVERT(DATE, "ConstStartDate")), MONTH(TRY_CONVERT(DATE, "ConstStartDate")), FORMAT(TRY_CONVERT(DATE, "ConstStartDate"), 'MMM yyyy')
              ),
              with_lag AS (
                SELECT 
                  period,
                  year,
                  month,
                  total_revenue,
                  project_count,
                  LAG(total_revenue, 1) OVER (ORDER BY year, month) as prev_month_revenue,
                  LAG(total_revenue, 2) OVER (ORDER BY year, month) as two_months_ago_revenue
                FROM monthly_data
              )
              SELECT 
                period,
                total_revenue,
                project_count,
                prev_month_revenue,
                ROUND(((total_revenue - prev_month_revenue) / NULLIF(prev_month_revenue, 0) * 100), DECIMAL(18,2)), 2) as mom_growth_pct,
                CASE 
                  WHEN total_revenue > prev_month_revenue AND prev_month_revenue > two_months_ago_revenue THEN 'Accelerating'
                  WHEN total_revenue < prev_month_revenue AND prev_month_revenue < two_months_ago_revenue THEN 'Decelerating'
                  WHEN total_revenue > prev_month_revenue THEN 'Growing'
                  WHEN total_revenue < prev_month_revenue THEN 'Declining'
                  ELSE 'Stable'
                END as momentum
              FROM with_lag
              WHERE prev_month_revenue IS NOT NULL
              ORDER BY year DESC, month DESC
              {limit_clause}`,
        params: [],
        param_types: [],
        optional_params: ["start_date", "end_date", "company",
          "client",
          "organization", "state_code", "limit"],
        chart_type: "line",
        chart_field: "total_revenue",
      },

      get_seasonal_patterns: {
        sql: `SELECT 
              MONTH(TRY_CONVERT(DATE, "ConstStartDate")) as month,
              DATENAME(MONTH, TRY_CONVERT(DATE, "ConstStartDate")) as month_name,
              COUNT(*) as total_projects,
              SUM(CAST(NULLIF("Fee", '') AS NUMERIC)) as total_revenue,
              AVG(CAST(NULLIF("Fee", '') AS NUMERIC)) as avg_project_value,
              COUNT(DISTINCT YEAR(TRY_CONVERT(DATE, "ConstStartDate"))) as years_of_data
              FROM "${TABLE}"
              WHERE "ConstStartDate" > '2000-01-01'
              {additional_filters}
              GROUP BY MONTH(TRY_CONVERT(DATE, "ConstStartDate")), DATENAME(MONTH, TRY_CONVERT(DATE, "ConstStartDate"))
              ORDER BY MONTH(TRY_CONVERT(DATE, "ConstStartDate"))`,
        params: [],
        param_types: [],
        optional_params: ["start_date", "end_date", "company",
          "client",
          "organization", "state_code", "status"],
        chart_type: "bar",
        chart_field: "total_revenue",
      },

      get_revenue_trend_by_category: {
        sql: `WITH category_quarterly AS (
                SELECT 
                  "RequestCategory" as category,
                  YEAR(TRY_CONVERT(DATE, "ConstStartDate")) as year,
                  DATEPART(QUARTER, TRY_CONVERT(DATE, "ConstStartDate")) as quarter,
                  CONCAT('Q', DATEPART(QUARTER, TRY_CONVERT(DATE, "ConstStartDate")), ' ', YEAR(TRY_CONVERT(DATE, "ConstStartDate"))) as period,
                  SUM(CAST(NULLIF("Fee", '') AS NUMERIC)) as total_revenue,
                  COUNT(*) as project_count
                FROM "${TABLE}"
                WHERE "RequestCategory" LIKE @p1
                AND "ConstStartDate" > '2000-01-01'
                {additional_filters}
                GROUP BY category, year, quarter
              ),
              with_lag AS (
                SELECT 
                  category,
                  period,
                  total_revenue,
                  project_count,
                  LAG(total_revenue) OVER (PARTITION BY category ORDER BY year, quarter) as prev_revenue
                FROM category_quarterly
              )
              SELECT 
                category,
                period,
                total_revenue,
                project_count,
                ROUND(((total_revenue - prev_revenue) / NULLIF(prev_revenue, 0) * 100), DECIMAL(18,2)), 2) as growth_rate_pct
              FROM with_lag
              ORDER BY period DESC`,
        params: ["category"],
        param_types: ["str"],
        optional_params: ["start_date", "end_date", "company",
          "client",
          "organization", "state_code"],
        chart_type: "line",
        chart_field: "total_revenue",
      },

      get_revenue_trend_by_state: {
        sql: `WITH state_quarterly AS (
                SELECT 
                  "State" as state,
                  YEAR(TRY_CONVERT(DATE, "ConstStartDate")) as year,
                  DATEPART(QUARTER, TRY_CONVERT(DATE, "ConstStartDate")) as quarter,
                  CONCAT('Q', DATEPART(QUARTER, TRY_CONVERT(DATE, "ConstStartDate")), ' ', YEAR(TRY_CONVERT(DATE, "ConstStartDate"))) as period,
                  SUM(CAST(NULLIF("Fee", '') AS NUMERIC)) as total_revenue,
                  COUNT(*) as project_count
                FROM "${TABLE}"
                WHERE "State" LIKE @p1
                AND "ConstStartDate" > '2000-01-01'
                {additional_filters}
                GROUP BY state, year, quarter
              ),
              with_lag AS (
                SELECT 
                  state,
                  period,
                  year,
                  quarter,
                  total_revenue,
                  project_count,
                  LAG(total_revenue) OVER (PARTITION BY state ORDER BY year, quarter) as prev_revenue
                FROM state_quarterly
              )
              SELECT 
                state,
                period,
                total_revenue,
                project_count,
                ROUND(((total_revenue - prev_revenue) / NULLIF(prev_revenue, 0) * 100), DECIMAL(18,2)), 2) as growth_rate_pct
              FROM with_lag
              ORDER BY year DESC, quarter DESC`,
        params: ["state_code"],
        param_types: ["str"],
        optional_params: ["start_date", "end_date", "company",
          "client",
          "organization", "status", "state_code", "states"],
        chart_type: "line",
        chart_field: "total_revenue",
      },

      get_revenue_trend_by_client: {
        sql: `WITH client_quarterly AS (
                SELECT 
                  "Client",
                  YEAR(TRY_CONVERT(DATE, "ConstStartDate")) as year,
                  DATEPART(QUARTER, TRY_CONVERT(DATE, "ConstStartDate")) as quarter,
                  CONCAT('Q', DATEPART(QUARTER, TRY_CONVERT(DATE, "ConstStartDate")), ' ', YEAR(TRY_CONVERT(DATE, "ConstStartDate"))) as period,
                  SUM(CAST(NULLIF("Fee", '') AS NUMERIC)) as total_revenue,
                  COUNT(*) as project_count
                FROM "${TABLE}"
                WHERE "Client" LIKE @p1
                AND "ConstStartDate" > '2000-01-01'
                {additional_filters}
                GROUP BY "Client", year, quarter
              ),
              with_lag AS (
                SELECT 
                  "Client",
                  period,
                  year,
                  quarter,
                  total_revenue,
                  project_count,
                  LAG(total_revenue) OVER (PARTITION BY "Client" ORDER BY year, quarter) as prev_revenue
                FROM client_quarterly
              )
              SELECT 
                "Client",
                period,
                total_revenue,
                project_count,
                ROUND(((total_revenue - prev_revenue) / NULLIF(prev_revenue, 0) * 100), DECIMAL(18,2)), 2) as growth_rate_pct,
                CASE 
                  WHEN total_revenue > prev_revenue THEN 'Growing'
                  WHEN total_revenue < prev_revenue THEN 'Declining'
                  ELSE 'Stable'
                END as trend
              FROM with_lag
              ORDER BY year DESC, quarter DESC`,
        params: ["client"],
        param_types: ["str"],
        optional_params: ["start_date", "end_date", "company",
          "client",
          "organization", "state_code"],
        chart_type: "line",
        chart_field: "total_revenue",
      },

      get_pipeline_velocity: {
        sql: `SELECT 
              "StatusChoice",
              COUNT(*) as project_count,
              AVG(DATEDIFF(DAY, TRY_CONVERT(DATE, "ConstStartDate"), CAST(GETDATE() AS DATE))) as avg_days_in_pipeline,
              MIN(DATEDIFF(DAY, TRY_CONVERT(DATE, "ConstStartDate"), CAST(GETDATE() AS DATE))) as min_days,
              MAX(DATEDIFF(DAY, TRY_CONVERT(DATE, "ConstStartDate"), CAST(GETDATE() AS DATE))) as max_days,
              PERCENTILE_CONT(0.5) WITHIN GROUP (ORDER BY DATEDIFF(DAY, TRY_CONVERT(DATE, "ConstStartDate"), CAST(GETDATE() AS DATE))) as median_days
              FROM "${TABLE}"
              WHERE "StatusChoice" IN ('Won', 'Lost', 'In Progress', 'On Hold')
              {additional_filters}
              GROUP BY "StatusChoice"
              ORDER BY avg_days_in_pipeline DESC`,
        params: [],
        param_types: [],
        optional_params: ["start_date", "end_date", "company",
          "client",
          "organization", "state_code", "categories"],
        chart_type: "bar",
        chart_field: "avg_days_in_pipeline",
      },

      get_conversion_rate_trend: {
        sql: `WITH quarterly_conversions AS (
                SELECT 
                  YEAR(TRY_CONVERT(DATE, "ConstStartDate")) as year,
                  DATEPART(QUARTER, TRY_CONVERT(DATE, "ConstStartDate")) as quarter,
                  CONCAT('Q', DATEPART(QUARTER, TRY_CONVERT(DATE, "ConstStartDate")), ' ', YEAR(TRY_CONVERT(DATE, "ConstStartDate"))) as period,
                  COUNT(CASE WHEN "StatusChoice" = 'Won' THEN 1 END) as won_count,
                  COUNT(CASE WHEN "StatusChoice" = 'Lost' THEN 1 END) as lost_count,
                  COUNT(CASE WHEN "StatusChoice" IN ('Won', 'Lost') THEN 1 END) as closed_count,
                  ROUND((COUNT(CASE WHEN "StatusChoice" = 'Won' THEN 1 END), DECIMAL(18,2)) / 
                         NULLIF(COUNT(CASE WHEN "StatusChoice" IN ('Won', 'Lost') THEN 1 END), 0) * 100), DECIMAL(18,2)), 2) as win_rate
                FROM "${TABLE}"
                WHERE "ConstStartDate" > '2000-01-01'
                {additional_filters}
                GROUP BY year, quarter
              ),
              with_lag AS (
                SELECT 
                  period,
                  year,
                  quarter,
                  won_count,
                  lost_count,
                  closed_count,
                  win_rate,
                  LAG(win_rate) OVER (ORDER BY year, quarter) as prev_win_rate
                FROM quarterly_conversions
              )
              SELECT 
                period,
                won_count,
                lost_count,
                closed_count,
                win_rate,
                prev_win_rate,
                ROUND((win_rate - prev_win_rate), DECIMAL(18,2)), 2) as win_rate_change
              FROM with_lag
              ORDER BY year DESC, quarter DESC
              {limit_clause}`,
        params: [],
        param_types: [],
        optional_params: ["start_date", "end_date", "company",
          "client",
          "organization", "state_code", "categories", "limit"],
        chart_type: "line",
        chart_field: "win_rate",
      },

      get_deal_cycle_analysis: {
        sql: `WITH sized_deals AS (
                SELECT 
                  CASE 
                    WHEN CAST(NULLIF("Fee", '') AS NUMERIC) < 50000 THEN 'Small (<50K)'
                    WHEN CAST(NULLIF("Fee", '') AS NUMERIC) < 200000 THEN 'Medium (50-200K)'
                    WHEN CAST(NULLIF("Fee", '') AS NUMERIC) < 500000 THEN 'Large (200-500K)'
                    ELSE 'Mega (500K+)'
                  END as deal_size,
                  "RequestCategory" as category,
                  COUNT(*) as project_count,
                  AVG(DATEDIFF(DAY, TRY_CONVERT(DATE, "ConstStartDate"), CAST(GETDATE() AS DATE))) as avg_cycle_days,
                  PERCENTILE_CONT(0.5) WITHIN GROUP (ORDER BY DATEDIFF(DAY, TRY_CONVERT(DATE, "ConstStartDate"), CAST(GETDATE() AS DATE))) as median_cycle_days
                FROM "${TABLE}"
                WHERE "Fee" IS NOT NULL AND "Fee" != ''
                AND CAST(NULLIF("Fee", '') AS NUMERIC) > 0
                AND "StatusChoice" IN ('Won', 'Lost')
                {additional_filters}
                GROUP BY deal_size, category
              )
              SELECT * FROM sized_deals
              ORDER BY 
                CASE deal_size
                  WHEN 'Mega (500K+)' THEN 1
                  WHEN 'Large (200-500K)' THEN 2
                  WHEN 'Medium (50-200K)' THEN 3
                  ELSE 4
                END,
                category`,
        params: [],
        param_types: [],
        optional_params: ["start_date", "end_date", "company",
          "client",
          "organization", "state_code"],
        chart_type: "bar",
        chart_field: "avg_cycle_days",
      },

      get_pipeline_coverage: {
        sql: `WITH pipeline_stats AS (
                SELECT 
                  COUNT(*) as total_opportunities,
                  COUNT(CASE WHEN "StatusChoice" NOT IN ('Won', 'Lost') THEN 1 END) as open_opportunities,
                  SUM(CAST(NULLIF("Fee", '') AS NUMERIC)) as total_pipeline_value,
                  SUM(CASE WHEN "StatusChoice" NOT IN ('Won', 'Lost') 
                      THEN CAST(NULLIF("Fee", '') AS NUMERIC) * CAST(NULLIF("ChanceOfSuccess", '') AS NUMERIC) / 100 
                      END) as weighted_pipeline_value,
                  AVG(CAST(NULLIF("ChanceOfSuccess", '') AS NUMERIC)) as avg_win_probability
                FROM "${TABLE}"
                WHERE "ConstStartDate" > '2000-01-01'
                {additional_filters}
              )
              SELECT 
                total_opportunities,
                open_opportunities,
                total_pipeline_value,
                weighted_pipeline_value,
                avg_win_probability,
                ROUND(CAST(open_opportunities AS DECIMAL(18,2)) / NULLIF(total_opportunities, 0) * 100, 2) as pct_still_open
              FROM pipeline_stats`,
        params: [],
        param_types: [],
        optional_params: ["start_date", "end_date", "company",
          "client",
          "organization", "state_code", "categories"],
        chart_type: "bar",
        chart_field: "weighted_pipeline_value",
      },

      get_pipeline_quality: {
        sql: `WITH tiered_pipeline AS (
                SELECT 
                  CASE 
                    WHEN CAST(NULLIF("ChanceOfSuccess", '') AS NUMERIC) >= 70 THEN 'High Probability (70%+)'
                    WHEN CAST(NULLIF("ChanceOfSuccess", '') AS NUMERIC) >= 40 THEN 'Medium Probability (40-70%)'
                    ELSE 'Low Probability (<40%)'
                  END as probability_tier,
                  COUNT(*) as opportunity_count,
                  SUM(CAST(NULLIF("Fee", '') AS NUMERIC)) as total_value,
                  AVG(CAST(NULLIF("Fee", '') AS NUMERIC)) as avg_deal_size,
                  SUM(CAST(NULLIF("Fee", '') AS NUMERIC) * CAST(NULLIF("ChanceOfSuccess", '') AS NUMERIC) / 100) as weighted_value
                FROM "${TABLE}"
                WHERE "StatusChoice" NOT IN ('Won', 'Lost')
                AND "ChanceOfSuccess" IS NOT NULL AND "ChanceOfSuccess" != ''
                {additional_filters}
                GROUP BY probability_tier
              )
              SELECT * FROM tiered_pipeline
              ORDER BY 
                CASE probability_tier
                  WHEN 'High Probability (70%+)' THEN 1
                  WHEN 'Medium Probability (40-70%)' THEN 2
                  ELSE 3
                END`,
        params: [],
        param_types: [],
        optional_params: ["start_date", "end_date", "company",
          "client",
          "organization", "state_code", "categories"],
        chart_type: "pie",
        chart_field: "opportunity_count",
      },

      // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
      // PHASE 3: CLIENT INTELLIGENCE & PHASE 4: RISK/PERFORMANCE
      // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

      get_clients_by_value_tier: {
        sql: `WITH client_stats AS (
                SELECT 
                  "Client",
                  COUNT(*) as project_count,
                  SUM(CAST(NULLIF("Fee", '') AS NUMERIC)) as total_value,
                  AVG(CAST(NULLIF("Fee", '') AS NUMERIC)) as avg_project_value,
                  MAX("ConstStartDate") as latest_project
                FROM "${TABLE}"
                WHERE "Client" IS NOT NULL AND "Client" != ''
                {additional_filters}
                GROUP BY "Client"
              )
              SELECT 
                "Client",
                project_count,
                total_value,
                avg_project_value,
                latest_project,
                CASE 
                  WHEN total_value >= 1000000 THEN 'Platinum (1M+)'
                  WHEN total_value >= 500000 THEN 'Gold (500K-1M)'
                  WHEN total_value >= 100000 THEN 'Silver (100K-500K)'
                  ELSE 'Bronze (<100K)'
                END as client_tier
              FROM client_stats
              ORDER BY total_value DESC
              {limit_clause}`,
        params: [],
        param_types: [],
        optional_params: ["start_date", "end_date", "company",
          "client",
          "organization", "state_code", "limit"],
        chart_type: "bar",
        chart_field: "total_value",
      },

      get_client_retention_rate: {
        sql: `WITH client_years AS (
                SELECT 
                  "Client",
                  COUNT(DISTINCT YEAR(TRY_CONVERT(DATE, "ConstStartDate"))) as years_active,
                  MIN(YEAR(TRY_CONVERT(DATE, "ConstStartDate"))) as first_year,
                  MAX(YEAR(TRY_CONVERT(DATE, "ConstStartDate"))) as last_year,
                  COUNT(*) as total_projects
                FROM "${TABLE}"
                WHERE "Client" IS NOT NULL AND "Client" != ''
                AND "ConstStartDate" > '2000-01-01'
                GROUP BY "Client"
              ),
              categorized AS (
                SELECT 
                  CASE 
                    WHEN years_active = 1 THEN 'One-Time Client'
                    WHEN years_active >= 5 THEN 'Long-Term (5+ years)'
                    WHEN years_active >= 3 THEN 'Established (3-4 years)'
                    ELSE 'Repeat (2 years)'
                  END as retention_category,
                  COUNT(*) as client_count,
                  SUM(total_projects) as total_projects,
                  ROUND(AVG(total_projects), DECIMAL(18,2)), 2) as avg_projects_per_client
                FROM client_years
                GROUP BY retention_category
              )
              SELECT * FROM categorized
              ORDER BY 
                CASE retention_category
                  WHEN 'Long-Term (5+ years)' THEN 1
                  WHEN 'Established (3-4 years)' THEN 2
                  WHEN 'Repeat (2 years)' THEN 3
                  ELSE 4
                END`,
        params: [],
        param_types: [],
        chart_type: "pie",
        chart_field: "client_count",
      },

      get_dormant_clients: {
        sql: `WITH client_last_activity AS (
                SELECT 
                  "Client",
                  MAX("ConstStartDate") as last_project_date,
                  DATEDIFF(DAY, MAX(TRY_CONVERT(DATE, "ConstStartDate")), CAST(GETDATE() AS DATE)) as days_since_last_project,
                  COUNT(*) as total_projects,
                  SUM(CAST(NULLIF("Fee", '') AS NUMERIC)) as lifetime_value
                FROM "${TABLE}"
                WHERE "Client" IS NOT NULL AND "Client" != ''
                GROUP BY "Client"
              )
              SELECT 
                "Client",
                last_project_date,
                days_since_last_project,
                total_projects,
                lifetime_value,
                CASE 
                  WHEN days_since_last_project > 730 THEN 'Dormant (2+ years)'
                  WHEN days_since_last_project > 365 THEN 'At Risk (1-2 years)'
                  ELSE 'Recent (<1 year)'
                END as client_status
              FROM client_last_activity
              WHERE days_since_last_project > 365
              ORDER BY lifetime_value DESC
              {limit_clause}`,
        params: [],
        param_types: [],
        optional_params: ["limit", "state_code", "states", "company",
          "client",
          "organization", "status", "categories"],
        chart_type: "bar",
        chart_field: "lifetime_value",
      },

      get_at_risk_clients: {
        sql: `WITH client_trends AS (
                SELECT 
                  "Client",
                  COUNT(*) as total_projects,
                  SUM(CAST(NULLIF("Fee", '') AS NUMERIC)) as lifetime_value,
                  MAX("ConstStartDate") as last_project,
                  DATEDIFF(DAY, MAX(TRY_CONVERT(DATE, "ConstStartDate")), CAST(GETDATE() AS DATE)) as days_inactive,
                  COUNT(CASE WHEN TRY_CONVERT(DATE, "ConstStartDate") >= DATEADD(DAY, -365, CAST(GETDATE() AS DATE)) THEN 1 END) as projects_last_year,
                  COUNT(CASE WHEN TRY_CONVERT(DATE, "ConstStartDate") >= DATEADD(DAY, -730, CAST(GETDATE() AS DATE)) AND TRY_CONVERT(DATE, "ConstStartDate") < DATEADD(DAY, -365, CAST(GETDATE() AS DATE)) THEN 1 END) as projects_prior_year
                FROM "${TABLE}"
                WHERE "Client" IS NOT NULL AND "Client" != ''
                GROUP BY "Client"
                HAVING COUNT(*) > 1
              ),
              risk_assessed AS (
                SELECT 
                  "Client",
                  total_projects,
                  lifetime_value,
                  last_project,
                  days_inactive,
                  projects_last_year,
                  projects_prior_year,
                  CASE 
                    WHEN projects_last_year < projects_prior_year AND days_inactive > 180 THEN 'High Risk'
                    WHEN projects_last_year < projects_prior_year THEN 'Medium Risk'
                    WHEN days_inactive > 365 THEN 'Medium Risk'
                    ELSE 'Low Risk'
                  END as risk_level
                FROM client_trends
                WHERE projects_last_year < projects_prior_year OR days_inactive > 180
              )
              SELECT * FROM risk_assessed
              ORDER BY 
                CASE risk_level
                  WHEN 'High Risk' THEN 1
                  WHEN 'Medium Risk' THEN 2
                  ELSE 3
                END,
                lifetime_value DESC
              {limit_clause}`,
        params: [],
        param_types: [],
        optional_params: ["limit", "state_code", "states", "company",
          "client",
          "organization", "status", "categories"],
        chart_type: "bar",
        chart_field: "lifetime_value",
      },

      get_client_expansion_opportunities: {
        sql: `WITH client_categories AS (
                SELECT 
                  "Client",
                  STRING_AGG(CAST("RequestCategory" AS NVARCHAR(MAX)), ', ') as categories_purchased,
                  COUNT(DISTINCT "RequestCategory") as category_count,
                  SUM(CAST(NULLIF("Fee", '') AS NUMERIC)) as total_value,
                  COUNT(*) as project_count,
                  AVG(CAST(NULLIF(REPLACE("ChanceOfSuccess", '%', ''), '') AS NUMERIC)) as avg_win_pct
                FROM "${TABLE}"
                WHERE "Client" IS NOT NULL AND "Client" != ''
                AND "RequestCategory" IS NOT NULL
                {category_clause}
                {min_fee_clause}
                {max_fee_clause}
                {min_win_clause}
                {max_win_clause}
                {state_clause}
                {status_clause}
                {company_clause}
                GROUP BY "Client"
                HAVING COUNT(DISTINCT "RequestCategory") < 3
              )
              SELECT 
                "Client",
                category_count,
                categories_purchased,
                total_value,
                project_count,
                ROUND(avg_win_pct, 1) as "Avg Win %",
                CASE 
                  WHEN category_count = 1 THEN 'High Expansion Potential'
                  WHEN category_count = 2 THEN 'Medium Expansion Potential'
                  ELSE 'Low Expansion Potential'
                END as expansion_opportunity
              FROM client_categories
              ORDER BY total_value DESC
              {limit_clause}`,
        params: [],
        param_types: [],
        optional_params: ["limit", "state_code", "states", "company",
          "client",
          "organization", "status", "categories", "category", "min_win", "max_win", "min_fee", "max_fee"],
        chart_type: "bar",
        chart_field: "total_value",
      },

      get_clients_with_multiple_pocs: {
        sql: `SELECT 
                "Client",
                COUNT(DISTINCT "PointOfContact") as poc_count,
                STRING_AGG(CAST("PointOfContact" AS NVARCHAR(MAX)), ', ') WITHIN GROUP (ORDER BY "PointOfContact") as poc_list,
                COUNT(*) as project_count,
                SUM(CAST(NULLIF("Fee", '') AS NUMERIC)) as total_value,
                AVG(CAST(NULLIF("Fee", '') AS NUMERIC)) as avg_project_value,
                AVG(CAST(NULLIF("ChanceOfSuccess", '') AS NUMERIC)) as avg_win_rate
              FROM "${TABLE}"
              WHERE "Client" IS NOT NULL AND "Client" != ''
              {status_filter}
              {additional_filters}
              GROUP BY "Client"
              HAVING COUNT(DISTINCT "PointOfContact") > 1
              ORDER BY poc_count DESC, project_count DESC
              {limit_clause}`,
        params: [],
        param_types: [],
        optional_params: ["status", "company",
          "client",
          "organization", "state_code", "categories", "start_date", "end_date", "limit"],
        chart_type: "bar",
        chart_field: "poc_count",
      },

      get_portfolio_diversity: {
        sql: `WITH concentration_metrics AS (
                SELECT 
                  COUNT(DISTINCT "Client") as total_clients,
                  COUNT(DISTINCT "State") as total_states,
                  COUNT(DISTINCT "RequestCategory") as total_categories,
                  COUNT(DISTINCT "Company") as total_companies,
                  SUM(CAST(NULLIF("Fee", '') AS NUMERIC)) as total_revenue
                FROM "${TABLE}"
                WHERE "ConstStartDate" > '2000-01-01'
                {additional_filters}
              ),
              top_clients AS (
                SELECT 
                  SUM(client_value) as top_10_client_revenue
                FROM (
                  SELECT TOP 10
                    SUM(CAST(NULLIF("Fee", '') AS NUMERIC)) as client_value
                  FROM "${TABLE}"
                  WHERE "Client" IS NOT NULL
                  GROUP BY "Client"
                  ORDER BY client_value DESC
                ) top_10
              )
              SELECT 
                c.total_clients,
                c.total_states,
                c.total_categories,
                c.total_companies,
                c.total_revenue,
                t.top_10_client_revenue,
                ROUND((t.top_10_client_revenue / NULLIF(c.total_revenue, 0) * 100), DECIMAL(18,2)), 2) as top_10_concentration_pct
              FROM concentration_metrics c, top_clients t`,
        params: [],
        param_types: [],
        optional_params: ["start_date", "end_date", "company",
          "client",
          "organization", "state_code"],
        chart_type: "bar",
        chart_field: "total_revenue",
      },

      get_client_concentration: {
        sql: `WITH ranked_clients AS (
                SELECT 
                  "Client",
                  SUM(CAST(NULLIF("Fee", '') AS NUMERIC)) as client_revenue,
                  COUNT(*) as project_count,
                  SUM(SUM(CAST(NULLIF("Fee", '') AS NUMERIC))) OVER () as total_revenue,
                  ROW_NUMBER() OVER (ORDER BY SUM(CAST(NULLIF("Fee", '') AS NUMERIC)) DESC) as revenue_rank
                FROM "${TABLE}"
                WHERE "Client" IS NOT NULL AND "Client" != ''
                {additional_filters}
                GROUP BY "Client"
              )
              SELECT 
                revenue_rank,
                "Client",
                client_revenue,
                project_count,
                ROUND((client_revenue / NULLIF(total_revenue, 0) * 100), DECIMAL(18,2)), 2) as pct_of_total_revenue,
                SUM(client_revenue) OVER (ORDER BY revenue_rank) as cumulative_revenue,
                ROUND((SUM(client_revenue) OVER (ORDER BY revenue_rank) / NULLIF(total_revenue, 0) * 100), DECIMAL(18,2)), 2) as cumulative_pct
              FROM ranked_clients
              WHERE revenue_rank <= 20
              ORDER BY revenue_rank`,
        params: [],
        param_types: [],
        optional_params: ["start_date", "end_date", "company",
          "client",
          "organization", "state_code"],
        chart_type: "bar",
        chart_field: "client_revenue",
      },

      get_declining_win_rates: {
        sql: `WITH quarterly_win_rates AS (
                SELECT 
                  YEAR(TRY_CONVERT(DATE, "ConstStartDate")) as year,
                  DATEPART(QUARTER, TRY_CONVERT(DATE, "ConstStartDate")) as quarter,
                  CONCAT('Q', DATEPART(QUARTER, TRY_CONVERT(DATE, "ConstStartDate")), ' ', YEAR(TRY_CONVERT(DATE, "ConstStartDate"))) as period,
                  ROUND((COUNT(CASE WHEN "StatusChoice" = 'Won' THEN 1 END), DECIMAL(18,2)) / 
                         NULLIF(COUNT(CASE WHEN "StatusChoice" IN ('Won', 'Lost') THEN 1 END), 0) * 100), DECIMAL(18,2)), 2) as win_rate,
                  COUNT(CASE WHEN "StatusChoice" IN ('Won', 'Lost') THEN 1 END) as closed_deals
                FROM "${TABLE}"
                WHERE "ConstStartDate" > '2000-01-01'
                {additional_filters}
                GROUP BY year, quarter
                HAVING COUNT(CASE WHEN "StatusChoice" IN ('Won', 'Lost') THEN 1 END) >= 3
              ),
              with_lag AS (
                SELECT 
                  period,
                  year,
                  quarter,
                  win_rate,
                  closed_deals,
                  LAG(win_rate) OVER (ORDER BY year, quarter) as prev_win_rate,
                  LAG(win_rate, 2) OVER (ORDER BY year, quarter) as two_quarters_ago_win_rate
                FROM quarterly_win_rates
              )
              SELECT 
                period,
                win_rate,
                prev_win_rate,
                closed_deals,
                ROUND((win_rate - prev_win_rate), DECIMAL(18,2)), 2) as win_rate_change
              FROM with_lag
              WHERE win_rate < prev_win_rate 
              AND prev_win_rate < two_quarters_ago_win_rate
              ORDER BY year DESC, quarter DESC
              {limit_clause}`,
        params: [],
        param_types: [],
        optional_params: ["start_date", "end_date", "company",
          "client",
          "organization", "state_code", "categories", "limit"],
        chart_type: "line",
        chart_field: "win_rate",
      },

      get_underperforming_segments: {
        sql: `WITH segment_performance AS (
                SELECT 
                  @p1 as dimension,
                  CASE 
                    WHEN @p1 = 'category' THEN "RequestCategory"
                    WHEN @p1 = 'state' THEN "State"
                    WHEN @p1 = 'company' THEN "Company"
                  END as segment_name,
                  COUNT(*) as project_count,
                  SUM(CAST(NULLIF("Fee", '') AS NUMERIC)) as total_value,
                  AVG(CAST(NULLIF("Fee", '') AS NUMERIC)) as avg_project_value,
                  ROUND((COUNT(CASE WHEN "StatusChoice" = 'Won' THEN 1 END), DECIMAL(18,2)) / 
                         NULLIF(COUNT(CASE WHEN "StatusChoice" IN ('Won', 'Lost') THEN 1 END), 0) * 100), DECIMAL(18,2)), 2) as win_rate
                FROM "${TABLE}"
                WHERE CASE 
                  WHEN @p1 = 'category' THEN "RequestCategory" IS NOT NULL
                  WHEN @p1 = 'state' THEN "State" IS NOT NULL
                  WHEN @p1 = 'company' THEN "Company" IS NOT NULL
                END
                {additional_filters}
                GROUP BY segment_name
                HAVING COUNT(*) >= 5
              ),
              averages AS (
                SELECT 
                  AVG(avg_project_value) as overall_avg_value,
                  AVG(win_rate) as overall_avg_win_rate
                FROM segment_performance
              )
              SELECT 
                s.segment_name,
                s.project_count,
                s.total_value,
                s.avg_project_value,
                s.win_rate,
                a.overall_avg_value,
                a.overall_avg_win_rate,
                ROUND(((s.avg_project_value - a.overall_avg_value) / NULLIF(a.overall_avg_value, 0) * 100), DECIMAL(18,2)), 2) as pct_below_avg_value,
                ROUND((s.win_rate - a.overall_avg_win_rate), DECIMAL(18,2)), 2) as pct_below_avg_win_rate
              FROM segment_performance s, averages a
              WHERE s.avg_project_value < a.overall_avg_value 
              OR s.win_rate < a.overall_avg_win_rate
              ORDER BY s.total_value ASC
              {limit_clause}`,
        params: ["dimension"],
        param_types: ["str"],
        optional_params: ["start_date", "end_date", "company",
          "client",
          "organization", "state_code", "limit"],
        chart_type: "bar",
        chart_field: "total_value",
      },

      get_stalled_deals: {
        sql: `SELECT 
              "Title",
              "Client",
              "State" as state,
              "RequestCategory" as category,
              "StatusChoice",
              "ConstStartDate",
              CAST(NULLIF("Fee", '') AS NUMERIC) as fee,
              CAST(NULLIF("ChanceOfSuccess", '') AS NUMERIC) as win_probability,
              DATEDIFF(DAY, TRY_CONVERT(DATE, "ConstStartDate"), CAST(GETDATE() AS DATE)) as days_in_pipeline,
              "PointOfContact" as poc
              FROM "${TABLE}"
              WHERE "StatusChoice" NOT IN ('Won', 'Lost')
              AND DATEDIFF(DAY, TRY_CONVERT(DATE, "ConstStartDate"), CAST(GETDATE() AS DATE)) > @p1
              AND "Fee" IS NOT NULL
              {additional_filters}
              ORDER BY DATEDIFF(DAY, TRY_CONVERT(DATE, "ConstStartDate"), CAST(GETDATE() AS DATE)) DESC
              {limit_clause}`,
        params: ["min_days_stalled"],
        param_types: ["int"],
        optional_params: ["status", "company",
          "client",
          "organization", "state_code", "categories", "limit"],
        chart_type: "bar",
        chart_field: "fee",
      },

      get_projects_with_missing_fields: {
        sql: `SELECT * FROM "${TABLE}" 
              WHERE (
                ("Fee" IS NULL OR "Fee" = '') OR 
                ("ConstStartDate" IS NULL OR TRY_CONVERT(DATE, "ConstStartDate") < '1900-01-01') OR 
                ("Description" IS NULL OR "Description" = '')
              )
              {status_filter}
              {additional_filters}
              ORDER BY CAST(NULLIF("Fee", '') AS NUMERIC) DESC
              {limit_clause}`,
        params: [],
        param_types: [],
        optional_params: ["status", "company",
          "client",
          "organization", "state_code", "categories", "limit"],
        chart_type: "bar",
        chart_field: "Fee",
      },
    };
  }

  private initializeFunctionDefinitions(): FunctionDefinition[] {
    return [
      // Status transition clarification - special handler
      {
        name: "clarify_status_transition_not_supported",
        description:
          "Use ONLY when user asks about projects that MOVED/CHANGED/TRANSITIONED from one status to another (e.g., 'moved from Lead to Proposal Development', 'changed from Won to Lost', 'transitioned from Submitted to In Progress'). This feature requires status change history which is not currently tracked. DO NOT use for simple status filters like 'projects in Lead status' - use get_projects_by_combined_filters for those.",
        parameters: {
          type: "object",
          properties: {
            from_status: {
              type: "string",
              description: "The status the project moved FROM",
            },
            to_status: {
              type: "string",
              description: "The status the project moved TO",
            },
            time_reference: {
              type: "string",
              description: "Time period for the transition (optional)",
            },
          },
          required: [],
        },
      },

      // Simple answer extraction - for AI Analysis follow-ups AND column lookups from previous results
      {
        name: "provide_simple_answer",
        description:
          "Use for: (1) Follow-up questions to AI Analysis responses (e.g., 'what are limitations', 'main assumptions'), (2) Follow-up questions asking about specific columns from previous query results (e.g., 'when was the start date', 'what is the division', 'who is the POC', 'which department', 'what status'). For column lookups, extract the relevant column values from the previous result data and format as readable answer. Column mappings: start date/when â†’ ConstStartDate, division â†’ Division, department â†’ Department, POC/who/assigned â†’ PointOfContact, status â†’ StatusChoice, fee/revenue â†’ Fee, client â†’ Client, company â†’ Company, category â†’ RequestCategory, type â†’ ProjectType, state/location â†’ State, region â†’ Region, country â†’ Country.",
        parameters: {
          type: "object",
          properties: {
            answer: { 
              type: "string", 
              description: "The extracted information from the previous AI Analysis narrative OR the column values from previous query results, formatted as a readable answer. For column lookups, summarize the values (e.g., 'The start dates are: 2025-01-15, 2025-02-20, ...' or 'The division is LFDH NY')." 
            },
          },
          required: ["answer"],
        },
      },

      // AI-powered data analysis - for predictive/reasoning queries
      {
        name: "ai_data_analysis",
        description:
          "Use when user asks analytical or predictive questions that require AI reasoning on data (e.g., 'predict final fees', 'which projects will likely succeed', 'analyze profit margins', 'estimate completion rates', 'forecast revenue from tags/categories', 'tag co-occurrence analysis'). The AI will fetch relevant project data and provide intelligent analysis. Supports filtering by status, categories (Request Category column), project_type (Project Type column - e.g., 'Hospitals', 'Bridges', 'Solar'), OR tags (Tags column - comma-separated values). **IMPORTANT**: 'Hospitals' is a PROJECT TYPE not a category - use project_type parameter. Categories are broad sectors like 'Healthcare', 'Transportation'. **TAG CO-OCCURRENCE**: When user asks about tags appearing together (e.g., 'lead remediation' and 'unit kitchens'), ALWAYS extract both tags into the tags array - the system uses AND logic to find projects containing ALL specified tags. IMPORTANT: For 'versus' comparison queries (e.g., 'over $100M versus under $10M'), DO NOT set both min_fee and max_fee - just pass the analysis_question and let AI analyze ALL data to make the comparison. DO NOT use for simple data retrieval - use specific query functions for those.",
        parameters: {
          type: "object",
          properties: {
            analysis_question: {
              type: "string",
              description: "The analytical question to answer (e.g., 'predict final negotiated fees', 'compare win rates for projects over $100M versus under $10M'). For comparison queries with 'versus', include the full comparison in this field and DO NOT set conflicting fee filters.",
            },
            status: {
              type: "string",
              description: "Project status to filter data (optional). Use only when filtering to a single status, not for comparisons.",
            },
            categories: {
              type: "array",
              items: { type: "string" },
              description: "Request Category column (ONLY use when user explicitly says 'category' or 'categories'). NEVER use this by default. If user says 'type', 'of type', 'type of', use project_type instead.",
            },
            project_type: {
              type: "string",
              description: "**DEFAULT FIELD** for type filtering. Use for ANY type-related query (e.g., 'education type', 'higher education', 'Hospitals', 'Bridges', 'Solar'). ALWAYS prefer this over categories unless user explicitly says 'category'.",
            },
            tags: {
              type: "array",
              items: { type: "string" },
              description: "ALWAYS extract tag names when user mentions specific tags (e.g., 'lead remediation', 'unit kitchens', 'substations', 'bridges'). For co-occurrence queries ('tags appearing together'), extract ALL mentioned tags. The system will find projects containing ALL specified tags (AND logic). Tags are stored as comma-separated values in the Tags column.",
            },
            min_fee: {
              type: "number",
              description: "Minimum fee to filter data (optional). WARNING: Do NOT use together with max_fee for 'versus' comparisons - that creates impossible filter (Fee >= X AND Fee <= Y where X > Y). For 'fee equal to X' or 'fee exactly X' queries, set BOTH min_fee AND max_fee to X.",
            },
            max_fee: {
              type: "number",
              description: "Maximum fee to filter data (optional). WARNING: Do NOT use together with min_fee for 'versus' comparisons - that creates impossible filter. For 'fee equal to X' or 'fee exactly X' queries, set BOTH min_fee AND max_fee to X.",
            },
          },
          required: ["analysis_question"],
        },
      },

      // Combined filters - most flexible
      {
        name: "get_projects_by_combined_filters",
        description:
          "Get projects matching MULTIPLE filters simultaneously. PRIMARY FUNCTION for: (1) Time-based queries with status/win rate (e.g., 'Submitted projects starting in next 30 days', 'projects likely to be won soon', 'high win rate projects beginning this month'), (2) Complex queries with size, tags, status, dates, Is Updated field, project title, etc. (4) TITLE SEARCH: 'projects under title X', 'titled X', 'title contains X' â†’ use title parameter for partial matching, (3) CHRONOLOGICAL QUERIES: 'first project ever', 'oldest project', 'earliest project', 'newest project', 'most recent project', 'latest project' â†’ set sort_field='start_date' and sort_direction='ASC' for oldest/first/earliest or 'DESC' for newest/latest/most recent. Use start_date/end_date for ANY time reference ('next X days', 'within 60 days', 'starting soon', 'this quarter'). **CRITICAL EXCLUSION**: DO NOT use for DURATION-IN-STATUS queries like 'stuck in [status] for X days', 'been in Proposal Development for over 60 days', 'projects in pipeline longer than X days' - use get_stalled_deals instead. DO NOT use for ranking/sorting queries like 'top by win rate' or 'sorted by fee' - use specific ranking functions instead. Use 'tags' parameter ONLY when user explicitly mentions 'tags' or 'tagged'. For general keywords without 'tags' mention, use get_projects_by_category instead. For Client (Client ID), use 'client' field, NOT 'company'. DO NOT use this for person names - use get_projects_by_poc instead. CRITICAL: Use 'exclude_categories' for negations like 'NOT in Healthcare', 'except Transportation', 'excluding Corporate'. **IMPORTANT**: 'Is Updated' is a DATABASE COLUMN (values: '0' or '1'), NOT a tag - use is_updated parameter, NOT exclude_tags! **MULTI-STATUS QUERIES**: When user asks for multiple statuses with OR logic (e.g., 'Proposal Development OR Submitted', 'Won or Lost'), you MUST pass status as an ARRAY of individual statuses: ['Proposal Development', 'Submitted']. Never pass comma-separated strings.",
        parameters: {
          type: "object",
          properties: {
            size: {
              type: "string",
              description: "Size category: Micro, Small, Medium, Large, Mega",
            },
            categories: {
              type: "array",
              items: { type: "string" },
              description: "Request Category column (ONLY use when user explicitly says 'category' or 'categories'). NEVER use this by default. For 'type' queries, use project_type instead.",
            },
            exclude_categories: {
              type: "array",
              items: { type: "string" },
              description: "Request Category values to EXCLUDE. Use when query has 'NOT in X', 'except Y', 'excluding Z', 'but not in X' (e.g., 'but not in Healthcare' â†’ exclude_categories: ['Healthcare'])",
            },
            tags: {
              type: "array",
              items: { type: "string" },
              description: "Keywords/tags to INCLUDE. Only when user explicitly says 'tags' or 'tagged' (e.g., 'show tags: Rail, Transit'). For general category queries without 'tags' keyword, use get_projects_by_category instead.",
            },
            exclude_tags: {
              type: "array",
              items: { type: "string" },
              description: "Keywords/tags to EXCLUDE. Use when query has 'NOT tagged with X', 'except tag Y', 'excluding tags Z'. DO NOT use for 'Is Updated' field!",
            },
            title: { type: "string", description: "Project title to filter by (partial match). Use for queries like 'projects under title X', 'title contains X', 'projects titled X', or when user mentions a specific project name to search for." },
            status: { 
              type: "array", 
              items: { type: "string", description: "Individual project status" },
              description: "Project status values (pass as array for OR logic): Won, Lost, Lead, Submitted, In Progress, Proposal Development, Qualified Lead, Hold. Also accepts: completed, finished (mapped to Won). Examples: ['Submitted'] for single status, ['Proposal Development', 'Submitted'] for OR query." 
            },
            client: { type: "string", description: "ONLY for explicit Client IDs like 'Client 1573', 'Client 4885'. Do NOT use for company/brand names like 'Google', 'Microsoft' - use 'organization' parameter instead. Do NOT use for person names - use 'poc' instead." },
            poc: { type: "string", description: "Point Of Contact / POC / person name. Use when filtering by PERSON NAME (e.g., 'Amy Wincko', 'Michael Luciani'). DO NOT use for Client - that's the 'client' field." },
            company: { type: "string", description: "Company/OPCO operating company name (NOT for Client)" },
            organization: { type: "string", description: "Use for company/brand names like 'Google', 'Microsoft', 'Acme'. Searches BOTH Client AND Company columns. Examples: 'show projects for Google', 'list Acme projects', 'Google client projects' (extract 'Google'). Use this instead of 'client' parameter unless user provides an explicit Client number like 'Client 1573'." },
            division: { type: "string", description: "Single division/business unit name (e.g., 'SCM: Cost Management', 'Architecture', 'Engineering'). Use for queries like 'projects in X division'." },
            divisions: { type: "array", items: { type: "string" }, description: "Multiple division names for OR logic (e.g., ['SCM: Cost Management', 'Architecture']). Use for 'projects in X and Y divisions'." },
            department: { type: "string", description: "Single department name (e.g., 'Civil', 'Structural', 'IT'). Use for queries like 'projects in X department'." },
            departments: { type: "array", items: { type: "string" }, description: "Multiple department names for OR logic (e.g., ['Civil', 'Structural']). Use for 'projects in X and Y departments'." },
            state_code: { type: "string", description: "State lookup code" },
            min_fee: { type: "number", description: "Minimum fee amount. For 'fee equal to X' or 'fee exactly X' queries, set BOTH min_fee AND max_fee to X." },
            max_fee: { type: "number", description: "Maximum fee amount. For 'fee equal to X' or 'fee exactly X' queries, set BOTH min_fee AND max_fee to X." },
            min_win: { type: "integer", description: "Minimum win percentage" },
            max_win: { type: "integer", description: "Maximum win percentage" },
            is_updated: { type: "string", description: "Filter by 'Is Updated' column: '0' (not updated) or '1' (updated). Use for queries like 'projects marked as Is Updated = 0'. This is a COLUMN, NOT a tag!" },
            project_type: { type: "string", description: "**DEFAULT FIELD** for type filtering. Use for ANY 'type' query: 'education type', 'higher education', 'Hospitals', 'Bridges', 'Solar'. ALWAYS prefer this over categories unless user explicitly says 'category'." },
            project_types: { type: "array", items: { type: "string" }, description: "Array of Project Types for OR logic (e.g., ['Hospitals', 'Pharma'] for 'hospitals or pharma type'). ALWAYS prefer this over categories unless user explicitly says 'category'." },
            time_reference: {
              type: "string",
              description:
                "Natural language time reference. Extract EXACT user phrase: 'next ten months', 'last 6 months', 'Q1 2026', 'soon', etc.",
            },
            start_date: { type: "string", description: "Start date filter (YYYY-MM-DD). Use for 'starting after X', 'from X', 'after year X', 'last N years', 'past N months'. CRITICAL: For 'last 10 years' or 'past 5 years', calculate the date by subtracting from today. Example: 'last 10 years' (if today is 2026-01-20) â†’ start_date='2016-01-20'. Example: 'starting after 2025' â†’ '2025-01-01'." },
            end_date: { type: "string", description: "End date filter (YYYY-MM-DD). Use for 'before X', 'until X', 'ending by X', 'last N years'. CRITICAL: For 'last 10 years', set end_date to today's date (e.g., '2026-01-20')." },
            sort_field: { 
              type: "string", 
              enum: ["start_date", "fee"],
              description: "Field to sort by: 'start_date' for chronological queries ('first project', 'oldest', 'earliest', 'newest', 'latest', 'most recent'), 'fee' for value-based queries (default)." 
            },
            sort_direction: { 
              type: "string", 
              enum: ["ASC", "DESC"],
              description: "Sort order: 'ASC' for oldest/first/earliest (ascending by date or lowest fee), 'DESC' for newest/latest/most recent or highest fee. For chronological queries: 'first/oldest/earliest' â†’ 'ASC', 'newest/latest/most recent' â†’ 'DESC'." 
            },
            limit: { type: "integer", description: "Result limit" },
          },
          required: [],
        },
      },

      // Rankings
      {
        name: "get_largest_projects",
        description: "Get largest/highest/biggest/top INDIVIDUAL PROJECTS by fee. Use for: 'largest project', 'biggest project by fee', 'top 10 projects by fee', 'highest fee project'. **ALSO use for client/company/POC/PROJECT TYPE queries asking for highest/largest/biggest fee WITHOUT aggregation**: 'which CLIENT has highest fee' (returns the project with highest fee showing its client), 'which COMPANY has biggest project', 'which POC has largest fee', **'which PROJECT TYPE has highest fee'** (returns single project with highest fee showing its type). For aggregated totals per type, use get_revenue_by_project_type instead. **SUPPORTS FILTERS**: Can combine with category, project_type, status, etc. (e.g., 'largest Aviation projects with Aviation-land-side type'). ORDINAL SUPPORT: For 'second best', 'third best', 'fourth largest', etc., set limit=1 and offset=(N-1). Examples: 'best project'â†’{limit:1}, 'second best project'â†’{limit:1,offset:1}, 'third largest project'â†’{limit:1,offset:2}, '5th biggest project'â†’{limit:1,offset:4}, 'which client has highest fee'â†’{limit:1}, 'which project type has highest fee'â†’{limit:1}",
        parameters: {
          type: "object",
          properties: {
            limit: { type: "integer", description: "Number of results (use 1 for single project queries)" },
            offset: { type: "integer", description: "Number of results to skip. For ordinal queries: 'second'=1, 'third'=2, 'fourth'=3, etc." },
            time_reference: { type: "string" },
            category: { type: "string", description: "Request Category filter (e.g., 'Aviation', 'Healthcare', 'Transportation')" },
            project_type: { type: "string", description: "Project Type filter (e.g., 'Aviation-land-side', 'Hospitals', 'GV - Government Buildings')" },
            status: { type: "string", description: "Project status filter" },
            client: { type: "string", description: "Client name or Client filter" },
            company: { type: "string", description: "Company/OPCO filter" },
            state_code: { type: "string", description: "State lookup code filter" },
            tags: { type: "array", items: { type: "string" }, description: "Tags to filter by" },
            min_fee: { type: "number", description: "Minimum fee filter. For 'fee equal to X', set BOTH min_fee AND max_fee to X." },
            max_fee: { type: "number", description: "Maximum fee filter. For 'fee equal to X', set BOTH min_fee AND max_fee to X." },
            min_win: { type: "integer", description: "Minimum win percentage filter" },
            max_win: { type: "integer", description: "Maximum win percentage filter" },
            regions: { type: "array", items: { type: "string" }, description: "Region column values to filter by (e.g., ['NA - West', 'NA - South']). Use for region-based queries like 'top projects in west region'." },
            title: { type: "string", description: "Project title to filter by. Use LIKE matching for partial title search. Use when user says 'projects under title X', 'title contains X', 'projects titled X', or mentions a specific project name." },
          },
          required: [],
        },
      },

      {
        name: "get_smallest_projects",
        description: "Get smallest/lowest/bottom/cheapest projects by fee. Use for queries like 'bottom projects', 'smallest fee', 'lowest value', 'cheapest projects', 'least expensive'. ORDINAL SUPPORT: For 'second smallest', 'third cheapest', etc., set limit=1 and offset=(N-1).",
        parameters: {
          type: "object",
          properties: {
            limit: { type: "integer", description: "Number of results (use 1 for single project queries)" },
            offset: { type: "integer", description: "Number of results to skip. For ordinal queries: 'second'=1, 'third'=2, 'fourth'=3, etc." },
            time_reference: { type: "string" },
          },
          required: [],
        },
      },

      {
        name: "get_largest_in_region",
        description: "Get largest pursuits in specific region/state. ORDINAL SUPPORT: For 'second largest in CA', set limit=1 and offset=1.",
        parameters: {
          type: "object",
          properties: {
            state_code: { type: "string" },
            limit: { type: "integer", description: "Number of results (use 1 for single project queries)" },
            offset: { type: "integer", description: "Number of results to skip. For ordinal queries: 'second'=1, 'third'=2, etc." },
          },
          required: ["state_code"],
        },
      },

      {
        name: "get_largest_by_category",
        description:
          "Get largest projects in REQUEST CATEGORY field. DO NOT use if user explicitly mentions 'tags'. ORDINAL SUPPORT: For 'second largest in category', set limit=1 and offset=1.",
        parameters: {
          type: "object",
          properties: {
            category: { type: "string" },
            limit: { type: "integer", description: "Number of results (use 1 for single project queries)" },
            offset: { type: "integer", description: "Number of results to skip. For ordinal queries: 'second'=1, 'third'=2, etc." },
          },
          required: ["category"],
        },
      },

      // Category/Type
      {
        name: "get_projects_by_category",
        description: "Get projects by Request Category field. Use for project categories like 'Transportation', 'Healthcare', 'Corporate', 'Education', etc. Use this function when user asks for category/type WITHOUT the word 'tags'. Supports additional filters: fee thresholds, win rate thresholds, status, date range, region/states. If user explicitly mentions 'tags', use get_projects_by_combined_filters instead. Examples: 'Education projects with win rate below 60%' â†’ category='Education', max_win=60. 'Healthcare projects with fee above 5M in West region' â†’ category='Healthcare', min_fee=5000000, states=['California',...]. 'Transportation projects started in 2024' â†’ category='Transportation', start_date='2024-01-01'.",
        parameters: {
          type: "object",
          properties: {
            category: { type: "string", description: "Request Category value (e.g., 'Transportation', 'Healthcare', 'Corporate', 'Education')" },
            min_fee: { type: "number", description: "Minimum fee filter. Use for 'fee above X', 'cost greater than X', 'revenue over X'. Convert millions: '5M' â†’ 5000000." },
            max_fee: { type: "number", description: "Maximum fee filter. Use for 'fee below X', 'cost less than X', 'budget under X'." },
            min_win: { type: "integer", description: "MINIMUM win percentage threshold. Use for 'win rate above X%', 'greater than X%', 'over X%', 'at least X%'." },
            max_win: { type: "integer", description: "MAXIMUM win percentage threshold. Use for 'win rate below X%', 'under X%', 'less than X%'." },
            start_date: { type: "string", description: "Start date filter (YYYY-MM-DD). Use for 'starting after X', 'from X', 'in year X'." },
            end_date: { type: "string", description: "End date filter (YYYY-MM-DD). Use for 'before X', 'until X', 'last N years/months'. For relative time queries, set end_date to today." },
            status: { type: "array", items: { type: "string" }, description: "Project status filter: Won, Lost, Lead, Submitted, In Progress, Proposal Development, Qualified Lead, Hold." },
            states: { type: "array", items: { type: "string" }, description: "Filter by specific state names ONLY when user asks for individual states like California or Texas." },
            region: { type: "string", description: "Region filter for geographic regions like Northeast, West, South, Midwest. Use this to query the Region column directly when user says \"northeast projects\", \"west region\", etc. Do NOT expand to states." },
            company: { type: "string", description: "Company/OPCO filter." },
            limit: { type: "integer", description: "Maximum number of results to return." },
          },
          required: ["category"],
        },
      },

      {
        name: "get_projects_by_project_type",
        description: "Get projects by PROJECT TYPE column (NOT Tags!). Use for: 'project type X', 'project [name]', 'projects under project [name]', 'how many projects are [type]', 'how many [type] projects with fee above X'. CRITICAL: This is the CORRECT function for 'how many projects are under project Higher Education' or 'how many projects are Higher Education type' - use project_type='Higher Education'. Also handles fee/date/win rate/POC filters. This queries the 'Project Type' column (specific types like 'Hospitals', 'Higher Education', 'Bridges', 'Solar'), NOT the 'Tags' column. Examples: 'projects with Hospitals type' â†’ project_type='Hospitals', 'projects under project Higher Education' â†’ project_type='Higher Education', 'how many Higher Education projects with fee above 50M' â†’ project_type='Higher Education', min_fee=50000000, 'K-12 School projects with win rate below 40%' â†’ project_type='K-12 School', max_win=40, 'Healthcare projects handled by John Smith' â†’ project_type='Hospitals', poc='John Smith'. SUPPORTS MULTIPLE TYPES: 'hospitals and pharma' â†’ project_types: ['Hospitals', 'Pharma']. Uses OR logic. SUPPORTS DATE FILTERS: 'starting after 2025' â†’ start_date='2025-01-01', 'before 2024' â†’ end_date='2024-01-01'. SUPPORTS POC FILTER: 'handled by X', 'managed by X', 'contact X' â†’ poc='X'.",
        parameters: {
          type: "object",
          properties: {
            project_type: { type: "string", description: "SINGLE project type from 'Project Type' column. Examples: 'Hospitals', 'Higher Education', 'Bridges', 'Solar', 'Pharma/Life Sciences', 'International Development'. Use 'project_types' array for multiple types." },
            project_types: { type: "array", items: { type: "string" }, description: "ARRAY of project types for multiple. Use when query mentions multiple types: 'hospitals and pharma' â†’ ['Hospitals', 'Pharma']. Uses OR logic." },
            poc: { type: "string", description: "Point of Contact filter. Use for 'handled by X', 'managed by X', 'assigned to X', 'contact X', 'POC X'. Extract the person's name." },
            min_fee: { type: "number", description: "Minimum fee filter. Use for 'fee above X', 'fee greater than X', 'fee over X million'." },
            max_fee: { type: "number", description: "Maximum fee filter. Use for 'fee below X', 'fee less than X', 'fee under X million'." },
            min_win: { type: "integer", description: "MINIMUM win percentage threshold. Use for 'win rate above X%', 'greater than X%'." },
            max_win: { type: "integer", description: "MAXIMUM win percentage threshold. Use for 'win rate below X%', 'under X%', 'less than X%'." },
            start_date: { type: "string", description: "Start date filter (YYYY-MM-DD). Use for 'starting after X', 'from X', 'after year X', 'last N years', 'past N months'. CRITICAL: For relative time like 'last 10 years', calculate start_date = today minus N years. Example: 'last 10 years' (if today is 2026-01-20) â†’ start_date='2016-01-20', end_date='2026-01-20'." },
            end_date: { type: "string", description: "End date filter (YYYY-MM-DD). Use for 'before X', 'until X', 'ending by X'. Example: 'before 2024' â†’ '2024-01-01'." },
            status: { type: "array", items: { type: "string" }, description: "Project status filter: Won, Lost, Lead, Submitted, In Progress, Proposal Development, Qualified Lead, Hold." },
            states: { type: "array", items: { type: "string" }, description: "Filter by specific state names ONLY when user asks for individual states like California or Texas." },
            region: { type: "string", description: "Region filter for geographic regions like Northeast, West, South, Midwest. Use this to query the Region column directly when user says \"northeast projects\", \"west region\", etc. Do NOT expand to states." },
            company: { type: "string", description: "Company/OPCO filter (e.g., 'Company A', 'Company B')." },
            limit: { type: "integer", description: "Maximum number of results to return." },
          },
          required: [],
        },
      },

      {
        name: "get_projects_by_service_type",
        description: "Get projects by SERVICE TYPE column (NOT Project Type!). Use ONLY when user explicitly says 'service type', 'servicetype', or 'service category'. Examples: 'Architecture service type projects' â†’ service_type='Architecture', 'list projects with Healthcare service type' â†’ service_type='Healthcare', 'all service type IT projects' â†’ service_type='IT'. The ServiceType column has values like 'Architecture', 'Healthcare', 'IT', 'Engineering', 'Consulting'. CRITICAL: If user just says 'projects' without 'service type' keyword, do NOT use this function - use get_largest_projects or get_projects_by_category instead. ONLY use when 'service type' or 'servicetype' is explicitly mentioned.",
        parameters: {
          type: "object",
          properties: {
            service_type: { type: "string", description: "Service type value from 'ServiceType' column. Examples: 'Architecture', 'Healthcare', 'IT', 'Engineering', 'Consulting', 'PMO'." },
            min_fee: { type: "number", description: "Minimum fee filter." },
            max_fee: { type: "number", description: "Maximum fee filter." },
            status: { type: "array", items: { type: "string" }, description: "Project status filter: Won, Lost, Lead, Submitted, In Progress." },
            states: { type: "array", items: { type: "string" }, description: "Filter by state names." },
            company: { type: "string", description: "Company/OPCO filter." },
            limit: { type: "integer", description: "Maximum number of results to return." },
          },
          required: [],
        },
      },

      {
        name: "get_projects_by_multiple_categories",
        description: "Get projects in multiple categories",
        parameters: {
          type: "object",
          properties: {
            categories: {
              type: "array",
              items: { type: "string" },
            },
          },
          required: ["categories"],
        },
      },

      // Tags
      {
        name: "get_largest_by_tags",
        description:
          "Get largest/top/biggest projects with specific TAGS. Use when user explicitly mentions 'tags'.",
        parameters: {
          type: "object",
          properties: {
            tag: { type: "string" },
            limit: { type: "integer" },
          },
          required: ["tag"],
        },
      },

      {
        name: "get_projects_by_status_and_win_rate",
        description:
          "Get projects by specific status combined with win percentage threshold. Use when user asks for BOTH status AND win rate percentage. CRITICAL: 'less than X%' or 'under X%' or 'below X%' â†’ use max_win. 'greater than X%' or 'above X%' or 'at least X%' or 'more than X%' â†’ use min_win. Examples: 'Win % less than 100' â†’ max_win=100. 'Win % greater than 50' â†’ min_win=50. 'Win % between 30 and 80' â†’ min_win=30, max_win=80. DO NOT use for time-based queries (e.g., 'next 30 days') - use get_projects_by_combined_filters instead.",
        parameters: {
          type: "object",
          properties: {
            status: { type: "string", description: "Status filter (e.g., 'Won', 'Lost', 'Lead')" },
            min_win: { type: "integer", description: "MINIMUM win percentage threshold. Use for 'greater than', 'above', 'at least', 'more than' patterns. Example: 'Win % > 50' â†’ min_win=50" },
            max_win: { type: "integer", description: "MAXIMUM win percentage threshold. Use for 'less than', 'under', 'below' patterns. Example: 'Win % < 100' â†’ max_win=100" },
          },
          required: ["status"],
        },
      },



      {
        name: "get_top_titles",
        description: "AGGREGATE/GROUP by Title (project name) - gets most frequently used project titles/names. Use for: 'most used titles', 'most common project names', 'most frequent titles', 'which project names appear most', 'popular project names', 'title frequency', 'breakdown by title', 'breakdown by project name', 'most repeated project names', 'provide most used titles'. SORTING: sort_by='project_count' for frequency, 'total_value' for revenue. Supports OPTIONAL FILTERS: client, company, status, state, categories, date range.",
        parameters: {
          type: "object",
          properties: {
            sort_by: { type: "string", enum: ["project_count", "total_value"], description: "Sorting criterion: 'project_count' for frequency, 'total_value' for revenue." },
            client: { type: "string", description: "Optional: Filter by client ID" },
            company: { type: "string", description: "Optional: Filter by company/OPCO" },
            status: { type: "string", description: "Optional: Filter by status" },
            state_code: { type: "string", description: "Optional: Filter by state" },
            categories: { type: "array", items: { type: "string" }, description: "Request Category filter" },
            min_fee: { type: "number", description: "Optional: Minimum fee filter" },
            max_fee: { type: "number", description: "Optional: Maximum fee filter" },
            start_date: { type: "string", description: "Optional: Start date filter" },
            end_date: { type: "string", description: "Optional: End date filter" },
            limit: { type: "integer", description: "Number of titles to return. Only set if user explicitly requests a number (e.g., 'top 5 titles'). Otherwise, omit to return ALL titles sorted by value." },
          },
          required: [],
        },
      },

      {
        name: "select_specific_columns",
        description: "Select specific columns from filtered results. Use when user asks to 'show only X', 'display just Y', 'provide only Z', 'give me the X column', 'want only Y', etc. CRITICAL: Map user terms to column names ('projects'â†’'Project Name', 'tags'â†’'Tags', 'clients'â†’'Client'). Preserves ALL filters from previous context (dates, client, company, status, etc). Examples: 'provide only the projects' â†’ columns: 'Project Name', 'show only tags' â†’ columns: 'Tags', 'want only tags' â†’ columns: 'Tags', 'display fee and client' â†’ columns: 'Fee, Client'.",
        parameters: {
          type: "object",
          properties: {
            columns: { 
              type: "string", 
              description: "Comma-separated exact column names to SELECT. Map user terms: 'projects'/'project names'â†’'Project Name', 'tags'â†’'Tags', 'clients'/'client names'â†’'Client', 'status'â†’'Status', 'fee'/'fees'/'cost'â†’'Fee', 'company'/'companies'â†’'Company', 'contact'/'POC'â†’'Point Of Contact', 'win rate'/'win %'â†’'Win %', 'type'/'project type'â†’'Project Type', 'date'/'start date'â†’'Start Date', 'description'â†’'Description', 'state'â†’'State Lookup', 'category'/'categories'â†’'Request Category', 'id'â†’'Internal Id'" 
            },
            start_date: { type: "string", description: "Optional: Start date filter in YYYY-MM-DD format (preserved from previous context)" },
            end_date: { type: "string", description: "Optional: End date filter in YYYY-MM-DD format (preserved from previous context)" },
            state_code: { type: "string", description: "Optional: State filter (preserved from previous context)" },
            company: { type: "string", description: "Optional: Company/OPCO filter (preserved from previous context)" },
            client: { type: "string", description: "Optional: Client filter (preserved from previous context)" },
            categories: { type: "array", items: { type: "string" }, description: "Request Category filter (ONLY if user explicitly says 'category'). Preserved from context." },
            status: { type: "string", description: "Optional: Status filter (preserved from previous context)" },
            size: { type: "string", description: "Optional: Size filter (preserved from previous context)" },
            min_fee: { type: "number", description: "Optional: Minimum fee filter (preserved from previous context)" },
            max_fee: { type: "number", description: "Optional: Maximum fee filter (preserved from previous context)" },
            min_win: { type: "number", description: "Optional: Minimum win % filter (preserved from previous context)" },
            max_win: { type: "number", description: "Optional: Maximum win % filter (preserved from previous context)" },
            limit: { type: "integer", description: "Optional: Number of results" },
          },
          required: ["columns"],
        },
      },

      // Company/OPCO
      {
        name: "get_company_summary",
        description: "Get aggregated summary/totals for a company/OPCO. Use when user asks for 'sum of fees for company X', 'total fee for Company Y', 'total value', 'how much total', 'aggregate', 'sum', 'total projects for company', 'company summary', or any aggregation query about a specific company. Returns: project count, total fee (sum), average fee, min/max fee, and avg win rate.",
        parameters: {
          type: "object",
          properties: {
            company: { type: "string", description: "Company name (e.g., 'Company A', 'Company G')" },
          },
          required: ["company"],
        },
      },

      {
        name: "get_projects_by_company",
        description: "Get projects by company/OPCO",
        parameters: {
          type: "object",
          properties: {
            company: { type: "string" },
          },
          required: ["company"],
        },
      },

      {
        name: "compare_companies",
        description: "AGGREGATE/GROUP by company - ranks ALL companies (OPCOs) by total revenue, project count, average size, and win rates. Use for: 'which company has most projects', 'which company has most submitted projects', 'top companies by revenue', 'which company contributes most', 'breakdown by company', 'aggregate by company', 'what company has highest total fee', 'revenue by company', 'rank all OPCOs', 'company performance comparison', 'historical win rate for each OPCO', 'win rate by company', 'which OPCO has best win rate'. CRITICAL: User asking 'which company' (without naming specific companies) = aggregation = use THIS function. DO NOT extract company names from previous results. IMPORTANT: When filtering AGGREGATED company results by win rate (e.g., 'which have win rate 40%', 'companies with 50% win rate'), continue using THIS function with min_win/max_win parameters - do NOT switch to individual project queries. Supports OPTIONAL FILTERS: fee ranges (min_fee, max_fee), win rate ranges (min_win, max_win), status (e.g., 'submitted', 'won', 'lead'), date ranges, categories, tags, state. This is an AGGREGATION query, NOT a filter. Returns all companies sorted by revenue.",
        parameters: {
          type: "object",
          properties: {
            limit: { type: "integer", description: "Optional: Number of top companies to return" },
            min_fee: { type: "number", description: "Optional: Minimum fee filter for underlying projects (e.g., 5000000 for $5M)" },
            max_fee: { type: "number", description: "Optional: Maximum fee filter for underlying projects (e.g., 20000000 for $20M)" },
            min_win: { type: "number", description: "Optional: Filter to only companies with avg_win_rate >= this value (0-100)" },
            max_win: { type: "number", description: "Optional: Filter to only companies with avg_win_rate <= this value (0-100)" },
            status: { type: "string", description: "Optional: Filter underlying projects by status (e.g., 'Submitted', 'Won', 'Lead', 'Lost'). ALWAYS extract from keywords like 'submitted projects', 'won projects', 'active projects'" },
            start_date: { type: "string", description: "Optional: Filter underlying projects by start date" },
            end_date: { type: "string", description: "Optional: Filter underlying projects by end date" },
            categories: { type: "array", items: { type: "string" }, description: "Request Category filter (ONLY if user explicitly says 'category'). Preserved from context." },
            tags: { type: "array", items: { type: "string" }, description: "Optional: Filter by tags (preserved from context)" },
          },
          required: [],
        },
      },

      {
        name: "compare_opco_revenue",
        description: "Compare predicted revenue between SPECIFIC companies/OPCOs for active pipeline opportunities (not won/lost). Use when user asks to compare 2+ specific companies like 'compare Company A vs Company B', 'how does OPCO X compare to OPCO Y'.",
        parameters: {
          type: "object",
          properties: {
            companies: {
              type: "array",
              items: { type: "string" },
              description: "Array of company names to compare",
            },
          },
          required: ["companies"],
        },
      },

      // Client
      {
        name: "get_client_summary",
        description: "Get aggregated summary/totals for ONE SPECIFIC client by Client. REQUIRES a specific client ID like 'Client 4885'. Use when user asks for 'sum of fees for Client X', 'total fee for client Y', 'how many projects for Client Z'. Returns: project count, total fee (sum), average fee, min/max fee, and avg win rate. DO NOT use for ranking/comparison queries like 'client with highest number of projects', 'which client has most projects', 'top clients' - use get_top_clients instead for those.",
        parameters: {
          type: "object",
          properties: {
            client: { type: "string", description: "Client ID number or Client (e.g., '4885', 'Client 5057'). NOT for person names." },
          },
          required: ["client"],
        },
      },

      {
        name: "get_projects_by_client",
        description: "Get all projects for a SPECIFIC client by CLIENT ID . Use when asking about 'this client', 'that client', 'Client X projects', 'average for client Y', or 'details about client Z'. Returns ALL projects for the specified client. DO NOT use for person names like 'Amy Wincko' - use get_projects_by_poc for person names instead.",
        parameters: {
          type: "object",
          properties: {
            client: { type: "string", description: "Client ID number or Client (e.g., '4885', 'Client 5057'). NOT for person names." },
          },
          required: ["client"],
        },
      },

      {
        name: "get_projects_by_client_and_fee_range",
        description: "Get projects for CLIENT ID  within fee range. Use for client IDs like 'Client 4885', '5057', etc. DO NOT use for person names - use get_projects_by_poc for person names.",
        parameters: {
          type: "object",
          properties: {
            client: { type: "string", description: "Client ID number or Client (e.g., '4885', 'Client 5057'). NOT for person names." },
            min_fee: { type: "number" },
            max_fee: { type: "number" },
          },
          required: ["client", "min_fee", "max_fee"],
        },
      },

      // Division / Department
      {
        name: "get_projects_by_division",
        description: "Get projects by business unit/division. Use when user asks about 'division projects', 'Engineering division', 'Healthcare division', 'projects in X division'. Returns all projects for the specified division sorted by fee.",
        parameters: {
          type: "object",
          properties: {
            division: { type: "string", description: "Division/business unit name (e.g., 'Engineering', 'Healthcare', 'IT')" },
            status: { type: "string", description: "Optional: Filter by status" },
            limit: { type: "integer", description: "Optional: Number of results" },
          },
          required: ["division"],
        },
      },

      {
        name: "get_projects_by_department",
        description: "Get ALL PROJECTS filtered by ORGANIZATIONAL DEPARTMENT. CRITICAL: Use when user wants to see actual project list/records for a specific department. Keywords: 'civil department projects', 'all projects in department', 'show department projects', 'projects of civil department', 'want all projects of X department', 'list department projects'. This returns individual project records filtered by department name (e.g., Civil & Structural, Engineering, Operations). NOT for breakdowns/summaries - use get_department_breakdown for those.",
        parameters: {
          type: "object",
          properties: {
            department: { type: "string", description: "Department name to filter by (e.g., 'civil', 'structural', 'engineering', 'operations')" },
            status: { type: "string", description: "Optional: Filter by status" },
            limit: { type: "integer", description: "Optional: Number of results" },
          },
          required: ["department"],
        },
      },

      {
        name: "get_division_summary",
        description: "Get aggregated summary/totals for a specific division. Use when user asks 'total fee for X division', 'division summary', 'how much for Engineering division'. Returns project count, total/avg/min/max fee, and avg win rate.",
        parameters: {
          type: "object",
          properties: {
            division: { type: "string", description: "Division name" },
          },
          required: ["division"],
        },
      },

      {
        name: "get_department_summary",
        description: "Get aggregated summary/totals for a specific department. Use when user asks 'total fee for X department', 'department summary', 'how much for Operations department'. Returns project count, total/avg/min/max fee, and avg win rate.",
        parameters: {
          type: "object",
          properties: {
            department: { type: "string", description: "Department name" },
          },
          required: ["department"],
        },
      },

      {
        name: "compare_divisions",
        description: "AGGREGATE/GROUP by division - ranks ALL divisions by total revenue, project count, avg size, and win rates. Use for: 'which division has most projects', 'top divisions by revenue', 'breakdown by division', 'compare divisions', 'division performance', 'revenue by division', 'which division has highest win rate'. CRITICAL: When user mentions SPECIFIC division names to compare (like 'compare Healthcare with Engineering division', 'SCM vs DIAS division'), you MUST extract those division names into the 'divisions' array parameter. Example: 'compare Healthcare division with Engineering' -> divisions: ['Healthcare', 'Engineering']",
        parameters: {
          type: "object",
          properties: {
            divisions: { type: "array", items: { type: "string" }, description: "IMPORTANT: Extract specific division names from user query. For 'compare Healthcare with Engineering division', use ['Healthcare', 'Engineering']. For 'SCM vs DIAS', use ['SCM', 'DIAS']. Always extract the division names mentioned by user." },
            limit: { type: "integer", description: "Optional: Number of top divisions to return" },
            min_fee: { type: "number", description: "Optional: Minimum fee filter" },
            max_fee: { type: "number", description: "Optional: Maximum fee filter" },
            min_win: { type: "number", description: "Optional: Minimum win rate filter (0-100)" },
            max_win: { type: "number", description: "Optional: Maximum win rate filter (0-100)" },
            status: { type: "string", description: "Optional: Filter by status" },
            start_date: { type: "string", description: "Optional: Start date filter" },
            end_date: { type: "string", description: "Optional: End date filter" },
          },
          required: [],
        },
      },

      {
        name: "compare_departments",
        description: "AGGREGATE/GROUP by department - ranks ALL departments by total revenue, project count, avg size, and win rates. Use for: 'which department has most projects', 'top departments by revenue', 'breakdown by department', 'compare departments', 'department performance', 'revenue by department', 'which department has highest win rate'. CRITICAL: When user mentions SPECIFIC department names to compare (like 'compare Environmental with Civil', 'Civil vs Structural department', 'how does Environmental stack up against Civil'), you MUST extract those department names into the 'departments' array parameter. Example: 'compare Environmental with Civil department' -> departments: ['Environmental', 'Civil']",
        parameters: {
          type: "object",
          properties: {
            departments: { type: "array", items: { type: "string" }, description: "IMPORTANT: Extract specific department names from user query. For 'compare Environmental with Civil department', use ['Environmental', 'Civil']. For 'Civil vs Structural', use ['Civil', 'Structural']. Always extract the department names mentioned by user." },
            limit: { type: "integer", description: "Optional: Number of top departments to return" },
            min_fee: { type: "number", description: "Optional: Minimum fee filter" },
            max_fee: { type: "number", description: "Optional: Maximum fee filter" },
            min_win: { type: "number", description: "Optional: Minimum win rate filter (0-100)" },
            max_win: { type: "number", description: "Optional: Maximum win rate filter (0-100)" },
            status: { type: "string", description: "Optional: Filter by status" },
            start_date: { type: "string", description: "Optional: Start date filter" },
            end_date: { type: "string", description: "Optional: End date filter" },
          },
          required: [],
        },
      },

      {
        name: "get_division_breakdown",
        description: "AGGREGATE/GROUP by division with optional filters - shows project count and total value per division. Use for: 'division breakdown', 'projects by division', 'how many projects per division', 'Healthcare projects by division', 'show by division'. SUPPORTS ALL FILTERS: categories, min_fee, max_fee, status, client, company, date range.",
        parameters: {
          type: "object",
          properties: {
            categories: { type: "array", items: { type: "string" }, description: "Optional: Filter by request category (e.g., ['Healthcare'])" },
            min_fee: { type: "number", description: "Optional: Minimum fee filter (e.g., 10000000 for $10M+)" },
            max_fee: { type: "number", description: "Optional: Maximum fee filter" },
            status: { type: "string", description: "Optional: Filter by status" },
            client: { type: "string", description: "Optional: Filter by client name" },
            company: { type: "string", description: "Optional: Filter by company" },
            state_code: { type: "string", description: "Optional: Filter by state" },
            start_date: { type: "string", description: "Optional: Start date filter" },
            end_date: { type: "string", description: "Optional: End date filter" },
          },
          required: [],
        },
      },

      {
        name: "get_department_breakdown",
        description: "AGGREGATE/GROUP by ORGANIZATIONAL DEPARTMENT with optional filters - shows project count and total value per department. Use when user asks about 'department', 'departments', 'department breakdown', 'department totals', 'projects per department', 'Healthcare projects by department'. SUPPORTS ALL FILTERS: categories, min_fee, max_fee, status, client, company, date range. Keywords: department, departments, dept.",
        parameters: {
          type: "object",
          properties: {
            department: { type: "string", description: "Optional: Filter by specific department name" },
            categories: { type: "array", items: { type: "string" }, description: "Optional: Filter by request category (e.g., ['Healthcare'])" },
            min_fee: { type: "number", description: "Optional: Minimum fee filter (e.g., 10000000 for $10M+)" },
            max_fee: { type: "number", description: "Optional: Maximum fee filter" },
            status: { type: "string", description: "Optional: Filter by status" },
            client: { type: "string", description: "Optional: Filter by client name" },
            company: { type: "string", description: "Optional: Filter by company" },
            state_code: { type: "string", description: "Optional: Filter by state" },
            start_date: { type: "string", description: "Optional: Start date filter" },
            end_date: { type: "string", description: "Optional: End date filter" },
          },
          required: [],
        },
      },

      {
        name: "get_revenue_by_division",
        description: "AGGREGATE/GROUP by division with optional filters - shows revenue, project count, avg fee, and win rate per division. Use for: 'breakdown by division', 'show by division', 'revenue by division', 'total fees per division', 'which division generates most revenue', 'Healthcare projects by division', 'projects over $10M by division'. SUPPORTS ALL FILTERS: categories, min_fee, max_fee, status, client, company, date range, etc.",
        parameters: {
          type: "object",
          properties: {
            categories: { type: "array", items: { type: "string" }, description: "Optional: Filter by request category (e.g., ['Healthcare', 'Transportation'])" },
            min_fee: { type: "number", description: "Optional: Minimum fee filter (e.g., 10000000 for $10M+)" },
            max_fee: { type: "number", description: "Optional: Maximum fee filter" },
            status: { type: "string", description: "Optional: Filter by status (e.g., 'Won', 'Active')" },
            client: { type: "string", description: "Optional: Filter by client name" },
            company: { type: "string", description: "Optional: Filter by company" },
            state_code: { type: "string", description: "Optional: Filter by state" },
            start_date: { type: "string", description: "Optional: Start date (YYYY-MM-DD)" },
            end_date: { type: "string", description: "Optional: End date (YYYY-MM-DD)" },
            limit: { type: "integer", description: "Optional: Number of divisions to return" },
          },
          required: [],
        },
      },

      {
        name: "get_revenue_by_department",
        description: "AGGREGATE/GROUP by department with optional filters - shows revenue, project count, avg fee, and win rate per department. Use for: 'breakdown by department', 'show by department', 'revenue by department', 'total fees per department', 'which department generates most revenue', 'Healthcare projects by department', 'projects over $10M by department'. SUPPORTS ALL FILTERS: categories, min_fee, max_fee, status, client, company, date range, etc.",
        parameters: {
          type: "object",
          properties: {
            categories: { type: "array", items: { type: "string" }, description: "Optional: Filter by request category (e.g., ['Healthcare', 'Transportation'])" },
            min_fee: { type: "number", description: "Optional: Minimum fee filter (e.g., 10000000 for $10M+)" },
            max_fee: { type: "number", description: "Optional: Maximum fee filter" },
            status: { type: "string", description: "Optional: Filter by status (e.g., 'Won', 'Active')" },
            client: { type: "string", description: "Optional: Filter by client name" },
            company: { type: "string", description: "Optional: Filter by company" },
            state_code: { type: "string", description: "Optional: Filter by state" },
            start_date: { type: "string", description: "Optional: Start date (YYYY-MM-DD)" },
            end_date: { type: "string", description: "Optional: End date (YYYY-MM-DD)" },
            limit: { type: "integer", description: "Optional: Number of departments to return" },
          },
          required: [],
        },
      },

      {
        name: "get_department_fee_trend",
        description: "TREND ANALYSIS: Compare department average fees across YEARS to identify declining or growing fee patterns. Use for: 'departments with declining fees', 'department fee trend', 'departments where fees are declining', 'compare department fees over time', 'year over year department comparison', 'which departments are losing fee value', 'fee trend by department', 'department performance over years'. Returns each department with yearly breakdown of avg_fee, project_count, and total_revenue. Only includes year/department combinations with 3+ projects for statistical significance.",
        parameters: {
          type: "object",
          properties: {
            department: { type: "string", description: "Optional: Filter to a specific department" },
            division: { type: "string", description: "Optional: Filter by division" },
            status: { type: "string", description: "Optional: Filter by status (e.g., 'Won')" },
            categories: { type: "array", items: { type: "string" }, description: "Optional: Filter by request category" },
          },
          required: [],
        },
      },

      {
        name: "get_division_fee_trend",
        description: "TREND ANALYSIS: Compare division average fees across YEARS to identify declining or growing fee patterns. Use for: 'divisions with declining fees', 'division fee trend', 'divisions where fees are declining', 'compare division fees over time', 'year over year division comparison', 'which divisions are losing fee value', 'fee trend by division', 'division performance over years'. Returns each division with yearly breakdown of avg_fee, project_count, and total_revenue. Only includes year/division combinations with 3+ projects for statistical significance.",
        parameters: {
          type: "object",
          properties: {
            division: { type: "string", description: "Optional: Filter to a specific division" },
            department: { type: "string", description: "Optional: Filter by department" },
            status: { type: "string", description: "Optional: Filter by status (e.g., 'Won')" },
            categories: { type: "array", items: { type: "string" }, description: "Optional: Filter by request category" },
          },
          required: [],
        },
      },

      {
        name: "get_fee_extremes",
        description: "FEE OUTLIERS: Find projects with unusually large fee differences by showing the highest and lowest fee projects. Use for: 'pair of projects where fee difference is large', 'fee outliers', 'projects with unusual fees', 'highest and lowest fee projects', 'fee extremes', 'largest fee difference', 'compare highest vs lowest fee', 'projects with extreme fees'. Returns highest fee project(s) and lowest fee project(s) to show the fee gap. Supports filtering by department, division, category, status, and time period.",
        parameters: {
          type: "object",
          properties: {
            department: { type: "string", description: "Optional: Filter to a specific department" },
            division: { type: "string", description: "Optional: Filter by division" },
            status: { type: "string", description: "Optional: Filter by status (e.g., 'Won')" },
            categories: { type: "array", items: { type: "string" }, description: "Optional: Filter by request category" },
            start_date: { type: "string", description: "Optional: Start date filter" },
            end_date: { type: "string", description: "Optional: End date filter" },
            limit: { type: "integer", description: "Optional: Number of top/bottom projects to return (default 3 each)" },
          },
          required: [],
        },
      },

      {
        name: "get_fee_variance_by_scope",
        description: "FEE VARIANCE BY SCOPE: Find projects with similar scope/category but significantly different fees. Use for: 'nearly identical scope but different fees', 'similar projects different fees', 'fee variance within category', 'projects with same type but different pricing', 'outliers within same category', 'fee inconsistencies', 'pricing anomalies'. Returns projects where fee is >2x or <0.5x the category average, with fee_variance_status (SIGNIFICANTLY_ABOVE/SIGNIFICANTLY_BELOW).",
        parameters: {
          type: "object",
          properties: {
            department: { type: "string", description: "Optional: Filter to a specific department" },
            division: { type: "string", description: "Optional: Filter by division" },
            status: { type: "string", description: "Optional: Filter by status (e.g., 'Won')" },
            categories: { type: "array", items: { type: "string" }, description: "Optional: Filter by request category" },
            start_date: { type: "string", description: "Optional: Start date filter" },
            end_date: { type: "string", description: "Optional: End date filter" },
          },
          required: [],
        },
      },

      {
        name: "get_fee_percentile",
        description: "FEE PERCENTILE: Find projects within a specific percentile threshold. Use for: 'top 15 percent by fee', 'projects in top X percentile', 'bottom Y percent of fees'. Returns projects with fee_bracket label and percentile_rank.",
        parameters: {
          type: "object",
          properties: {
            percentile_threshold: { type: "number", description: "Percentile threshold (0.10 for top 10%, 0.20 for top 20%, etc.)" },
            limit: { type: "integer", description: "Optional: Maximum number of projects to return" },
            department: { type: "string", description: "Optional: Filter to a specific department" },
            division: { type: "string", description: "Optional: Filter by division" },
            status: { type: "string", description: "Optional: Filter by status" },
            start_date: { type: "string", description: "Optional: Start date filter" },
            end_date: { type: "string", description: "Optional: End date filter" },
          },
          required: ["percentile_threshold"],
        },
      },

      {
        name: "get_top_fee_bracket",
        description: "TOP FEE BRACKET: Find projects in the top 10% by fee value. Use for: 'top 10% fee bracket', 'highest fee tier', 'top percentile projects', 'top decile by fee', 'premium fee projects'. Returns projects with fee_bracket label.",
        parameters: {
          type: "object",
          properties: {
            department: { type: "string", description: "Optional: Filter to a specific department" },
            division: { type: "string", description: "Optional: Filter by division" },
            status: { type: "string", description: "Optional: Filter by status" },
            start_date: { type: "string", description: "Optional: Start date filter" },
            end_date: { type: "string", description: "Optional: End date filter" },
          },
          required: [],
        },
      },

      {
        name: "get_bottom_fee_bracket",
        description: "BOTTOM FEE BRACKET: Find projects in the bottom 20% by fee value. Use for: 'bottom 20% of total revenue', 'lowest fee tier', 'bottom percentile projects', 'bottom quintile by fee', 'low-fee projects for review'. Returns projects contributing least to revenue.",
        parameters: {
          type: "object",
          properties: {
            department: { type: "string", description: "Optional: Filter to a specific department" },
            division: { type: "string", description: "Optional: Filter by division" },
            status: { type: "string", description: "Optional: Filter by status" },
            start_date: { type: "string", description: "Optional: Start date filter" },
            end_date: { type: "string", description: "Optional: End date filter" },
          },
          required: [],
        },
      },

      {
        name: "get_top_vs_bottom_fee_comparison",
        description: "TOP VS BOTTOM FEE COMPARISON: Compare average fee of top 5 projects with bottom 5 projects. Use for: 'compare average fee of top 5 with bottom 5', 'top vs bottom fee comparison', 'highest vs lowest fee averages', 'fee gap between top and bottom'. Returns both groups with group_name label.",
        parameters: {
          type: "object",
          properties: {
            department: { type: "string", description: "Optional: Filter to a specific department" },
            division: { type: "string", description: "Optional: Filter by division" },
            status: { type: "string", description: "Optional: Filter by status" },
            start_date: { type: "string", description: "Optional: Start date filter" },
            end_date: { type: "string", description: "Optional: End date filter" },
          },
          required: [],
        },
      },

      {
        name: "get_revenue_concentration",
        description: "REVENUE CONCENTRATION: Show what percentage of total revenue comes from top projects. Use for: 'revenue concentration', 'does one project dominate revenue', 'percentage of total revenue by top three', 'cumulative revenue contribution', 'revenue risk concentration', 'how much do top projects contribute'. Returns cumulative_pct and individual_pct for each project.",
        parameters: {
          type: "object",
          properties: {
            department: { type: "string", description: "Optional: Filter to a specific department" },
            division: { type: "string", description: "Optional: Filter by division" },
            status: { type: "string", description: "Optional: Filter by status" },
            start_date: { type: "string", description: "Optional: Start date filter" },
            end_date: { type: "string", description: "Optional: End date filter" },
          },
          required: [],
        },
      },

      {
        name: "get_projects_vs_median",
        description: "MEDIAN FEE COMPARISON: Show projects classified as ABOVE_MEDIAN or BELOW_MEDIAN. Use for: 'above or below median fee', 'median fee comparison', 'projects priced above/below median', 'more projects above or below median'. Returns overall_median_fee and median_classification.",
        parameters: {
          type: "object",
          properties: {
            department: { type: "string", description: "Optional: Filter to a specific department" },
            division: { type: "string", description: "Optional: Filter by division" },
            status: { type: "string", description: "Optional: Filter by status" },
            start_date: { type: "string", description: "Optional: Start date filter" },
            end_date: { type: "string", description: "Optional: End date filter" },
          },
          required: [],
        },
      },

      {
        name: "get_fee_distribution_stats",
        description: "FEE DISTRIBUTION STATISTICS: Get comprehensive fee statistics including skewness direction and variance. Use for: 'how evenly distributed are fees', 'are project fees skewed toward higher or lower values', 'fee distribution analysis', 'fee spread statistics', 'fee variance analysis', 'variance of projects', 'project variance', 'statistical variance'. Returns min, max, avg, median, quartiles, std_dev, variance, and skew_direction.",
        parameters: {
          type: "object",
          properties: {
            categories: { type: "array", items: { type: "string" }, description: "Optional: Filter by project categories (e.g., 'Healthcare', 'Education')" },
            department: { type: "string", description: "Optional: Filter to a specific department" },
            division: { type: "string", description: "Optional: Filter by division" },
            status: { type: "string", description: "Optional: Filter by status" },
            client: { type: "string", description: "Optional: Filter by client name" },
            state_code: { type: "string", description: "Optional: Filter by state code" },
            start_date: { type: "string", description: "Optional: Start date filter" },
            end_date: { type: "string", description: "Optional: End date filter" },
          },
          required: [],
        },
      },

      {
        name: "get_fee_clustering",
        description: "FEE CLUSTERING: Group projects by fee ranges to show distribution. Use for: 'fee clustering around price points', 'fee distribution by range', 'how are fees distributed across ranges', 'fee buckets', 'pricing tiers breakdown'. Returns project_count per fee_range.",
        parameters: {
          type: "object",
          properties: {
            department: { type: "string", description: "Optional: Filter to a specific department" },
            division: { type: "string", description: "Optional: Filter by division" },
            status: { type: "string", description: "Optional: Filter by status" },
            start_date: { type: "string", description: "Optional: Start date filter" },
            end_date: { type: "string", description: "Optional: End date filter" },
          },
          required: [],
        },
      },

      {
        name: "get_project_closest_to_average",
        description: "PROJECT CLOSEST TO AVERAGE: Find the project(s) with fee closest to the overall average. Use for: 'fee closest to average', 'project at the average fee', 'most typical fee project', 'representative project by fee'. Returns projects sorted by deviation_from_avg (smallest first).",
        parameters: {
          type: "object",
          properties: {
            department: { type: "string", description: "Optional: Filter to a specific department" },
            division: { type: "string", description: "Optional: Filter by division" },
            status: { type: "string", description: "Optional: Filter by status" },
            start_date: { type: "string", description: "Optional: Start date filter" },
            end_date: { type: "string", description: "Optional: End date filter" },
          },
          required: [],
        },
      },

      {
        name: "get_middle_fee_project",
        description: "MIDDLE FEE PROJECT: Find the project that sits exactly between highest and lowest fee. Use for: 'project between highest and lowest fee', 'midpoint fee project', 'project at the middle fee point', 'fee midpoint'. Returns projects with distance_from_midpoint.",
        parameters: {
          type: "object",
          properties: {
            department: { type: "string", description: "Optional: Filter to a specific department" },
            division: { type: "string", description: "Optional: Filter by division" },
            status: { type: "string", description: "Optional: Filter by status" },
            start_date: { type: "string", description: "Optional: Start date filter" },
            end_date: { type: "string", description: "Optional: End date filter" },
          },
          required: [],
        },
      },

      {
        name: "get_projects_vs_average",
        description: "AVERAGE COMPARISON: Show projects classified as ABOVE_AVERAGE or BELOW_AVERAGE relative to the overall average fee. Use for: 'average project fee', 'projects above average', 'projects below average', 'which projects fall above and below average', 'compare to average fee', 'projects vs average', 'above or below the mean'. Returns projects with their fee_classification (ABOVE_AVERAGE/BELOW_AVERAGE) and the overall_avg_fee for reference.",
        parameters: {
          type: "object",
          properties: {
            department: { type: "string", description: "Optional: Filter to a specific department" },
            division: { type: "string", description: "Optional: Filter by division" },
            status: { type: "string", description: "Optional: Filter by status (e.g., 'Won')" },
            categories: { type: "array", items: { type: "string" }, description: "Optional: Filter by request category" },
            start_date: { type: "string", description: "Optional: Start date filter" },
            end_date: { type: "string", description: "Optional: End date filter" },
          },
          required: [],
        },
      },

      // Status
      {
        name: "get_projects_by_status",
        description: "Get INDIVIDUAL PROJECTS/DEALS filtered by status (won/lost/submitted/lead/completed/finished) and/or other attributes like is_updated. Returns projects sorted by fee (highest first). Use this for questions like 'top won projects', 'highest value lost projects', 'show me won projects', 'largest submitted projects by fee', 'completed projects', 'finished projects', 'projects which are updated', 'deals that are won', 'won deals', 'successfully won'. TERMINOLOGY: 'deals' = projects, 'successfully'/'won successfully' = status Won. Supports OPTIONAL FILTERS: status, client, company, state, categories, tags, fee ranges, date range, is_updated. Use start_date for time-based queries like 'last 90 days', 'this year', 'since January 2024'. Note: 'completed', 'finished', 'successfully' are automatically mapped to 'Won' status. Status is optional - you can query by is_updated alone.",
        parameters: {
          type: "object",
          properties: {
            status: { type: "string", description: "Optional: Project status: Won, Lost, Lead, Submitted, In Progress, Proposal Development, Qualified Lead, Hold. Also accepts: completed, finished (mapped to Won)" },
            limit: { type: "integer", description: "Optional: Maximum number of results to return" },
            start_date: { type: "string", description: "Optional: Filter by projects starting after this date. Accepts natural language like 'last 90 days', 'this year', 'since Jan 2024' or ISO dates like '2024-01-01'" },
            end_date: { type: "string", description: "Optional: Filter by projects starting before this date. ISO format YYYY-MM-DD" },
            client: { type: "string", description: "Optional: Filter by client ID" },
            company: { type: "string", description: "Optional: Filter by company/OPCO" },
            state_code: { type: "string", description: "Optional: Filter by state" },
            is_updated: { type: "string", description: "Optional: Filter by updated status. Use '1' for updated projects, '' (empty string) for non-updated projects. Extract from queries like 'projects which are updated', 'updated projects', 'show updated items'." },
          },
          required: [],
        },
      },

      {
        name: "get_status_breakdown",
        description: "Get AGGREGATED breakdown/analysis by status - GROUPS projects by status and shows totals. Use for: 'group by status', 'group projects by status', 'breakdown by status', 'which status has most projects', 'which status contributes most revenue', 'aggregate by status', 'total fees by status', 'what status has highest total', 'revenue by status', 'categorize by status'. Supports OPTIONAL FILTERS: client, company, state, categories, date range. This is an AGGREGATION query, NOT a filter.",
        parameters: {
          type: "object",
          properties: {
            client: { type: "string", description: "Optional: Filter by client ID" },
            company: { type: "string", description: "Optional: Filter by company/OPCO" },
            state_code: { type: "string", description: "Optional: Filter by state" },
            categories: { type: "array", items: { type: "string" }, description: "Request Category filter" },
            min_fee: { type: "number", description: "Optional: Minimum fee filter" },
            max_fee: { type: "number", description: "Optional: Maximum fee filter" },
            start_date: { type: "string", description: "Optional: Start date filter" },
            end_date: { type: "string", description: "Optional: End date filter" },
          },
          required: [],
        },
      },

      {
        name: "get_module_breakdown",
        description: "Get AGGREGATED breakdown/analysis by MODULE (source/pipeline stage) - GROUPS projects by ModuleName and shows totals. Use for: 'summarize contract value across Opportunities, Tracked Work, and Construction', 'breakdown by module', 'group by source', 'aggregate by module', 'total fees by module', 'contract value for Opportunities and Tracked Work', 'compare modules', 'which module has most projects'. IMPORTANT: When user mentions 'Opportunities', 'Tracked Work', 'Construction' as categories/buckets, these are MODULE values (ModuleName column). Supports OPTIONAL FILTERS: modules (array of specific modules to include), client, company, state, categories, date range. This is an AGGREGATION query, NOT a filter.",
        parameters: {
          type: "object",
          properties: {
            modules: { type: "array", items: { type: "string" }, description: "Optional: Array of specific modules to include in breakdown. Use when user mentions specific modules like 'Opportunities', 'Tracked Work', 'Construction', etc." },
            client: { type: "string", description: "Optional: Filter by client ID" },
            company: { type: "string", description: "Optional: Filter by company/OPCO" },
            state_code: { type: "string", description: "Optional: Filter by state" },
            categories: { type: "array", items: { type: "string" }, description: "Request Category filter" },
            min_fee: { type: "number", description: "Optional: Minimum fee filter" },
            max_fee: { type: "number", description: "Optional: Maximum fee filter" },
            start_date: { type: "string", description: "Optional: Start date filter" },
            end_date: { type: "string", description: "Optional: End date filter" },
          },
          required: [],
        },
      },

      {
        name: "get_overoptimistic_losses",
        description:
          "Get LOST projects where win percentage was above 70%. ONLY use when user specifically asks about 'overoptimistic losses'.",
        parameters: {
          type: "object",
          properties: {},
          required: [],
        },
      },

      {
        name: "get_top_predicted_wins",
        description: "Get projects predicted to win (highest win percentage). **ALWAYS use this for win-intent queries** even if fee ranges mentioned. Keywords: 'likely to win', 'probably win', 'predicted wins', 'win probability', 'highest win %', 'may win', 'which will win'. Supports BOTH win filtering AND fee ranges (min_fee/max_fee) simultaneously. Temporal filtering: extract natural language dates like 'in next 18 months', 'Q1 2025' as start_date/end_date which will be automatically parsed server-side. Returns ALL matching projects by default (no limit) unless user specifies a number.",
        parameters: {
          type: "object",
          properties: {
            limit: { type: "integer", description: "Number of projects to return (optional, defaults to all matching projects)" },
            min_fee: { type: "number", description: "Minimum fee filter (optional, in dollars)" },
            max_fee: { type: "number", description: "Maximum fee filter (optional, in dollars)" },
            start_date: { type: "string", description: "Start date filter: accepts YYYY-MM-DD OR natural language like 'in next 18 months', 'Q1 2025' (automatically parsed)" },
            end_date: { type: "string", description: "End date in YYYY-MM-DD format (optional if start_date is natural language)" },
          },
          required: [],
        },
      },

      // Win Rate
      {
        name: "get_project_win_rate",
        description: "Get win rate for specific project",
        parameters: {
          type: "object",
          properties: {
            project_name: { type: "string" },
          },
          required: ["project_name"],
        },
      },

      {
        name: "get_projects_by_win_range",
        description: "Get projects with win percentage above threshold (and optionally below max). Use for queries like 'win rate more than X', 'win rate at least X', 'win rate between X and Y'.",
        parameters: {
          type: "object",
          properties: {
            min_win: { type: "integer", description: "Minimum win percentage (required)" },
            max_win: { type: "integer", description: "Maximum win percentage (optional)" },
          },
          required: ["min_win"],
        },
      },

      {
        name: "get_projects_by_category_and_win_range",
        description: "Get projects in specific category with win percentage above threshold. Use when user asks for category AND win rate together.",
        parameters: {
          type: "object",
          properties: {
            category: { type: "string" },
            min_win: { type: "integer" },
            max_win: { type: "integer", description: "Optional maximum win percentage" },
          },
          required: ["category", "min_win"],
        },
      },

      {
        name: "get_projects_by_client_status_win_range",
        description: "Get projects for specific CLIENT or Client (Client ID) with status and win percentage range. Use when user asks for Client (like 'Client 1573'), status, AND win rate range. Use 'client' parameter for Client.",
        parameters: {
          type: "object",
          properties: {
            client: { type: "string", description: "Client name or Client (e.g., 'Client 1573')" },
            status: { type: "string" },
            min_win: { type: "integer" },
            max_win: { type: "integer" },
          },
          required: ["client", "status", "min_win", "max_win"],
        },
      },

      {
        name: "get_clients_by_highest_win_rate",
        description: "RANK ALL clients by their average win rate to COMPARE them. Use ONLY when asking 'which clients have highest win rate' or 'rank clients by win probability'. DO NOT use for asking about a SPECIFIC client's win rate - use get_projects_by_client for that.",
        parameters: {
          type: "object",
          properties: {},
          required: [],
        },
      },

      {
        name: "get_top_projects_by_win_rate",
        description: "RANKING/SORTING QUERY: Get projects RANKED/SORTED BY win percentage/win rate from highest to lowest. ALWAYS use this when user asks to 'list', 'show', 'top', 'rank', or 'sort' projects BY win percentage/rate. Supports optional date filters. Examples: 'list top 20 projects by win percentage', 'show highest win rate projects', 'projects sorted by win %', 'rank by win rate', 'best win percentage', 'top 10 by win rate'.",
        parameters: {
          type: "object",
          properties: {
            start_date: { type: "string", description: "Optional start date filter (YYYY-MM-DD)" },
            end_date: { type: "string", description: "Optional end date filter (YYYY-MM-DD)" },
            limit: { type: "integer", description: "Number of results to return (default 20)" },
          },
          required: [],
        },
      },

      {
        name: "get_clients_by_status_count",
        description: "Aggregate CLIENTS (not individual projects) by status to show which clients have the MOST/LEAST projects of that status. Returns CLIENT names grouped by project count. Use ONLY for client-level aggregation like 'which clients won/lost MOST projects', 'top clients by win count'. DO NOT EVER use for: (1) individual project queries like 'top won projects' - use get_projects_by_status instead, (2) TIME/YEAR-based queries like 'which year had most wins' or 'identify year with highest wins' - use compare_years instead, (3) any grouping by time period, quarter, month, or year, (4) ANY temporal queries with 'started/began/launched/initiated' referring to Start Date - these ALWAYS use get_top_clients with start_date/end_date filters instead, (5) ANY queries mentioning 'win%' or 'win rate' or '0 win%' - these ALWAYS use get_top_clients with min_win/max_win filters instead. CRITICAL: 'Started' is NOT a valid Status value in the database - valid statuses are: 'Won', 'Lost', 'Lead', 'Submitted', 'In Progress', 'Proposal Development', 'Qualified Lead', 'Hold'. Queries about 'which clients started most projects' must use get_top_clients with date filters, NOT this function. Queries about 'clients with X win%' must use get_top_clients with win filters, NOT this function.",
        parameters: {
          type: "object",
          properties: {
            status: { type: "string", description: "Project status field value: MUST be one of: 'Won', 'Lost', 'Lead', 'Submitted', 'In Progress', 'Proposal Development', 'Qualified Lead', 'Hold'. NEVER use 'Started' - that's a temporal reference, not a status!" },
            limit: { type: "integer", description: "Number of clients to return. Only set if user explicitly requests a number. Otherwise omit." },
          },
          required: ["status"],
        },
      },

      // Region
      {
        name: "get_projects_by_state",
        description: "Get projects in specific state/region",
        parameters: {
          type: "object",
          properties: {
            state_code: { type: "string" },
          },
          required: ["state_code"],
        },
      },

      // Fee/Size
      {
        name: "get_projects_by_fee_range",
        description: "Get projects within fee range. Use ONLY when user explicitly mentions FEE/COST/VALUE amounts like 'fees > @p1M', 'projects costing between', 'fee range $500K-$2M'. DO NOT use for status-only queries like 'status is submitted' - use get_projects_by_status instead. DO NOT use for win probability language - use get_top_predicted_wins instead. Requires at least min_fee or max_fee or exact_fee to be specified. Supports date filters: extract temporal phrases as start_date/end_date which will be automatically parsed server-side. IMPORTANT: For 'last X projects' or 'bottom X', set sort_direction='ASC' to get LOWEST fees. For 'top X' or 'first X', use sort_direction='DESC' (default) to get HIGHEST fees.",
        parameters: {
          type: "object",
          properties: {
            exact_fee: { type: "number", description: "EXACT fee amount for 'equal to X', 'exactly X', 'fee is X', 'fee = X' queries. When set, this overrides min_fee/max_fee. Use this for EXACT MATCH queries like 'fee equal to 0', 'fee exactly $1M', 'projects with $0 fee'." },
            min_fee: { type: "number", description: "Minimum fee in dollars (required unless max_fee or exact_fee provided). Use for 'greater than X', 'at least X', 'more than X' queries." },
            max_fee: { type: "number", description: "Maximum fee in dollars (required unless min_fee or exact_fee provided). Use for 'less than X', 'at most X', 'under X' queries." },
            start_date: { type: "string", description: "Start date filter: accepts YYYY-MM-DD OR natural language like 'next 6 months', 'Q1 2025' (automatically parsed)" },
            end_date: { type: "string", description: "End date in YYYY-MM-DD format (optional if start_date is natural language)" },
            limit: { type: "integer", description: "Number of results to return (e.g., 'last 5' = 5, 'top 10' = 10)" },
            sort_direction: { type: "string", enum: ["ASC", "DESC"], description: "Sort order: 'ASC' for 'last/bottom/lowest X' (ascending=lowest first), 'DESC' for 'top/first/highest X' (descending=highest first). Default is DESC." },
          },
          required: [],
        },
      },

      {
        name: "get_projects_by_size",
        description:
          "Get projects by DYNAMIC size category calculated from percentiles. Size: 'Micro', 'Small', 'Medium', 'Large', or 'Mega'.",
        parameters: {
          type: "object",
          properties: {
            size: {
              type: "string",
              description: "Size category: 'Micro', 'Small', 'Medium', 'Large', or 'Mega'",
            },
          },
          required: ["size"],
        },
      },

      {
        name: "get_size_distribution",
        description:
          "Get distribution of projects by DYNAMIC size tiers calculated from actual fee percentiles.",
        parameters: {
          type: "object",
          properties: {},
          required: [],
        },
      },

      // Revenue Aggregation
      {
        name: "get_revenue_by_category",
        description:
          "Get total revenue aggregated by category. Use when user asks 'total revenue in X', 'value of X projects'.",
        parameters: {
          type: "object",
          properties: {
            category: { type: "string" },
            status: { type: "string", description: "Optional: filter by status" },
          },
          required: ["category"],
        },
      },

      // What-If Projections
      {
        name: "get_weighted_revenue_projection",
        description:
          "Get weighted revenue projections (Fee Ã— Win %) based on win probability. Use for 'weighted value', 'expected value', 'predicted revenue', 'what if'. Supports filtering by status and grouping by different columns.",
        parameters: {
          type: "object",
          properties: {
            status: { 
              anyOf: [
                { type: "string" },
                { type: "array", items: { type: "string" } }
              ],
              description: "Filter by status - can be single value or array. Examples: 'Qualified Lead', ['Qualified Lead', 'Submitted']" 
            },
            group_by: { 
              type: "string", 
              description: "Column to group results by. Options: 'status' (default), 'category' (Request Category), 'company', 'client', 'poc' (Point of Contact). Use 'category' when user asks for breakdown by category/request category." 
            },
            categories: { type: "array", items: { type: "string" }, description: "Request Category filter (ONLY if user explicitly says 'category'). For 'type' queries, use project_type instead." },
            min_fee: { type: "number", description: "Minimum fee filter" },
            max_fee: { type: "number", description: "Maximum fee filter" },
          },
          required: [],
        },
      },

      // Year Comparisons
      {
        name: "compare_years",
        description: "Compare project performance across multiple years OR identify the best/worst year OR group/aggregate projects by year. Use for: 'compare 2025 vs 2026', 'year over year', 'which year had the most wins', 'identify the year with highest number of project wins', 'what year was best', 'top performing year', 'year with most projects', 'group all projects by start year', 'group by year', 'projects by start year', 'breakdown by year', 'yearly breakdown', 'annual summary'. If no specific years mentioned, analyzes ALL years. Returns aggregated counts and revenue by year with won_count column.",
        parameters: {
          type: "object",
          properties: {
            year1: { type: "integer", description: "First year to compare (optional - if omitted, shows all years)" },
            year2: { type: "integer", description: "Second year to compare (optional)" },
            status: { type: "string", description: "Filter by status (e.g., 'Won') - optional" },
            limit: { type: "integer", description: "Limit results (optional)" },
          },
          required: [],
        },
      },

      // POC (Point of Contact)
      {
        name: "get_top_pocs",
        description: "AGGREGATE/GROUP by POC (Point of Contact) - ranks top performing project managers/POCs/contacts/sales reps by total value, project count, or win rate. Use for: 'best POCs', 'top project managers', 'who handles most projects', 'which POC contributes most', 'breakdown by POC', 'aggregate by POC', 'what POC has highest total', 'revenue by POC', 'which contact generates most', 'which poc has highest revenue', 'poc with most revenue', 'contact with highest revenue', 'sales rep with maximum projects', 'top sales reps', 'best sales rep', 'which sales rep has most'. TERMINOLOGY: 'contact' = 'POC' = 'sales rep' = Point of Contact. Supports OPTIONAL FILTERS: client, company, status, state, categories, date range. This is an AGGREGATION query, NOT a filter.",
        parameters: {
          type: "object",
          properties: {
            client: { type: "string", description: "Optional: Filter by client ID" },
            company: { type: "string", description: "Optional: Filter by company/OPCO" },
            status: { type: "string", description: "Optional: Filter by status" },
            state_code: { type: "string", description: "Optional: Filter by state" },
            categories: { type: "array", items: { type: "string" }, description: "Request Category filter (ONLY if user explicitly says 'category'). For 'type' queries, use project_type instead." },
            min_fee: { type: "number", description: "Optional: Minimum fee filter" },
            max_fee: { type: "number", description: "Optional: Maximum fee filter" },
            start_date: { type: "string", description: "Optional: Start date filter" },
            end_date: { type: "string", description: "Optional: End date filter" },
            limit: { type: "integer", description: "Number of POCs to return" },
          },
          required: [],
        },
      },

      {
        name: "get_projects_by_poc",
        description: "Get all projects managed by specific Point of Contact/POC/project manager/contact/sales rep - USE FOR PERSON NAMES ONLY. TERMINOLOGY: 'contact X' = 'POC X' = 'sales rep X' = Point of Contact X. Examples: 'Amy Wincko', 'Michael Luciani', 'Bryan Benso', 'Irene Chan'. When user says 'projects with Amy Wincko', 'contact Bryan Benso', 'handled by contact Irene Chan', 'managed by contact X', 'sales rep X projects', use THIS function. SUPPORTS MULTIPLE POCs: 'projects with Amy Wincko and Alex' â†’ pocs: ['Amy Wincko', 'Alex']. Supports optional filters like fee ranges, dates, status, categories, project_type, etc. DO NOT use for client IDs or company names.",
        parameters: {
          type: "object",
          properties: {
            poc: { type: "string", description: "SINGLE person's full name (e.g., 'Amy Wincko'). Use 'pocs' array for multiple people." },
            pocs: { type: "array", items: { type: "string" }, description: "ARRAY of person names for multiple POCs. Use when query mentions multiple people: 'Amy Wincko and Alex' â†’ ['Amy Wincko', 'Alex']. Uses OR logic (projects with ANY of these POCs)." },
            min_fee: { type: "number", description: "Minimum fee amount (optional)" },
            max_fee: { type: "number", description: "Maximum fee amount (optional)" },
            size: { type: "string", description: "Size filter (optional)" },
            status: { type: "string", description: "Status filter (optional)" },
            start_date: { type: "string", description: "Start date filter (optional)" },
            end_date: { type: "string", description: "End date filter (optional)" },
          },
          required: [],
        },
      },

      {
        name: "compare_pocs",
        description: "AGGREGATE/GROUP by POC - compares performance metrics between two specific Points of Contact/POCs/project managers. Use for: 'compare Amy and John', 'which POC contributes more', 'breakdown by these POCs', 'what POC has higher total'. This is an AGGREGATION query, NOT a filter.",
        parameters: {
          type: "object",
          properties: {
            poc1: { type: "string", description: "Name of the first Point of Contact/POC" },
            poc2: { type: "string", description: "Name of the second Point of Contact/POC" },
          },
          required: ["poc1", "poc2"],
        },
      },

      {
        name: "get_projects_with_same_attribute",
        description: "Find all projects that share the same attribute value(s) as a reference project, with optional exclusion filters. CRITICAL RULE: The 'attribute' parameter defines what to MATCH, exclusion parameters define what to EXCLUDE - these must be DIFFERENT attributes. Use for: (1) 'similar to PID X' queries, (2) 'same [attribute] as PID X', (3) 'similar but different [attribute]', (4) 'like PID X but not in same [attribute]', (5) 'POSITIONAL/SUPERLATIVE project queries'. REFERENCE PROJECT KEYWORDS: POSITIONAL (ordered by Start Date): 'first project', 'second project', 'third project', '1st project', '2nd project', '10th project' â†’ use exact text (system finds Nth project by chronological order). SUPERLATIVE (ordered by Fee): 'largest project', 'top project', 'biggest project', 'highest fee project' â†’ use exact text (system finds project with highest fee). EXCLUSION EXAMPLES: 'similar to PID 10 but different category' â†’ {reference_pid:'PID 10', attribute:'tags', exclude_category:true} [NOTE: matches by tags, excludes category], 'similar to PID 10 from other request categories' â†’ {reference_pid:'PID 10', attribute:'tags', exclude_category:true}, 'like PID 5 but not same client' â†’ {reference_pid:'PID 5', attribute:'tags', exclude_client:true}. MATCHING EXAMPLES: 'same point of contact as PID 7' â†’ {reference_pid:'PID 7', attribute:'poc'}, 'similar to PID 8 (same category and tags)' â†’ {reference_pid:'PID 8', attribute:'category,tags'}, 'get projects related to the first project by tags' â†’ {reference_pid:'first project', attribute:'tags'}, 'take the second project and find similar ones' â†’ {reference_pid:'second project', attribute:'tags'}, 'largest project and find similar' â†’ {reference_pid:'largest project', attribute:'tags'}. This two-step function: (1) looks up reference project by PID/position/superlative, (2) finds matching projects while excluding specified fields.",
        parameters: {
          type: "object",
          properties: {
            reference_pid: { type: "string", description: "The Project ID (PID) or project name to use as reference. POSITIONAL (by Start Date): 'first project', 'second project', 'third project', '1st project', '2nd project', '5th project', '10th project' (gets Nth project chronologically). SUPERLATIVE (by Fee): 'largest project', 'top project', 'biggest project', 'highest fee' (gets highest-fee project). PID: 'PID 10', '10', 'Project ABC'" },
            attribute: { type: "string", description: "Which attribute(s) to MATCH. IMPORTANT: Do NOT include attributes that are being excluded (e.g., if exclude_category=true, do NOT include 'category' in this field). For 'similar' queries without specific attributes, use 'tags'. For specific attributes: 'poc' (Point of Contact), 'category' (Request Category), 'client' (Client ID), 'status' (Status), 'company' (Company/OPCO), 'tags' (Tags). Multi-attribute: comma-separated like 'client,status' or 'category,tags'" },
            exclude_category: { type: "boolean", description: "Set to true when query says 'different category', 'not same category', 'but only those in a different category', 'except same category', 'from other categories', 'from other request categories', or 'in other categories'. Excludes projects in same category as reference. CRITICAL: If true, do NOT include 'category' in the 'attribute' field." },
            exclude_status: { type: "boolean", description: "Set to true when query says 'different status', 'not same status', 'but different status'. Excludes projects with same status as reference. CRITICAL: If true, do NOT include 'status' in the 'attribute' field." },
            exclude_client: { type: "boolean", description: "Set to true when query says 'different client', 'not same client', 'but different client'. Excludes projects from same client as reference. CRITICAL: If true, do NOT include 'client' in the 'attribute' field." },
            min_fee: { type: "number", description: "Minimum fee filter (optional)" },
            max_fee: { type: "number", description: "Maximum fee filter (optional)" },
            start_date: { type: "string", description: "Start date filter (optional)" },
            end_date: { type: "string", description: "End date filter (optional)" },
          },
          required: ["reference_pid", "attribute"],
        },
      },

      // Description Search
      {
        name: "search_description",
        description: "Search for projects by keyword in project description. Use when user wants to find projects 'mentioning', 'containing', 'about', 'related to', 'describing', or 'involving' specific topics. CRITICAL: Use this for domain-specific keywords that are NOT category/type names, such as: 'municipal', 'airport', 'airports', 'medical', 'energy', 'solar', 'water', 'bridge', 'facility', 'facilities', 'building', 'buildings', 'renovation', 'construction', 'pavement', 'road', 'highway'. Also use for phrases like 'appear to be municipal jobs', 'related to airports', 'medical buildings', 'buildings or facilities'. Extract the core keywords from the question.",
        parameters: {
          type: "object",
          properties: {
            keyword: { type: "string", description: "Keyword or phrase to search for in descriptions. For compound phrases like 'medical buildings', search for 'medical'. For 'related to airports', search for 'airport'." },
          },
          required: ["keyword"],
        },
      },

      // Month-based Queries
      {
        name: "get_projects_by_month",
        description: "Get projects starting in specific month. Use when user asks for 'January projects', 'March 2024', etc.",
        parameters: {
          type: "object",
          properties: {
            year: { type: "integer", description: "Year (e.g., 2024)" },
            month: { type: "integer", description: "Month number 1-12 (1=Jan, 12=Dec)" },
          },
          required: ["year", "month"],
        },
      },

      {
        name: "get_revenue_by_month",
        description: "Get monthly revenue breakdown for a specific year. Use for 'monthly revenue', 'revenue by month', 'monthly trends'.",
        parameters: {
          type: "object",
          properties: {
            year: { type: "integer", description: "Year to analyze" },
          },
          required: ["year"],
        },
      },

      // Trend Analysis
      {
        name: "get_yoy_growth",
        description: "Calculate year-over-year growth between two years. Use for 'YoY growth', 'compare 2023 vs 2024', 'year over year'.",
        parameters: {
          type: "object",
          properties: {
            year1: { type: "integer", description: "First year (earlier)" },
            year2: { type: "integer", description: "Second year (later)" },
          },
          required: ["year1", "year2"],
        },
      },

      // Regional Analysis
      {
        name: "get_revenue_by_state",
        description: "Get revenue breakdown by state/region. Use for 'revenue by state', 'regional performance', 'market share by geography'.",
        parameters: {
          type: "object",
          properties: {
            limit: { type: "integer", description: "Number of states to return" },
          },
          required: [],
        },
      },

      // Client Analysis
      {
        name: "get_repeat_clients",
        description: "Get clients with multiple projects (repeat customers). Use for 'repeat clients', 'returning customers', 'client loyalty'.",
        parameters: {
          type: "object",
          properties: {
            limit: { type: "integer", description: "Number of clients to return" },
          },
          required: [],
        },
      },

      // Risk Analysis
      {
        name: "get_high_risk_opportunities",
        description: "Find high-value projects with low win rates (risky opportunities). Use for 'high risk', 'risky projects', 'low confidence high value'.",
        parameters: {
          type: "object",
          properties: {
            min_fee: { type: "number", description: "Minimum project value to consider" },
            max_win: { type: "integer", description: "Maximum win percentage (low confidence threshold)" },
            limit: { type: "integer", description: "Number of projects to return" },
          },
          required: ["min_fee", "max_win"],
        },
      },

      // Project Type Analysis
      {
        name: "get_project_type_breakdown",
        description: "AGGREGATE/GROUP by PROJECT TYPE column (NOT Tags!) - Shows count/frequency of each project type. Use for: 'most repeated project type', 'most common project type', 'project type breakdown', 'which project type has most projects', 'project types by count', 'how many of each project type'. IMPORTANT: This queries the 'Project Type' column (e.g., 'Hospitals', 'Bridges', 'Higher Education', 'Solar') - NOT the 'Tags' column. For tag queries, use get_top_tags instead. Returns: project_type, project_count, total_revenue, avg_fee, avg_win_rate. Supports OPTIONAL FILTERS: categories (Request Category), client, company, status, state, date range. Use limit=1 for 'the most repeated' (singular) or omit for full breakdown.",
        parameters: {
          type: "object",
          properties: {
            limit: { type: "integer", description: "Number of results to return. Use 1 for 'the most repeated/common' (singular), omit for full breakdown" },
            categories: { type: "array", items: { type: "string" }, description: "Request Category filter (ONLY if user explicitly says 'category'). For 'type' queries, use project_type instead." },
            client: { type: "string", description: "Optional: Filter by client ID" },
            company: { type: "string", description: "Optional: Filter by company/OPCO" },
            status: { type: "string", description: "Optional: Filter by status" },
            state_code: { type: "string", description: "Optional: Filter by state" },
            min_fee: { type: "number", description: "Optional: Minimum fee filter" },
            max_fee: { type: "number", description: "Optional: Maximum fee filter" },
            start_date: { type: "string", description: "Optional: Start date filter" },
            end_date: { type: "string", description: "Optional: End date filter" },
          },
          required: [],
        },
      },

      {
        name: "get_revenue_by_project_type",
        description: "AGGREGATE/GROUP by project type - Shows TOTAL AGGREGATED revenue per project type (sum of all projects). Use ONLY for: 'which TYPE contributes most TOTAL revenue', 'revenue breakdown by type', 'what type has highest TOTAL', 'aggregate by project type', 'which types are most profitable OVERALL'. DO NOT use for: 'which project type has highest fee' (use get_largest_projects instead - returns single project with highest fee). Returns aggregated SUM metrics per type. IMPORTANT: When question asks for 'which has highest total' (singular), use limit=1 to return only the top result. For 'breakdown' or 'all types' return all results (no limit). Supports OPTIONAL FILTERS: client, company, status, state, categories, date range, limit. This is an AGGREGATION query, NOT a filter for individual projects.",
        parameters: {
          type: "object",
          properties: {
            limit: { type: "integer", description: "Number of results to return. Use 1 when question asks 'which has highest total' (singular), omit for full breakdown" },
            client: { type: "string", description: "Optional: Filter by client ID (e.g., 'Client 3908')" },
            company: { type: "string", description: "Optional: Filter by company/OPCO" },
            status: { type: "string", description: "Optional: Filter by status (Won, Lost, Submitted, etc.)" },
            state_code: { type: "string", description: "Optional: Filter by state" },
            categories: { type: "array", items: { type: "string" }, description: "Request Category filter (ONLY if user explicitly says 'category'). For 'type' queries, use project_type instead." },
            min_fee: { type: "number", description: "Optional: Minimum fee filter" },
            max_fee: { type: "number", description: "Optional: Maximum fee filter" },
            start_date: { type: "string", description: "Optional: Start date filter" },
            end_date: { type: "string", description: "Optional: End date filter" },
          },
          required: [],
        },
      },

      {
        name: "get_project_type_yoy_growth",
        description: "IF QUERY ASKS FOR 'INCREASE' OR 'GROWTH', SET show_only_increases=true. IF QUERY ASKS FOR 'DECREASE' OR 'DECLINE', SET show_only_decreases=true. Example: 'which project types saw an increase' â†’ {\"show_only_increases\": true}, 'types that declined' â†’ {\"show_only_decreases\": true}. Year-over-year comparison of project types - Shows which project types have INCREASED or DECREASED in number of projects compared to previous year. Use for: 'which project types saw an increase compared to last year', 'project types with growth year over year', 'types with more projects than previous year', 'year-over-year project type trends', 'types that grew/declined'. Returns project_type, year, project_count, prev_year_count, count_change, growth_pct. Defaults to comparing current year vs previous year (dynamically calculated at runtime). Supports OPTIONAL FILTERS: client, company, status, state, categories, fee ranges. This is a TREND ANALYSIS query with LAG window function.",
        parameters: {
          type: "object",
          properties: {
            year1: { type: "integer", description: "Optional: First/earlier year to compare. Can provide alone (will compare to year1+1) or with year2. Defaults to previous year (dynamically calculated) if neither provided." },
            year2: { type: "integer", description: "Optional: Second/target year to compare. Can provide alone (will compare to year2-1) or with year1. Defaults to current year (dynamically calculated) if neither provided." },
            show_only_increases: { type: "boolean", description: "Optional: Set to true to show only project types that increased (positive growth). Omit to show all types." },
            show_only_decreases: { type: "boolean", description: "Optional: Set to true to show only project types that decreased (negative growth). Omit to show all types." },
            client: { type: "string", description: "Optional: Filter by client ID" },
            company: { type: "string", description: "Optional: Filter by company/OPCO" },
            status: { type: "string", description: "Optional: Filter by status" },
            state_code: { type: "string", description: "Optional: Filter by state" },
            categories: { type: "array", items: { type: "string" }, description: "Request Category filter (ONLY if user explicitly says 'category'). For 'type' queries, use project_type instead." },
            min_fee: { type: "number", description: "Optional: Minimum fee filter" },
            max_fee: { type: "number", description: "Optional: Maximum fee filter" },
            limit: { type: "integer", description: "Optional: Number of results to return" },
          },
          required: [],
        },
      },

      // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
      // PHASE 1: HIGH-VALUE COMPARISONS
      // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

      {
        name: "compare_states",
        description: "AGGREGATE/GROUP by STATE (individual states) - compares performance metrics between 2 or more specific states OR ranks ALL states by project count. Use for: 'compare CA and TX', 'which state contributes most', 'in which state was this project type most executed', 'breakdown by state', 'breakdown by state lookup', 'aggregate by state', 'aggregate these states', 'what state has highest total', 'revenue by state'. If user provides specific states, use the 'states' array. If asking 'which state' or 'what state', leave states empty to rank ALL states. Supports OPTIONAL FILTERS: project_type, client, company, status, categories, date range. This is an AGGREGATION query, NOT a filter. NOTE: For 'breakdown by region' (West/Midwest/South/Northeast), use compare_regions instead.",
        parameters: {
          type: "object",
          properties: {
            states: {
              type: "array",
              items: { type: "string" },
              description: "Optional: List of specific state codes to compare (e.g., ['CA', 'TX', 'FL']). Leave empty to rank ALL states.",
            },
            project_type: { type: "string", description: "Optional: Filter by project type (e.g., 'Hospitals', 'Schools')" },
            client: { type: "string", description: "Optional: Filter by client ID (e.g., 'Client 3908')" },
            company: { type: "string", description: "Optional: Filter by company/OPCO" },
            status: { type: "string", description: "Optional: Filter by status" },
            categories: { type: "array", items: { type: "string" }, description: "Request Category filter (ONLY if user explicitly says 'category'). For 'type' queries, use project_type instead." },
            start_date: { type: "string", description: "Optional: Start date filter" },
            end_date: { type: "string", description: "Optional: End date filter" },
          },
          required: [],
        },
      },

      {
        name: "compare_regions",
        description: "AGGREGATE/GROUP by REGION (West, Midwest, South, Northeast) - groups projects by US geographic region and shows aggregate metrics. Use for: 'breakdown by region', 'break down by region', 'aggregate by region', 'by region', 'projects per region', 'which region has most'. Maps states to 4 regions: West (AK, AZ, CA, CO, HI, ID, MT, NV, NM, OR, UT, WA, WY), Midwest (IL, IN, IA, KS, MI, MN, MO, NE, ND, OH, SD, WI), South (AL, AR, DE, FL, GA, KY, LA, MD, MS, NC, OK, SC, TN, TX, VA, WV), Northeast (CT, ME, MA, NH, NJ, NY, PA, RI, VT). Supports OPTIONAL FILTERS: project_type, client, company, status, categories, date range. NOTE: For individual state breakdown, use compare_states instead.",
        parameters: {
          type: "object",
          properties: {
            project_type: { type: "string", description: "Optional: Filter by project type (e.g., 'Hospitals', 'Schools')" },
            client: { type: "string", description: "Optional: Filter by client ID (e.g., 'Client 3908')" },
            company: { type: "string", description: "Optional: Filter by company/OPCO" },
            status: { type: "string", description: "Optional: Filter by status" },
            categories: { type: "array", items: { type: "string" }, description: "Request Category filter (ONLY if user explicitly says 'category'). For 'type' queries, use project_type instead." },
            start_date: { type: "string", description: "Optional: Start date filter" },
            end_date: { type: "string", description: "Optional: End date filter" },
          },
          required: [],
        },
      },

      {
        name: "get_category_breakdown",
        description: "Get aggregated statistics for request categories. Use when user asks: 'for each category', 'by category', 'breakdown by category', 'projects per category', 'number of projects by category', 'category summary', 'all categories', 'how many projects in each category', 'category with most projects', 'highest number of projects', 'categories with win rate above X', 'categories where win percentage greater than X'. Returns: category name, project count, total fee, avg fee, avg win rate, won count, lost count - sorted by project count. IMPORTANT: For singular queries like 'the highest', 'the top category', 'which category has most', set limit=1. For 'all categories', 'each category', 'for every category', 'list all', omit limit to return all.",
        parameters: {
          type: "object",
          properties: {
            min_win: { type: "number", description: "Minimum average win rate % to filter categories (e.g., 50 for categories with avg win rate >= 50%)" },
            max_win: { type: "number", description: "Maximum average win rate % to filter categories" },
            limit: { type: "integer", description: "CRITICAL: Set limit=1 for SINGULAR queries like 'the highest', 'the top', 'which category has most/highest'. Omit limit for plural queries like 'for each category', 'all categories', 'every category'." },
          },
          required: [],
        },
      },

      {
        name: "compare_categories",
        description: "AGGREGATE/GROUP by category - gets aggregated statistics for one or more SPECIFIC request categories. Use for: 'average win rate for Transportation category', 'average win% for projects categorized as X', 'statistics for Design category', 'summary for Construction', 'compare Design and Construction', 'which category contributes most', 'how many projects in Transportation category', 'fee/revenue for X category'. CRITICAL: Use this when user mentions a SPECIFIC category name (like 'Transportation', 'Design', 'Construction', etc.) and wants summary statistics. Returns: project count, total fee, avg fee, avg win rate, won count, lost count per category. For ALL categories without specifying names, use get_category_breakdown instead.",
        parameters: {
          type: "object",
          properties: {
            categories: {
              type: "array",
              items: { type: "string" },
              description: "List of categories to get statistics for (can be 1 or more categories)",
            },
          },
          required: ["categories"],
        },
      },

      {
        name: "get_top_clients",
        description: "PRIMARY TEMPLATE FOR CLIENT RANKING/AGGREGATION. Use for: 'client with highest number of projects', 'which client has most projects', 'top clients', 'client with most projects', 'rank clients by project count', 'which clients contribute most', 'breakdown by client'. SINGULAR QUERIES: For 'THE client with highest/most' set limit=1 and sort_by='project_count'. For NUMBER thresholds: 'more than X projects' â†’ min_project_count=X+1, 'at least X projects' â†’ min_project_count=X. SORTING: sort_by='won_count' for WON PROJECTS emphasis ('won more projects', 'won most projects', 'has won more', 'won the most'), sort_by='project_count' for COUNT emphasis ('most projects', 'highest project count'), sort_by='total_value' for REVENUE emphasis ('top revenue', 'most valuable'). WIN% FILTERING: min_win/max_win filter projects BEFORE aggregation. Supports filters: project_type, status, state, company, categories, dates, fees, win%, min_project_count, limit. DO NOT use for: 'which client has highest fee' (use get_largest_projects). Returns ALL clients unless limit specified.",
        parameters: {
          type: "object",
          properties: {
            sort_by: { type: "string", enum: ["project_count", "total_value", "won_count"], description: "Sorting criterion: 'won_count' for queries about WON PROJECTS ('won more projects', 'won most projects', 'has won more', 'won the most', 'which client has won'), 'project_count' for queries about NUMBER/COUNT of projects ('most projects', 'highest project count', 'most new projects', 'started most'), 'total_value' for queries about REVENUE/VALUE ('top revenue', 'highest value', 'most valuable', 'best clients by fees'). Default is 'total_value' if omitted." },
            min_project_count: { type: "integer", description: "CRITICAL for project count thresholds. Minimum number of projects a client must have (HAVING clause). ALWAYS extract from phrases like: 'more than X projects' â†’ X+1, 'at least X projects' â†’ X, 'X or more projects' â†’ X. Examples: 'more than 10 projects' â†’ 11, 'at least 5 projects' â†’ 5, 'clients with 15+ projects' â†’ 15" },
            limit: { type: "integer", description: "Number of clients to return. Only set if user EXPLICITLY requests a specific number (e.g., 'top 5 clients', 'show 10 clients'). Otherwise, omit to return ALL clients." },
            project_type: { type: "string", description: "Optional: Filter by project type (e.g., 'Hospitals', 'Schools')" },
            start_date: { type: "string", description: "Date filter: accepts both YYYY-MM-DD format OR natural language like 'last 6 months', 'past year', 'Q1 2024' which will be automatically parsed server-side" },
            end_date: { type: "string", description: "End date in YYYY-MM-DD format (optional, not needed if start_date is natural language)" },
            status: { type: "string", description: "Optional: Filter by status" },
            state_code: { type: "string", description: "Optional: Filter by state" },
            company: { type: "string", description: "Optional: Filter by company/OPCO" },
            categories: { type: "array", items: { type: "string" }, description: "Request Category filter (ONLY if user explicitly says 'category'). For 'type' queries, use project_type instead." },
            min_fee: { type: "number", description: "Optional: Minimum fee filter applied BEFORE aggregation" },
            max_fee: { type: "number", description: "Optional: Maximum fee filter applied BEFORE aggregation" },
            min_win: { type: "number", description: "Optional: Minimum win% filter applied BEFORE aggregation. Use with max_win for exact win% (e.g., 0% â†’ min_win=0, max_win=0)" },
            max_win: { type: "number", description: "Optional: Maximum win% filter applied BEFORE aggregation. Use with min_win for exact win% (e.g., 0% â†’ min_win=0, max_win=0)" },
          },
          required: [],
        },
      },

      {
        name: "compare_clients",
        description: "Compare performance metrics between 2 or more SPECIFIC clients (requires explicit client names/Clients). Use ONLY when user provides specific client identifiers to compare side-by-side. Examples: 'compare Client 1573 and Client 3907', 'compare Client A vs Client B'. CRITICAL: DO NOT use for ranking ALL clients - use get_top_clients instead. DO NOT reuse client names from previous results - only extract when user explicitly names them with 'vs', 'versus', 'and', or 'compare X and Y'. This is for SPECIFIC client comparison (2+ named clients), NOT general ranking ('which client', 'top clients').",
        parameters: {
          type: "object",
          properties: {
            clients: {
              type: "array",
              items: { type: "string" },
              description: "List of specific clients to compare (must have at least 2 client names or Clients explicitly mentioned by user)",
            },
          },
          required: ["clients"],
        },
      },

      {
        name: "compare_quarters",
        description: "Compare two specific quarters (e.g., Q1 2024 vs Q1 2023, or Q4 2024 vs Q3 2024). Use when user wants quarter-over-quarter comparison.",
        parameters: {
          type: "object",
          properties: {
            year1: { type: "integer", description: "First quarter's year" },
            quarter1: { type: "integer", description: "First quarter (1-4)" },
            year2: { type: "integer", description: "Second quarter's year" },
            quarter2: { type: "integer", description: "Second quarter (1-4)" },
          },
          required: ["year1", "quarter1", "year2", "quarter2"],
        },
      },

      {
        name: "compare_months_across_years",
        description: "Compare the same month across different years (e.g., December 2023 vs December 2024). Use when user wants month-over-month year-over-year comparison.",
        parameters: {
          type: "object",
          properties: {
            month: { type: "integer", description: "Month number (1-12)" },
            years: {
              type: "array",
              items: { type: "integer" },
              description: "List of years to compare",
            },
          },
          required: ["month", "years"],
        },
      },

      {
        name: "get_companies_by_geographic_diversity",
        description: "Rank ALL companies by geographic reach (number of different states they operate in). Use when user asks: 'which companies work across most states', 'companies in highest number of states', 'most geographically diverse companies', 'companies working across different State Lookup values', 'companies with most geographic diversity'. Returns companies ordered by COUNT(DISTINCT states). DO NOT use for specific state filtering or comparing specific companies.",
        parameters: {
          type: "object",
          properties: {
            limit: { type: "integer", description: "Number of companies to return. Only set if user explicitly requests a number. Otherwise omit to return all companies." },
          },
          required: [],
        },
      },

      {
        name: "compare_to_average",
        description: "Compare a specific entity (company, state, category, or POC) to the overall average. Use when user asks 'how does X compare to average?', 'is X above/below average?'.",
        parameters: {
          type: "object",
          properties: {
            dimension: {
              type: "string",
              enum: ["company",
          "client",
          "organization", "state", "category", "poc"],
              description: "What dimension to compare (company, state, category, or poc)",
            },
            value: { type: "string", description: "The specific value to compare (e.g., 'CA', 'Design', 'Michael Luciani')" },
          },
          required: ["dimension", "value"],
        },
      },

      {
        name: "rank_all_pocs",
        description: "Get complete ranking/leaderboard of all POCs by performance. Use when user asks for 'POC rankings', 'leaderboard', 'who are the top POCs', 'rank all project managers'.",
        parameters: {
          type: "object",
          properties: {
            limit: { type: "integer", description: "Maximum number of POCs to return (optional)" },
          },
          required: [],
        },
      },

      {
        name: "get_state_performance_ranking",
        description: "Get complete ranking of all states by performance. Use when user asks for 'state rankings', 'which states perform best', 'rank states by revenue'.",
        parameters: {
          type: "object",
          properties: {
            limit: { type: "integer", description: "Maximum number of states to return (optional)" },
          },
          required: [],
        },
      },

      {
        name: "get_client_lifetime_value",
        description: "Get total lifetime value of clients including first/last project dates, relationship duration. Use when user asks about 'client lifetime value', 'total value per client', 'client history'.",
        parameters: {
          type: "object",
          properties: {
            limit: { type: "integer", description: "Maximum number of clients to return (optional)" },
          },
          required: [],
        },
      },

      {
        name: "get_client_win_rate_by_type",
        description: "Segment clients into Enterprise/Mid-Market/Small tiers and show win rates by tier. Use when user asks about 'client segmentation', 'win rates by client size', 'enterprise vs small clients'.",
        parameters: {
          type: "object",
          properties: {},
          required: [],
        },
      },

      {
        name: "get_poc_efficiency",
        description: "Calculate revenue per project for each POC (efficiency metric). Use when user asks about 'POC efficiency', 'revenue per project by POC', 'most efficient project managers'.",
        parameters: {
          type: "object",
          properties: {
            limit: { type: "integer", description: "Maximum number of POCs to return (optional)" },
          },
          required: [],
        },
      },

      {
        name: "get_poc_win_rate_trend",
        description: "Show how a specific POC's win rate has changed over time by quarter. Use when user asks about 'POC performance over time', 'is X improving?', 'POC trend analysis'.",
        parameters: {
          type: "object",
          properties: {
            poc: { type: "string", description: "Name of the Point of Contact" },
          },
          required: ["poc"],
        },
      },

      {
        name: "get_top_bottom_performers",
        description: "Identify top 5 and bottom 5 performing POCs. Use when user asks about 'best and worst performers', 'who's struggling', 'star performers and underperformers'.",
        parameters: {
          type: "object",
          properties: {},
          required: [],
        },
      },

      {
        name: "get_category_by_state_matrix",
        description: "Multi-dimensional analysis showing how each category performs in each state. Use when user asks about 'category performance by state', 'which categories work best in which states', 'geographic category analysis'.",
        parameters: {
          type: "object",
          properties: {
            limit: { type: "integer", description: "Maximum number of results (optional)" },
          },
          required: [],
        },
      },

      {
        name: "get_status_by_category_matrix",
        description: "Multi-dimensional analysis showing status distribution within each category. Use when user asks about 'win rates by category', 'how each category is performing', 'category conversion rates'.",
        parameters: {
          type: "object",
          properties: {},
          required: [],
        },
      },

      // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
      // PHASE 2: TREND & FORECASTING
      // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

      {
        name: "get_quarterly_trends",
        description: "Show quarterly revenue trends with quarter-over-quarter growth rates. Use when user asks about 'quarterly trends', 'QoQ growth', 'quarter performance over time'.",
        parameters: {
          type: "object",
          properties: {
            limit: { type: "integer", description: "Number of quarters to show (optional)" },
          },
          required: [],
        },
      },

      {
        name: "get_best_worst_quarters",
        description: "Identify the top 3 peak quarters and bottom 3 trough quarters by revenue. Use when user asks about 'best/worst quarters', 'strongest/weakest quarters', 'peak performance periods'.",
        parameters: {
          type: "object",
          properties: {},
          required: [],
        },
      },

      {
        name: "get_monthly_momentum",
        description: "Show month-over-month trends with acceleration/deceleration indicators (Accelerating, Decelerating, Growing, Declining, Stable). Use when user asks about 'monthly momentum', 'are we accelerating?', 'monthly trends'.",
        parameters: {
          type: "object",
          properties: {
            limit: { type: "integer", description: "Number of months to show (optional)" },
          },
          required: [],
        },
      },

      {
        name: "get_seasonal_patterns",
        description: "Analyze seasonal patterns by showing average performance for each month across all years. Use when user asks about 'seasonality', 'which months are best', 'seasonal trends', 'Q4 spike'.",
        parameters: {
          type: "object",
          properties: {},
          required: [],
        },
      },

      {
        name: "get_revenue_trend_by_category",
        description: "Show revenue trend over time for a specific category with growth rates. Use when user asks about 'category growth over time', 'how is Design trending', 'category performance trend'.",
        parameters: {
          type: "object",
          properties: {
            category: { type: "string", description: "Request Category to analyze" },
          },
          required: ["category"],
        },
      },

      {
        name: "get_revenue_trend_by_state",
        description: "Show revenue trend over time for a specific state with growth rates. Use when user asks about 'state growth over time', 'how is CA trending', 'geographic expansion trend'.",
        parameters: {
          type: "object",
          properties: {
            state_code: { type: "string", description: "State code to analyze (e.g., 'CA', 'TX')" },
          },
          required: ["state_code"],
        },
      },

      {
        name: "get_revenue_trend_by_client",
        description: "Show revenue trend over time for a specific client with growth indicators. Use when user asks about 'client growth over time', 'is this client growing?', 'client relationship trend'.",
        parameters: {
          type: "object",
          properties: {
            client: { type: "string", description: "Client name or Client" },
          },
          required: ["client"],
        },
      },

      {
        name: "get_pipeline_velocity",
        description: "Calculate average time projects spend in pipeline by status. Use when user asks about 'pipeline velocity', 'deal cycle time', 'how long until close', 'time in pipeline'.",
        parameters: {
          type: "object",
          properties: {},
          required: [],
        },
      },

      {
        name: "get_conversion_rate_trend",
        description: "Show win rate trends over time by quarter with changes. Use when user asks about 'conversion rate trends', 'is our win rate improving?', 'win rate over time'.",
        parameters: {
          type: "object",
          properties: {
            limit: { type: "integer", description: "Number of quarters to show (optional)" },
          },
          required: [],
        },
      },

      {
        name: "get_deal_cycle_analysis",
        description: "Analyze average deal cycle duration by deal size and category. Use when user asks about 'deal cycle by size', 'how long do large deals take?', 'cycle time analysis'.",
        parameters: {
          type: "object",
          properties: {},
          required: [],
        },
      },

      {
        name: "get_pipeline_coverage",
        description: "Calculate total pipeline value, weighted pipeline value, and coverage metrics. Use when user asks about 'pipeline coverage', 'pipeline value', 'what's in the pipeline?'.",
        parameters: {
          type: "object",
          properties: {},
          required: [],
        },
      },

      {
        name: "get_pipeline_quality",
        description: "Segment pipeline into High/Medium/Low probability tiers based on win percentage. Use when user asks about 'pipeline quality', 'how strong is our pipeline?', 'probability distribution'.",
        parameters: {
          type: "object",
          properties: {},
          required: [],
        },
      },

      // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
      // PHASE 3: CLIENT INTELLIGENCE & PHASE 4: RISK/PERFORMANCE
      // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

      {
        name: "get_clients_by_value_tier",
        description: "Segment clients into Platinum/Gold/Silver/Bronze tiers by total value. Use when user asks about 'top clients', 'client tiers', 'client segmentation', 'VIP clients'.",
        parameters: {
          type: "object",
          properties: {
            limit: { type: "integer", description: "Maximum number of clients to return (optional)" },
          },
          required: [],
        },
      },

      {
        name: "get_client_retention_rate",
        description: "Analyze client retention by categorizing into Long-Term (5+ years), Established (3-4 years), Repeat (2 years), or One-Time clients. Use when user asks about 'client retention', 'how loyal are clients?', 'repeat business'.",
        parameters: {
          type: "object",
          properties: {},
          required: [],
        },
      },

      {
        name: "get_dormant_clients",
        description: "Identify clients who haven't had projects in 1+ years but have lifetime value. Use when user asks about 'dormant clients', 'inactive clients', 'clients we lost', 'win-back opportunities'.",
        parameters: {
          type: "object",
          properties: {
            limit: { type: "integer", description: "Maximum number of clients to return (optional)" },
          },
          required: [],
        },
      },

      {
        name: "get_at_risk_clients",
        description: "Identify clients showing declining activity (fewer projects this year vs last year, or long inactivity). Use when user asks about 'at-risk clients', 'clients we might lose', 'declining clients'.",
        parameters: {
          type: "object",
          properties: {
            limit: { type: "integer", description: "Maximum number of clients to return (optional)" },
          },
          required: [],
        },
      },

      {
        name: "get_client_expansion_opportunities",
        description: "Find clients who only buy 1-2 categories (cross-sell/upsell potential). Use when user asks about 'expansion opportunities', 'cross-sell potential', 'clients who could buy more categories'.",
        parameters: {
          type: "object",
          properties: {
            limit: { type: "integer", description: "Maximum number of clients to return (optional)" },
            min_win: { type: "number", description: "Minimum win percentage (e.g., 50 for 50%)" },
            max_win: { type: "number", description: "Maximum win percentage (e.g., 80 for 80%)" },
          },
          required: [],
        },
      },

      {
        name: "get_portfolio_diversity",
        description: "Analyze portfolio concentration risk (how much revenue comes from top 10 clients). Use when user asks about 'concentration risk', 'portfolio diversity', 'how dependent are we on top clients?'.",
        parameters: {
          type: "object",
          properties: {},
          required: [],
        },
      },

      {
        name: "get_client_concentration",
        description: "Show top 20 clients with revenue concentration and cumulative percentages (Pareto analysis). Use when user asks about 'client concentration', 'top 20 clients', '80/20 analysis', 'revenue distribution'.",
        parameters: {
          type: "object",
          properties: {},
          required: [],
        },
      },

      {
        name: "get_declining_win_rates",
        description: "Identify quarters where win rate has declined for 2+ consecutive quarters (early warning signal). Use when user asks about 'declining win rates', 'is our win rate dropping?', 'performance alerts'.",
        parameters: {
          type: "object",
          properties: {
            limit: { type: "integer", description: "Number of declining periods to show (optional)" },
          },
          required: [],
        },
      },

      {
        name: "get_underperforming_segments",
        description: "Find categories/states/companies performing below average in value or win rate. Use when user asks about 'underperforming segments', 'which categories/states are struggling?', 'below average performance'.",
        parameters: {
          type: "object",
          properties: {
            dimension: {
              type: "string",
              enum: ["category", "state", "company"],
              description: "What dimension to analyze (category, state, or company)",
            },
            limit: { type: "integer", description: "Maximum number of segments to return (optional)" },
          },
          required: ["dimension"],
        },
      },

      {
        name: "get_stalled_deals",
        description: "Identify projects that have been in pipeline/status for a specific duration using CURRENT_DATE - Start Date calculation. This is the CORRECT function for duration-in-status queries (NOT date range filters). Use when user asks about: 'stuck in [status] for X days', 'been in Proposal Development for over 60 days', 'projects in pipeline longer than X days', 'how long in status', 'stalled deals', 'slow-moving opportunities'. Supports optional filters (status, category, company, state, tags) to narrow results while still calculating duration correctly. Example: 'Aviation projects stuck in Proposal Development for over 60 days' â†’ min_days_stalled=60, categories=['Aviation'], status='Proposal Development'.",
        parameters: {
          type: "object",
          properties: {
            min_days_stalled: {
              type: "integer",
              description: "Minimum days in pipeline to be considered stalled (e.g., 60 for 'over 60 days', 180 for 'over 6 months')",
            },
            status: {
              type: "string",
              description: "Filter by specific status (e.g., 'Proposal Development', 'Submitted', 'Lead'). Optional.",
            },
            categories: {
              type: "array",
              items: { type: "string" },
              description: "Filter by request categories (e.g., ['Aviation'], ['Healthcare']). Optional.",
            },
            tags: {
              type: "array",
              items: { type: "string" },
              description: "Filter by tags. Optional.",
            },
            company: {
              type: "string",
              description: "Filter by company name. Optional.",
            },
            state_code: {
              type: "string",
              description: "Filter by state code. Optional.",
            },
            limit: { type: "integer", description: "Maximum number of deals to return (optional)" },
          },
          required: ["min_days_stalled"],
        },
      },

      {
        name: "get_projects_with_missing_fields",
        description: "Find projects with missing, incomplete, empty, or NULL critical fields (fee, start date, description). Use when user asks about 'missing data', 'incomplete information', 'empty fields', 'NULL values', 'data quality', 'projects without fee', 'projects with no start date', 'incomplete records', 'missing description'. This checks for NULL or empty string values in critical fields. DO NOT confuse with 'Is Updated' field - that's different! Supports optional filters to narrow results by status, category, company, etc. Keywords: missing, empty, incomplete, NULL, blank, no data, data quality, without.",
        parameters: {
          type: "object",
          properties: {
            status: {
              type: "array",
              items: { type: "string" },
              description: "Filter by status. Optional.",
            },
            categories: {
              type: "array",
              items: { type: "string" },
              description: "Filter by request categories. Optional.",
            },
            tags: {
              type: "array",
              items: { type: "string" },
              description: "Filter by tags. Optional.",
            },
            company: {
              type: "string",
              description: "Filter by company name. Optional.",
            },
            state_code: {
              type: "string",
              description: "Filter by state code. Optional.",
            },
            limit: { type: "integer", description: "Maximum number of projects to return (optional)" },
          },
          required: [],
        },
      },

      {
        name: "get_clients_with_multiple_pocs",
        description: "Identify clients that have projects with multiple different Points of Contact (POCs). Use when user asks about 'clients with multiple POCs', 'different points of contact per client', 'clients with various POCs', 'POC breakdown by client', 'which clients have multiple different contacts', 'multiple departments at same client'. Returns clients with poc_count > 1, showing list of all POCs (poc_list) for each client. Supports optional filters (status, categories, company, state, date range) to narrow results. Keywords: multiple POCs, different contacts, various points of contact, POC diversity, client contacts.",
        parameters: {
          type: "object",
          properties: {
            status: {
              type: "array",
              items: { type: "string" },
              description: "Filter by status. Optional.",
            },
            categories: {
              type: "array",
              items: { type: "string" },
              description: "Filter by request categories. Optional.",
            },
            tags: {
              type: "array",
              items: { type: "string" },
              description: "Filter by tags. Optional.",
            },
            company: {
              type: "string",
              description: "Filter by company name. Optional.",
            },
            state_code: {
              type: "string",
              description: "Filter by state code. Optional.",
            },
            start_date: {
              type: "string",
              description: "Start date for filtering projects. Optional.",
            },
            end_date: {
              type: "string",
              description: "End date for filtering projects. Optional.",
            },
            limit: { type: "integer", description: "Maximum number of clients to return (optional)" },
          },
          required: [],
        },
      },

      // Utility
      {
        name: "get_all_projects",
        description: "List all projects with basic fields. Supports filtering by ModuleName column (Opportunities, Tracked Work, Construction) when user asks for a specific module like 'opportunities module', 'tracked work module', 'construction module'.",
        parameters: {
          type: "object",
          properties: {
            modules: { 
              type: "array", 
              items: { type: "string" },
              description: "Filter by ModuleName column. Values: 'Opportunity', 'Tracked Work', 'Construction'. Use for: 'list opportunities module', 'show tracked work module', 'construction module projects'."
            }
          },
          required: [],
        },
      },

      {
        name: "get_project_by_id",
        description: "Find project(s) by Project Name/PID. Use for: 'show PID 19', 'get PID19', 'project PID 100', 'provide all projects with PID19', 'find PID 5', 'PID 123 details'. Returns ALL columns. Also handles PID ranges like 'PID 1 to PID 19' or 'projects between PID1 and PID20'.",
        parameters: {
          type: "object",
          properties: {
            project_name: { type: "string", description: "Project ID (e.g., 'PID 19', 'PID19', '19')" },
            pid_start: { type: "integer", description: "Start of PID range for range queries (e.g., 1 for 'PID 1 to PID 19')" },
            pid_end: { type: "integer", description: "End of PID range for range queries (e.g., 19 for 'PID 1 to PID 19')" },
          },
          required: [],
        },
      },
      
      {
        name: "get_project_column_by_id",
        description: "Get a SPECIFIC COLUMN value for a SINGLE PROJECT by PROJECT ID (PID). Use ONLY for single-project lookups like 'description of PID 1061', 'fee for PID 5', 'status of project ABC'. DO NOT use for CLIENT-level queries - if user mentions 'client', 'Client', or asks for 'average', use get_projects_by_client instead. This is for INDIVIDUAL PROJECT lookups only, NOT client aggregation. Column names: Request Category, Module Name, LP, Conflict, Co Op, Project Name, Client, Status, Group Criteria, Fee, Group, Company, Email, Point Of Contact, Win %, Project Type, Start Date, Description, State Lookup, Internal Id, Is Updated, Tags",
        parameters: {
          type: "object",
          properties: {
            project_name: { type: "string", description: "Project ID or name (e.g., 'PID 1204', 'pid1204'). NOT for client IDs like 'Client 5713'." },
            column_name: { type: "string", description: "Exact column name to retrieve (e.g., 'Description', 'Fee', 'Status', 'Win %')" },
          },
          required: ["project_name", "column_name"],
        },
      },

      {
        name: "search_projects_by_keyword",
        description: "Search projects by keyword in description field. Use for questions like 'projects mentioning bridge', 'search for water treatment', 'find projects with keyword X', 'projects about sustainability', 'projects related to airports', 'municipal jobs', 'medical buildings', 'energy projects'. CRITICAL: Use this for domain-specific keywords NOT found as exact category/type names. Examples: 'airport', 'municipal', 'medical', 'building', 'facility', 'solar', 'water', 'highway', 'pavement'. Supports additional filters like status, location, size, etc.",
        parameters: {
          type: "object",
          properties: {
            keyword: { type: "string", description: "Keyword to search for in project description. Extract core keyword from phrases like 'appear to be municipal jobs' â†’ 'municipal', 'related to airports' â†’ 'airport', 'medical buildings' â†’ 'medical'." },
            limit: { type: "integer", description: "Number of results to return" },
          },
          required: ["keyword"],
        },
      },

      {
        name: "get_upcoming_similar_to_group_pattern",
        description: "TWO-STEP PATTERN ANALYSIS: Analyzes common characteristics (tags, status) in a reference group, then finds upcoming projects matching those patterns. Use for queries like 'upcoming projects similar to lost projects', 'future projects like won ones', 'upcoming matching successful project patterns'. Steps: (1) Query reference group, (2) Extract top 3 most common tags, (3) Find upcoming projects with those tags + same status.",
        parameters: {
          type: "object",
          properties: {
            reference_status: { 
              type: "string", 
              description: "Status of the reference group to analyze (e.g., 'lost', 'won', 'hold'). Will find patterns in this group first." 
            },
            time_reference: { 
              type: "string", 
              description: "Time reference for upcoming projects (e.g., 'upcoming', 'next 6 months', 'future')" 
            },
            limit: { type: "integer", description: "Number of upcoming projects to return" },
          },
          required: ["reference_status"],
        },
      },
    ];
  }

  /**
   * Detect if the user's follow-up question contains override/negation intent
   * When detected, skip context merging and treat as a fresh query
   */
  private detectOverrideIntent(question: string): { isOverride: boolean; reason: string } {
    const normalizedQuestion = question.toLowerCase().trim();
    
    // Override patterns - order matters (more specific first)
    const overridePatterns: Array<{ pattern: RegExp; reason: string }> = [
      // Explicit negation of previous filters
      { pattern: /\b(don'?t\s+want|do\s+not\s+want|dont\s+want)\b/i, reason: "explicit 'don't want' negation" },
      { pattern: /\b(no\s+longer|not\s+anymore|anymore)\b/i, reason: "'no longer' override" },
      { pattern: /\b(ignore\s+previous|forget\s+previous|disregard)\b/i, reason: "explicit ignore previous" },
      { pattern: /\b(instead\s+of|rather\s+than)\b/i, reason: "'instead of' replacement" },
      { pattern: /\b(only\s+want|just\s+want|actually\s+want)\b/i, reason: "explicit 'only want' override" },
      // "only X" at start of question - implies replacing previous filter with just X
      { pattern: /^only\s+[\w-]+/i, reason: "'only X' at start - replacement intent" },
      // "X only" at end - implies replacing previous filter with just X (e.g., "1834 only")
      { pattern: /[\w-]+\s+only$/i, reason: "'X only' at end - replacement intent" },
      // "just X" without "want" - also implies replacement  
      { pattern: /^just\s+[\w-]+/i, reason: "'just X' at start - replacement intent" },
      { pattern: /\b(exclude|excluding|without)\s+\w+/i, reason: "exclusion keyword" },
      { pattern: /\bnot\s+(pid|pids|project|projects|status|client|company)\b/i, reason: "negation of entity type" },
      { pattern: /\b(remove|drop|skip)\s+(pid|pids|project|projects|the\s+previous)/i, reason: "removal instruction" },
      // "want X not Y" or "want X but not Y"
      { pattern: /\bwant\s+.{1,30}\s+(not|but\s+not)\s+/i, reason: "'want X not Y' pattern" },
      // "X instead" at end
      { pattern: /\binstead$/i, reason: "'instead' at end" },
    ];
    
    for (const { pattern, reason } of overridePatterns) {
      if (pattern.test(normalizedQuestion)) {
        console.log(`[OverrideDetection] âœ“ Detected override: "${reason}" in question: "${question}"`);
        return { isOverride: true, reason };
      }
    }
    
    console.log(`[OverrideDetection] No override detected in: "${question}"`);
    return { isOverride: false, reason: '' };
  }

  /**
   * Detect if a question is a NEW, independent query vs a follow-up to previous context
   * Returns true if it's clearly a new query (should NOT merge previous context)
   */
  private isNewIndependentQuery(
    question: string, 
    newFunctionName: string,
    previousFunctionName?: string
  ): { isNew: boolean; reason: string } {
    const normalizedQuestion = question.toLowerCase().trim();
    
    // 1. Check for referential language that indicates follow-up
    const FOLLOW_UP_INDICATORS = [
      /\bthese\s+(projects|clients|results|companies|records)/i,
      /\bthose\s+(projects|clients|results|companies|records)/i,
      /\b(the\s+)?(above|previous|same)\s+(projects|clients|results)/i,
      /\bfrom\s+(them|these|those|the\s+above|the\s+results)/i,
      /\bof\s+(them|these|those)\b/i,
      /\bwhich\s+of\s+(these|those|them)\b/i,
      /\b(also|additionally|and\s+also)\s+(show|include|add|filter)/i,
      /\b(but|and)\s+(with|only|limit|filter)/i,
      /\b(narrow|refine|filter)\s+(it|them|these|those|the\s+results)/i,
      /\bmore\s+(details|info|information)\s+(on|about)\b/i,
      // "Which are X" without explicit noun = follow-up about existing results
      // e.g., "which are most likely to win", "which are in California", "which have fee above 50M"
      /^which\s+are\s+/i,
      /^which\s+(have|has|had)\s+/i,
      /^which\s+(is|will|would|could|should|might)\s+/i,
      /^which\s+(ones?|projects?)\s+(are|have|is|will)\s+/i,
      // Contextual anchors at start of query - "From these, show...", "Among those, find..."
      /^from\s+(these|those|them|the\s+(?:above|results|records|projects))\s*[,.]?\s*/i,
      /^among\s+(these|those|them|the\s+(?:above|results|records|projects))\s*[,.]?\s*/i,
      /^out\s+of\s+(these|those|them|the\s+(?:above|results|records|projects))\s*[,.]?\s*/i,
      /^within\s+(these|those|them|the\s+(?:above|results|records|projects))\s*[,.]?\s*/i,
      /^in\s+(these|those)\s+(results|records|projects)?\s*[,.]?\s*/i,
      /^for\s+(these|those)\s+(projects|results)?\s*[,.]?\s*/i,
    ];
    
    const hasFollowUpLanguage = FOLLOW_UP_INDICATORS.some(pattern => pattern.test(normalizedQuestion));
    
    if (hasFollowUpLanguage) {
      console.log(`[NewQueryDetection] Follow-up language detected - NOT a new query`);
      return { isNew: false, reason: 'follow-up language detected' };
    }
    
    // 2. Check if this is a complete, standalone query (has its own filters/entities)
    // These patterns indicate a fresh, complete query
    const STANDALONE_QUERY_PATTERNS = [
      /^(show|get|find|list|display|give)\s+(me\s+)?(all\s+)?projects/i,
      /^projects\s+(with|in|from|starting|ending|for|by)/i,
      /^(how\s+many|what|which|who)\s+/i,
      /^(top|all|total)\s+\d*\s*(projects|clients|companies)/i,
      /\bprojects\s+(starting|from|in|with|for|by)\s+\d/i, // Projects with explicit date/number
    ];
    
    const isStandaloneQuery = STANDALONE_QUERY_PATTERNS.some(pattern => pattern.test(normalizedQuestion));
    
    // 3. Check if the function type changed significantly (different category of query)
    const QUERY_CATEGORIES: Record<string, string> = {
      'get_projects_by_date_range': 'date',
      'get_projects_by_quarter': 'date',
      'get_projects_by_combined_filters': 'filter',
      'get_projects_by_client': 'entity',
      'get_projects_by_poc': 'entity',
      'get_projects_by_category': 'category',
      'get_top_clients': 'aggregation',
      'get_top_tags': 'aggregation',
      'compare_companies': 'aggregation',
      'get_size_distribution': 'aggregation',
      'get_ai_analysis': 'analysis',
      'get_projects_by_pids': 'lookup',
      'get_project_by_pid': 'lookup',
    };
    
    const prevCategory = previousFunctionName ? QUERY_CATEGORIES[previousFunctionName] || 'other' : null;
    const newCategory = QUERY_CATEGORIES[newFunctionName] || 'other';
    
    const categoryChanged = prevCategory && prevCategory !== newCategory;
    
    // 4. Decision logic: treat as NEW query if:
    //    - It's a standalone query pattern AND no follow-up language
    //    - OR category of query changed significantly
    if (isStandaloneQuery && !hasFollowUpLanguage) {
      console.log(`[NewQueryDetection] âœ“ NEW QUERY: Standalone pattern detected without follow-up language`);
      return { isNew: true, reason: 'standalone query pattern' };
    }
    
    if (categoryChanged && !hasFollowUpLanguage) {
      console.log(`[NewQueryDetection] âœ“ NEW QUERY: Category changed from "${prevCategory}" to "${newCategory}"`);
      return { isNew: true, reason: `category changed: ${prevCategory} â†’ ${newCategory}` };
    }
    
    // 5. Default: Check if question has complete date/filter specification 
    //    (not just "with status won" type refinements)
    const hasCompleteDateSpec = /\b(starting|from|in|during)\s+\d{1,2}[-\/]\d{1,2}[-\/]\d{4}\b/i.test(normalizedQuestion) ||
                                /\b(in|during|for)\s+(20\d{2}|january|february|march|april|may|june|july|august|september|october|november|december)/i.test(normalizedQuestion) ||
                                /\b(last|past|next)\s+\d*\s*(months?|years?|quarters?|weeks?|days?)\b/i.test(normalizedQuestion);
    
    if (hasCompleteDateSpec && !hasFollowUpLanguage) {
      console.log(`[NewQueryDetection] âœ“ NEW QUERY: Complete date specification detected`);
      return { isNew: true, reason: 'complete date specification' };
    }
    
    console.log(`[NewQueryDetection] No clear new query signal - treating as potential follow-up`);
    return { isNew: false, reason: 'no clear new query signal' };
  }

  /**
   * Smart merge of previous arguments with new arguments
   * Detects whether the user is pivoting (replace) or refining (accumulate)
   */
  private smartMergeArguments(
    previousArgs: Record<string, any>,
    newArgs: Record<string, any>,
    previousFunctionName?: string,
    newFunctionName?: string
  ): Record<string, any> {
    console.log(`[SmartMerge] STARTING MERGE`);
    console.log(`[SmartMerge] Previous function: ${previousFunctionName}, New function: ${newFunctionName}`);
    console.log(`[SmartMerge] Previous args:`, JSON.stringify(previousArgs));
    console.log(`[SmartMerge] New args:`, JSON.stringify(newArgs));

    // Normalize tags and categories to always be arrays (AI might return strings)
    if (newArgs.tags && typeof newArgs.tags === 'string') {
      newArgs.tags = [newArgs.tags];
      console.log(`[SmartMerge] Normalized new tags from string to array:`, newArgs.tags);
    }
    if (newArgs.categories && typeof newArgs.categories === 'string') {
      newArgs.categories = [newArgs.categories];
      console.log(`[SmartMerge] Normalized new categories from string to array:`, newArgs.categories);
    }
    
    // Clear limit when switching from ranking/top queries to client/company queries
    // This ensures "average" calculations use ALL records, not just top 1
    const rankingFunctions = ['get_largest_projects', 'get_smallest_projects', 'get_highest_win_rate', 'get_lowest_win_rate', 'get_top_clients', 'compare_companies', 'get_top_pocs', 'get_top_tags', 'get_status_breakdown', 'get_revenue_by_project_type', 'get_project_type_breakdown', 'get_projects_by_project_type'];
    const clientCompanyFunctions = ['get_projects_by_client', 'get_projects_by_company', 'compare_clients', 'compare_companies'];
    
    // Clear limit when switching from ranking to detail/average queries
    const detailFunctions = ['get_projects_by_client', 'get_projects_by_company', 'get_projects_by_project_type'];
    
    // Clear limit when switching from ranking to detail/client/company queries
    if (previousFunctionName && newFunctionName &&
        rankingFunctions.includes(previousFunctionName) &&
        (clientCompanyFunctions.includes(newFunctionName) || detailFunctions.includes(newFunctionName))) {
      console.log(`[SmartMerge] âš ï¸ Function changed from ranking to detail/client/company query - clearing limit for accurate averages`);
      delete previousArgs.limit;
      delete previousArgs.offset;
    }
    
    // Also clear limit when STAYING in same detail function (e.g., asking for average after limit query)
    if (previousFunctionName && newFunctionName && 
        previousFunctionName === newFunctionName &&
        detailFunctions.includes(newFunctionName) &&
        previousArgs.limit !== undefined) {
      console.log(`[SmartMerge] âš ï¸ Staying in same detail function but clearing limit for average/detail query`);
      delete previousArgs.limit;
      delete previousArgs.offset;
    }
    if (previousArgs.tags && typeof previousArgs.tags === 'string') {
      previousArgs.tags = [previousArgs.tags];
      console.log(`[SmartMerge] Normalized previous tags from string to array:`, previousArgs.tags);
    }
    if (previousArgs.categories && typeof previousArgs.categories === 'string') {
      previousArgs.categories = [previousArgs.categories];
      console.log(`[SmartMerge] Normalized previous categories from string to array:`, previousArgs.categories);
    }

    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    // STATE/REGION MUTUAL EXCLUSIVITY: state_code and states are mutually exclusive
    // If follow-up provides state_code, remove previous states (and vice versa)
    // This ensures "projects in California" replaces "projects in West region"
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    if (newArgs.state_code && previousArgs.states) {
      console.log(`[SmartMerge] ğŸ”„ STATE OVERRIDE: New state_code="${newArgs.state_code}" replaces previous states array`);
      delete previousArgs.states;
    }
    if (newArgs.states && previousArgs.state_code) {
      console.log(`[SmartMerge] ğŸ”„ REGION OVERRIDE: New states array replaces previous state_code="${previousArgs.state_code}"`);
      delete previousArgs.state_code;
    }
    // Also handle new state_code overriding previous state_code
    if (newArgs.state_code && previousArgs.state_code && newArgs.state_code !== previousArgs.state_code) {
      console.log(`[SmartMerge] ğŸ”„ STATE REPLACE: "${previousArgs.state_code}" â†’ "${newArgs.state_code}"`);
    }

    // Define parameter categories
    const REPLACEABLE_PARAMS = new Set([
      'company',     // Usually want to pivot to a different company
      'client',      // Usually want to pivot to a different client
      'poc',         // Usually want to pivot to a different person
      'size',        // Usually want to change the size filter
      'state_code',  // Usually want to pivot to a different location
      'categories',  // Usually want to REPLACE categories when pivoting
      'tags',        // Usually want to REPLACE tags (e.g., "show me X tag" should replace, not add)
    ]);

    const ADDITIVE_PARAMS = new Set<string>([
      // Removed 'tags' - tags should be REPLACEABLE by default
      // If user says "also add X", AI should include it in the new tags array
    ]);

    const CUMULATIVE_PARAMS = new Set([
      // Range/threshold filters - these should ALWAYS persist
      'min_fee', 'max_fee', 'min_win', 'max_win',
      // Date filters
      'start_date', 'end_date', 'year', 'quarter', 'years',
      // Status filter
      'status',
      // Category/type filters (when not explicitly changed)
      'category', 'project_type', 'project_types',
      // Other context filters
      'state_name', 'time_reference', 'project_name',
      // Location (preserve if not explicitly changing)
      'state_code', 'states',
      // NOTE: 'limit' is NOT cumulative - if user asks for "each" or "all", we shouldn't carry forward limit
    ]);

    const result: Record<string, any> = {};

    // Step 0: Detect if newArgs is essentially empty (only has optional params)
    // Optional params that can be changed without affecting core query logic
    const OPTIONAL_ONLY_PARAMS = new Set(['limit', 'offset']);
    const newArgKeys = Object.keys(newArgs);
    const hasOnlyOptionalParams = newArgKeys.length === 0 || 
                                   newArgKeys.every(key => OPTIONAL_ONLY_PARAMS.has(key));
    
    if (hasOnlyOptionalParams && newArgKeys.length > 0) {
      console.log(`[SmartMerge] âš ï¸  WARNING: New args only contain optional params (${newArgKeys.join(', ')})`);
      console.log(`[SmartMerge]    This might lose required parameters! Preserving ALL previous args.`);
    }

    // Step 0.5: Detect PIVOT vs REFINEMENT for replaceable params
    // PIVOT = User explicitly mentions a replaceable param that was previously set with a DIFFERENT value
    // REFINEMENT = User adds new filters without mentioning previous replaceable params
    const explicitPivotParams = new Set<string>();
    
    for (const key of Array.from(REPLACEABLE_PARAMS)) {
      if (key in newArgs && key in previousArgs) {
        // User mentioned this param again - check if value changed
        const prevValue = JSON.stringify(previousArgs[key]);
        const newValue = JSON.stringify(newArgs[key]);
        
        if (prevValue !== newValue) {
          // Value changed - this is an EXPLICIT PIVOT for this specific param
          explicitPivotParams.add(key);
          console.log(`[SmartMerge] ğŸ”„ PIVOT detected for ${key}: ${prevValue} â†’ ${newValue}`);
        }
      }
    }
    
    // Detect refinement: User is adding filters without pivoting
    const isRefinement = !hasOnlyOptionalParams && explicitPivotParams.size === 0;
    
    if (isRefinement) {
      console.log(`[SmartMerge] ğŸ¯ REFINEMENT detected: User is adding filters, keeping all previous replaceable params`);
    }

    // Step 1: Add all previous cumulative parameters (unless new ones override them)
    for (const [key, value] of Object.entries(previousArgs)) {
      if (CUMULATIVE_PARAMS.has(key) && !(key in newArgs)) {
        console.log(`[SmartMerge] Keeping cumulative param: ${key} = ${JSON.stringify(value)}`);
        result[key] = value;
      } else if (REPLACEABLE_PARAMS.has(key) && !(key in newArgs)) {
        // NEW LOGIC: Smart pivot detection
        // Keep replaceable params UNLESS we're in an explicit pivot for that specific param
        
        if (key === 'tags' || key === 'categories') {
          // Special handling: Only drop tags if new tags provided, only drop categories if new categories provided
          const shouldDropTags = key === 'tags' && newArgs.tags;
          const shouldDropCategories = key === 'categories' && newArgs.categories;
          
          if (shouldDropTags || shouldDropCategories) {
            console.log(`[SmartMerge] Dropping ${key} because new ${key} provided`);
          } else {
            console.log(`[SmartMerge] Keeping ${key} (no new ${key} in follow-up): ${JSON.stringify(value)}`);
            result[key] = value;
          }
        } else if (isRefinement || hasOnlyOptionalParams) {
          // REFINEMENT or OPTIONAL-ONLY: Keep all replaceable params
          // User is adding filters, not pivoting
          console.log(`[SmartMerge] âœ… Keeping ${key} = ${JSON.stringify(value)} (refinement mode)`);
          result[key] = value;
        } else if (explicitPivotParams.has(key)) {
          // Explicit pivot for THIS specific param - drop it
          console.log(`[SmartMerge] ğŸ”„ Dropping ${key} (explicit pivot detected)`);
        } else {
          // Keep other replaceable params even during pivot (only drop the pivoted one)
          console.log(`[SmartMerge] Keeping ${key} = ${JSON.stringify(value)} (not part of pivot)`);
          result[key] = value;
        }
      } else if (!CUMULATIVE_PARAMS.has(key) && !REPLACEABLE_PARAMS.has(key)) {
        // Handle internal flags (starting with _)
        if (key.startsWith('_')) {
          // PRESERVE _explicit_category - it determines which column (RequestCategory vs ProjectType) to use
          if (key === '_explicit_category' && result.categories) {
            console.log(`[SmartMerge] âœ… PRESERVING ${key} flag with inherited categories`);
            result[key] = value;
            continue;
          }
          // Skip other internal flags
          console.log(`[SmartMerge] Skipping internal flag: ${key}`);
          continue;
        }
        // Skip limit/offset - these should NOT be carried forward to follow-ups
        // If user asks "for each" or "all", the AI won't pass limit, and we shouldn't inherit it
        if (key === 'limit' || key === 'offset') {
          console.log(`[SmartMerge] âš ï¸ NOT carrying forward ${key} - it should be set fresh per query`);
          continue;
        }
        // Unknown parameter - keep it for safety
        console.log(`[SmartMerge] Keeping unknown param: ${key} = ${JSON.stringify(value)}`);
        result[key] = value;
      }
    }

    // Step 2: Process new parameters
    for (const [key, value] of Object.entries(newArgs)) {
      if (REPLACEABLE_PARAMS.has(key)) {
        // REPLACE: Don't merge with previous value, just use new value
        console.log(`[SmartMerge] Replacing param: ${key} = ${JSON.stringify(value)}`);
        result[key] = value;
      } else if (ADDITIVE_PARAMS.has(key)) {
        // ADDITIVE: Union new values with existing values (for tags/categories)
        if (previousArgs[key] && Array.isArray(previousArgs[key]) && Array.isArray(value)) {
          // Combine old and new, removing duplicates
          const combined = Array.from(new Set([...previousArgs[key], ...value]));
          console.log(`[SmartMerge] Adding to existing ${key}: ${JSON.stringify(previousArgs[key])} + ${JSON.stringify(value)} = ${JSON.stringify(combined)}`);
          result[key] = combined;
        } else {
          // No previous value or not arrays, just use new value
          console.log(`[SmartMerge] Setting new ${key}: ${JSON.stringify(value)}`);
          result[key] = value;
        }
      } else {
        // CUMULATIVE or OVERRIDE: Use new value
        console.log(`[SmartMerge] Adding/overriding param: ${key} = ${JSON.stringify(value)}`);
        result[key] = value;
      }
    }

    // Step 2.5: Handle fee/win% range changes
    // If user specifies a new min_fee but no max_fee, clear old max_fee
    // (they want "greater than X", not "between X and old_max")
    if (newArgs.min_fee !== undefined && newArgs.max_fee === undefined && previousArgs.max_fee !== undefined) {
      console.log(`[SmartMerge] Fee range change detected: new min_fee without max_fee`);
      console.log(`[SmartMerge]   Clearing old max_fee (${previousArgs.max_fee}) because user wants "greater than ${newArgs.min_fee}"`);
      delete result.max_fee;
    }
    // Similarly, if user specifies a new max_fee but no min_fee, clear old min_fee
    // (they want "less than X", not "between old_min and X")
    if (newArgs.max_fee !== undefined && newArgs.min_fee === undefined && previousArgs.min_fee !== undefined) {
      console.log(`[SmartMerge] Fee range change detected: new max_fee without min_fee`);
      console.log(`[SmartMerge]   Clearing old min_fee (${previousArgs.min_fee}) because user wants "less than ${newArgs.max_fee}"`);
      delete result.min_fee;
    }
    
    // Same logic for win% ranges
    if (newArgs.min_win !== undefined && newArgs.max_win === undefined && previousArgs.max_win !== undefined) {
      console.log(`[SmartMerge] Win% range change detected: clearing old max_win`);
      delete result.max_win;
    }
    if (newArgs.max_win !== undefined && newArgs.min_win === undefined && previousArgs.min_win !== undefined) {
      console.log(`[SmartMerge] Win% range change detected: clearing old min_win`);
      delete result.min_win;
    }

    // Step 3: Handle special pivot cases
    console.log(`[SmartMerge] Checking pivot conditions...`);
    console.log(`[SmartMerge]   newArgs.categories? ${!!newArgs.categories}`);
    console.log(`[SmartMerge]   previousArgs.tags? ${!!previousArgs.tags}`);
    console.log(`[SmartMerge]   !newArgs.tags? ${!newArgs.tags}`);
    
    // IMPORTANT: If user provides new categories but had old tags,
    // this is likely a PIVOT (e.g., tags:Rail/Transit â†’ categories:Healthcare).
    // In this case, we should CLEAR old tags to prevent impossible combinations
    // like "categories=Healthcare AND tags=Rail"
    if (newArgs.categories && previousArgs.tags && !newArgs.tags) {
      console.log(`[SmartMerge] PIVOT condition met: new categories, old tags exist, no new tags`);
      // User pivoted to new categories but didn't mention tags
      // Check if categories actually changed (or if previous had no categories)
      const oldCats = JSON.stringify(previousArgs.categories || []);
      const newCats = JSON.stringify(newArgs.categories);
      
      console.log(`[SmartMerge]   Comparing categories: ${oldCats} vs ${newCats}`);
      
      if (oldCats !== newCats) {
        // Categories changed or were newly added - this is a pivot, clear old tags
        delete result.tags;
        console.log(`[SmartMerge] âœ… PIVOT DETECTED: Categories changed/added, CLEARING old tags`);
        console.log(`[SmartMerge]   Old categories: ${oldCats}, New categories: ${newCats}`);
        console.log(`[SmartMerge]   Old tags (${JSON.stringify(previousArgs.tags)}) were removed`);
      }
    }

    // Similarly, if user provides new tags but had old categories
    // Clear old categories (they're pivoting from one domain to another)
    if (newArgs.tags && previousArgs.categories && !newArgs.categories) {
      console.log(`[SmartMerge] PIVOT condition met: new tags, old categories exist, no new categories`);
      const oldTags = JSON.stringify(previousArgs.tags || []);
      const newTags = JSON.stringify(newArgs.tags);
      
      console.log(`[SmartMerge]   Comparing tags: ${oldTags} vs ${newTags}`);
      
      if (oldTags !== newTags) {
        // Tags changed or were newly added - this is a pivot, clear old categories
        delete result.categories;
        console.log(`[SmartMerge] âœ… PIVOT DETECTED: Tags changed/added, CLEARING old categories`);
        console.log(`[SmartMerge]   Old tags: ${oldTags}, New tags: ${newTags}`);
        console.log(`[SmartMerge]   Old categories (${JSON.stringify(previousArgs.categories)}) were removed`);
      }
    }
    
    // Log replacements for debugging
    if (previousArgs.tags && newArgs.tags) {
      console.log(`[SmartMerge] Tags REPLACED: ${JSON.stringify(previousArgs.tags)} â†’ ${JSON.stringify(newArgs.tags)}`);
    }

    if (previousArgs.categories && newArgs.categories) {
      console.log(`[SmartMerge] Categories REPLACED: ${JSON.stringify(previousArgs.categories)} â†’ ${JSON.stringify(newArgs.categories)}`);
    }

    return result;
  }

  private resolveEntityReferences(
    args: Record<string, any>,
    previousResults: any[],
    userQuestion: string
  ): Record<string, any> {
    if (!previousResults || previousResults.length === 0) return args;

    const result = { ...args };
    const firstResult = previousResults[0];
    const questionLower = userQuestion.toLowerCase();

    // Pattern: "this client", "that client", "the client", "same client"
    const clientPatterns = /\b(this|that|the|same)\s+client\b/i;
    if (clientPatterns.test(userQuestion) && result.client) {
      const clientMatch = result.client.toLowerCase();
      if (clientMatch.includes('this client') || clientMatch.includes('that client') || 
          clientMatch.includes('the client') || clientMatch.includes('same client')) {
        // Extract actual client from previous result
        if (firstResult.Client) {
          result.client = firstResult.Client;
          console.log(`[EntityResolver] Replaced "${args.client}" with "${firstResult.Client}" from previous result`);
        }
      }
    }

    // Pattern: "this company", "that company", "the company", "same company"
    const companyPatterns = /\b(this|that|the|same)\s+company\b/i;
    if (companyPatterns.test(userQuestion) && result.company) {
      const companyMatch = result.company.toLowerCase();
      if (companyMatch.includes('this company') || companyMatch.includes('that company') || 
          companyMatch.includes('the company') || companyMatch.includes('same company')) {
        // Extract actual company from previous result
        if (firstResult.Company) {
          result.company = firstResult.Company;
          console.log(`[EntityResolver] Replaced "${args.company}" with "${firstResult.Company}" from previous result`);
        }
      }
    }

    // Pattern: "this project", "that project"
    const projectPatterns = /\b(this|that|the|same)\s+project\b/i;
    if (projectPatterns.test(userQuestion) && result.pid) {
      const pidMatch = result.pid.toLowerCase();
      if (pidMatch.includes('this project') || pidMatch.includes('that project')) {
        // Extract actual PID from previous result
        if (firstResult.PID) {
          result.pid = firstResult.PID;
          console.log(`[EntityResolver] Replaced "${args.pid}" with "${firstResult.PID}" from previous result`);
        }
      }
    }

    return result;
  }

  /**
   * TWO-PASS LLM APPROACH: Extract entities using GPT-5.2-mini
   * Pass 1: Fast entity extraction with structured schema
   * This replaces regex-based extraction for better accuracy
   */
  async extractEntitiesWithLLM(userQuestion: string): Promise<Record<string, any>> {
    const startTime = Date.now();
    
    try {
      const extractionPrompt = `You are an entity extraction system for a project database query system.
Extract ALL entities from the user's query. Return JSON with these fields (use null if not found):

{
  "person_name": <string or null - Names of people (POC, sales rep, contact). NEVER include command phrases like "show me", "give me", "list all", "find", "get". Only extract actual person names.>,
  "company": <string or null - Company/OPCO names like "Company A", "Company F">,
  "client": <string or null - Client/customer names>,
  "division": <string or null - Business unit/division name like "Engineering", "Healthcare Division", "IT Division">,
  "department": <string or null - Department name like "Operations", "Sales", "Engineering">,
  "states": <array of strings or null - US state names mentioned>,
  "region": <string or null - Region like "west", "midwest", "south", "northeast", "east">,
  "status": <string or null - Project status: "Won", "Lost", "Lead", "Submitted", "Pursue", "Qualified Lead", "Unqualified", "No-Go", "Closed", "In Progress", "Proposal Development", "Hold">,
  "min_fee": <number or null - Minimum fee/budget in dollars (convert 500k to 500000, 1M to 1000000)>,
  "max_fee": <number or null - Maximum fee/budget in dollars>,
  "min_win": <number or null - Minimum win rate percentage (0-100)>,
  "max_win": <number or null - Maximum win rate percentage (0-100)>,
  "project_type": <string or null - Type like "Hospitals", "Airports", "K-12", "Transit", "Higher Education">,
  "category": <string or null - Sector/category like "Healthcare", "Education", "Transportation">,
  "year": <number or null - Specific year mentioned (e.g., 2024)>,
  "start_date": <string or null - Start date in YYYY-MM-DD format. Calculate from today for relative references.>,
  "end_date": <string or null - End date in YYYY-MM-DD format. Calculate from today for relative references.>,
  "time_reference": <string or null - Raw time phrase if dates need parsing: "in 3 months", "next 6 months", "Q1 2025">,
  "limit": <number or null - Number of results requested ONLY for explicit limits like "top 5", "first 10", "limit to 20". NEVER extract limit from time phrases like "last 3 months" or "next 6 weeks" - the number in time phrases is for DATE calculation, NOT result limiting!>,
  "size": <string or null - Size category: "mega", "large", "medium", "small", "micro">
}

RELATIVE DATE HANDLING (today is ${new Date().toISOString().split('T')[0]}):
CRITICAL: "in X months" means WITHIN the next X months (from today to X months from now), NOT starting at X months!
- "in 3 months" / "expected to start in 3 months" / "starting in 3 months" / "within 3 months" â†’ start_date: TODAY (${new Date().toISOString().split('T')[0]}), end_date: 3 months from today, time_reference: "in 3 months"
- "next 6 months" / "upcoming 6 months" â†’ start_date: TODAY, end_date: 6 months from today
- "last 3 months" / "past 3 months" â†’ start_date: 3 months ago, end_date: TODAY
- ALWAYS set start_date to TODAY for future references like "in X months", "next X months", "within X months"
- If you can calculate dates, provide both start_date and end_date. Also include time_reference for verification.

YEAR-BASED DATE HANDLING:
- "before 2026" / "prior to 2026" / "projects starting before 2026" â†’ end_date: "2025-12-31" (everything UP TO end of 2025, EXCLUDING 2026)
- "after 2024" â†’ start_date: "2025-01-01" (EXCLUSIVE - after 2024 ends means 2025 onwards)
- "since 2024" / "from 2024" â†’ start_date: "2024-01-01" (INCLUSIVE - from the start of 2024)
- "in 2025" / "during 2025" â†’ start_date: "2025-01-01", end_date: "2025-12-31" (OR just year: 2025)
- "until 2026" / "through 2026" â†’ end_date: "2026-12-31" (INCLUDING 2026)
- For "before YEAR", set end_date to December 31 of the PREVIOUS year (2026 â†’ 2025-12-31)
- For "after YEAR", set start_date to January 1 of the NEXT year (2024 â†’ 2025-01-01)

FEE/COST HANDLING:
- "over $1M" / "above 1 million" / "more than 1M" â†’ min_fee: 1000000
- "under $500k" / "below 500k" / "less than 500,000" â†’ max_fee: 500000
- "between 1M and 5M" â†’ min_fee: 1000000, max_fee: 5000000
- "fee over 2 million" â†’ min_fee: 2000000
- K = 1000, M = 1000000, B = 1000000000

WIN RATE HANDLING:
- "win rate above 50%" / "high probability" â†’ min_win: 50
- "win rate below 30%" / "low win rate" â†’ max_win: 30
- "win rate between 40 and 60%" â†’ min_win: 40, max_win: 60
- Note: win rate is 0-100 scale, NOT 0-1

LOCATION HANDLING:
- "in California" / "California projects" â†’ states: ["California"]
- "in CA and TX" â†’ states: ["California", "Texas"] (expand abbreviations)
- "west coast" â†’ region: "west"
- "northeast region" â†’ region: "northeast"

FEW-SHOT EXAMPLES:
Query: "projects starting before 2026"
Output: {"end_date": "2025-12-31"}

Query: "won projects in California with fee over 1M"
Output: {"status": "Won", "states": ["California"], "min_fee": 1000000}

Query: "healthcare projects with win rate above 50%"
Output: {"category": "Healthcare", "min_win": 50}

Query: "education sector projects over $1M fee"
Output: {"category": "Education", "min_fee": 1000000}
EXPLANATION: "sector" = category! "education sector" means category is Education. DO NOT also set project_type!

Query: "transportation sector projects"
Output: {"category": "Transportation"}
EXPLANATION: "sector" triggers category, NOT project_type. Never set both category AND project_type to the same value!

Query: "Buildings request category projects with win rate above 90%"
Output: {"category": "Buildings", "min_win": 90}
EXPLANATION: "Buildings request category" means the REQUEST CATEGORY is "Buildings" - NOT a project_type!

Query: "list Transportation request category projects"
Output: {"category": "Transportation"}
EXPLANATION: "X request category projects" means category is X

Query: "show me John Smith's projects in Texas"
Output: {"person_name": "John Smith", "states": ["Texas"]}

Query: "top 10 projects by fee"
Output: {"limit": 10}

Query: "over last 3 months"
Output: {"start_date": "2024-09-29", "end_date": "2024-12-29", "time_reference": "last 3 months"}
EXPLANATION: The "3" in "last 3 months" is for DATE calculation, NOT a limit!

Query: "next 6 months"
Output: {"start_date": "2024-12-29", "end_date": "2025-06-29", "time_reference": "next 6 months"}
EXPLANATION: The "6" is for the time range, NOT a result limit!

Query: "projects from 2023 to 2024"
Output: {"start_date": "2023-01-01", "end_date": "2024-12-31"}

Query: "projects after 2024 in the west region"
Output: {"start_date": "2025-01-01", "region": "west"}
EXPLANATION: "after 2024" means AFTER 2024 ends â†’ 2025 onwards (exclusive)

Query: "projects from 2024" or "since 2024"
Output: {"start_date": "2024-01-01"}
EXPLANATION: "from/since 2024" means FROM the start of 2024 (inclusive)

Query: "projects in Engineering division"
Output: {"division": "Engineering"}

Query: "show me Operations department projects"
Output: {"department": "Operations"}

Query: "Healthcare division projects with fee over 1M"
Output: {"division": "Healthcare", "min_fee": 1000000}

Query: "compare divisions" or "by division"
Output: {"division": null}
EXPLANATION: "by division" means GROUP BY division, NOT a filter for specific division

CRITICAL RULES:
1. "show me", "give me", "list all", "find all", "get me", "display" are COMMANDS, not person names
2. Only extract actual person names that look like real names (e.g., "John Smith", "Mary", "Dr. Jones")
3. Convert fee amounts: 500k = 500000, 1M = 1000000, 50 million = 50000000
4. For win rates, extract the percentage value (e.g., "above 50%" â†’ min_win: 50)
5. Return null for fields not mentioned in the query
6. LIMIT vs TIME PHRASES: NEVER confuse numbers in time phrases with result limits!
   - "last 3 months" â†’ limit: null, time_reference: "last 3 months" (3 is for date calculation)
   - "next 6 weeks" â†’ limit: null, time_reference: "next 6 weeks" (6 is for date calculation)
   - "top 5 projects" â†’ limit: 5 (5 is an explicit result limit)
   - "first 10" â†’ limit: 10 (10 is an explicit result limit)
7. "X REQUEST CATEGORY" PATTERN: When user says "X request category projects", the word BEFORE "request category" is the CATEGORY value, NOT a project_type!
   - "Buildings request category" â†’ category: "Buildings", project_type: null
   - "Transportation request category" â†’ category: "Transportation", project_type: null
   - "Healthcare request category" â†’ category: "Healthcare", project_type: null
   - The word "request" is NOT the category - it's part of the phrase "request category"!
8. AGGREGATION PHRASES: Do NOT extract column names as filter values when used in aggregation context:
   - "by company", "per company", "grouped by company" â†’ company: null (NOT "Company")
   - "by client", "per client", "grouped by client" â†’ client: null
   - "by state", "per state", "grouped by state" â†’ states: null
   - "by category", "per category" â†’ category: null
   - "by division", "per division", "grouped by division" â†’ division: null
   - "by department", "per department", "grouped by department" â†’ department: null
   - "by company" means GROUP BY company, NOT filter for a company named "Company"
   - Only extract company/client/state/division/department when a SPECIFIC name is provided (e.g., "Company A", "Engineering division", "Operations department")
9. "SECTOR" = CATEGORY: The word "sector" is a synonym for "category", NOT "project_type"!
   - "education sector" â†’ category: "Education", project_type: null
   - "healthcare sector" â†’ category: "Healthcare", project_type: null
   - NEVER set both category AND project_type to the same value for sector queries!

User Query: "${userQuestion}"

Return ONLY valid JSON, no explanation.`;

      const response = await this.openaiClient.chat(
        [
          { role: "system", content: "You are a precise entity extraction system. Return only valid JSON." },
          { role: "user", content: extractionPrompt }
        ],
        { model: "gpt-5.1", max_completion_tokens: 500 }
      );

      const content = response?.trim() || "{}";
      const extracted = JSON.parse(content);
      
      const duration = Date.now() - startTime;
      console.log(`[LLM-Extract] âœ… Entity extraction completed in ${duration}ms:`, JSON.stringify(extracted, null, 2));
      
      // Clean up null values and normalize
      const cleaned: Record<string, any> = {};
      for (const [key, value] of Object.entries(extracted)) {
        if (value !== null && value !== undefined) {
          // Convert region to states array - BUT only if question has explicit geographic context
          if (key === 'region' && typeof value === 'string') {
            const regionMap: Record<string, string[]> = {
              'west': ['California', 'Oregon', 'Washington', 'Nevada', 'Arizona', 'Utah', 'Colorado', 'New Mexico', 'Hawaii', 'Alaska', 'Idaho', 'Montana', 'Wyoming'],
              'midwest': ['Illinois', 'Indiana', 'Iowa', 'Kansas', 'Michigan', 'Minnesota', 'Missouri', 'Nebraska', 'North Dakota', 'Ohio', 'South Dakota', 'Wisconsin'],
              'south': ['Alabama', 'Arkansas', 'Delaware', 'Florida', 'Georgia', 'Kentucky', 'Louisiana', 'Maryland', 'Mississippi', 'North Carolina', 'Oklahoma', 'South Carolina', 'Tennessee', 'Texas', 'Virginia', 'West Virginia', 'District of Columbia'],
              'northeast': ['Connecticut', 'Maine', 'Massachusetts', 'New Hampshire', 'New Jersey', 'New York', 'Pennsylvania', 'Rhode Island', 'Vermont'],
              'east': ['Connecticut', 'Delaware', 'Maine', 'Maryland', 'Massachusetts', 'New Hampshire', 'New Jersey', 'New York', 'Pennsylvania', 'Rhode Island', 'Vermont', 'Virginia', 'West Virginia'],
            };
            const regionLower = value.toLowerCase();
            
            // GUARD: For short directional regions (east/west/north/south), require explicit geographic context
            // This prevents "East Orange BOE" from triggering "East" region
            const shortDirectionals = ['east', 'west', 'north', 'south'];
            if (shortDirectionals.includes(regionLower)) {
              const questionLower = (question || '').toLowerCase();
              // Only allow if question has explicit geographic phrasing
              const hasGeographicContext = new RegExp(`\\b(in\\s+the\\s+)${regionLower}\\b|\\b${regionLower}(ern)?\\s+(region|states?|area|coast)\\b`, 'i').test(questionLower);
              if (!hasGeographicContext) {
                console.log(`[LLM-Extract] âš ï¸ BLOCKED region "${value}" - no geographic context in question (likely part of entity name like "East Orange")`);
                // Skip this region - don't set states
              } else if (regionMap[regionLower]) {
                cleaned.region = value; // Query Region column directly
                cleaned._region = regionLower;
              }
            } else if (regionMap[regionLower]) {
              cleaned.region = value; // Query Region column directly
              cleaned._region = regionLower;
            }
          } else if (key === 'person_name') {
            cleaned.poc = value;
          } else if (key === 'year' && typeof value === 'number') {
            cleaned.start_date = `${value}-01-01`;
            cleaned.end_date = `${value}-12-31`;
          } else if (key === 'time_reference' && typeof value === 'string') {
            // Parse time_reference to get start_date/end_date if not already set
            if (!cleaned.start_date && !cleaned.end_date) {
              const dateRange = this.timeParser.parse(value);
              if (dateRange) {
                cleaned.start_date = dateRange[0];
                cleaned.end_date = dateRange[1];
                console.log(`[LLM-Extract] ğŸ“… Parsed time_reference "${value}" â†’ ${dateRange[0]} to ${dateRange[1]}`);
              }
            }
            // Also store the raw time_reference for debugging
            cleaned._time_reference = value;
          } else if (key === 'company' && typeof value === 'string') {
            // POST-EXTRACTION CLEANUP: Reject column names extracted as filter values
            // "Company" alone is not a valid company name - it's the column name
            const invalidCompanyValues = ['company', 'companies', 'opco', 'opcos'];
            if (!invalidCompanyValues.includes(value.toLowerCase())) {
              cleaned[key] = value;
            } else {
              console.log(`[LLM-Extract] âš ï¸ Rejected invalid company value: "${value}" (column name, not filter)`);
            }
          } else if (key === 'client' && typeof value === 'string') {
            // Same for client column
            const invalidClientValues = ['client', 'clients', 'customer', 'customers'];
            if (!invalidClientValues.includes(value.toLowerCase())) {
              cleaned[key] = value;
            } else {
              console.log(`[LLM-Extract] âš ï¸ Rejected invalid client value: "${value}" (column name, not filter)`);
            }
          } else {
            cleaned[key] = value;
          }
        }
      }
      
      // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
      // POST-EXTRACTION VALIDATION: Verify extracted entities are reasonable
      // This catches LLM errors before they cause SQL issues
      // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
      
      // Validate fee values - should be positive numbers
      if (cleaned.min_fee && (cleaned.min_fee < 0 || cleaned.min_fee > 100000000000)) {
        console.log(`[LLM-Extract] âš ï¸ Invalid min_fee ${cleaned.min_fee}, removing`);
        delete cleaned.min_fee;
      }
      if (cleaned.max_fee && (cleaned.max_fee < 0 || cleaned.max_fee > 100000000000)) {
        console.log(`[LLM-Extract] âš ï¸ Invalid max_fee ${cleaned.max_fee}, removing`);
        delete cleaned.max_fee;
      }
      
      // Validate win rate values - should be 0-100
      if (cleaned.min_win && (cleaned.min_win < 0 || cleaned.min_win > 100)) {
        console.log(`[LLM-Extract] âš ï¸ Invalid min_win ${cleaned.min_win}, removing`);
        delete cleaned.min_win;
      }
      if (cleaned.max_win && (cleaned.max_win < 0 || cleaned.max_win > 100)) {
        console.log(`[LLM-Extract] âš ï¸ Invalid max_win ${cleaned.max_win}, removing`);
        delete cleaned.max_win;
      }
      
      // Validate and normalize date formats - accept YYYY-MM-DD or ISO 8601
      const normalizeDateString = (dateStr: string): string | null => {
        if (!dateStr) return null;
        // Already in YYYY-MM-DD format
        if (/^\d{4}-\d{2}-\d{2}$/.test(dateStr)) return dateStr;
        // ISO 8601 format (e.g., "2025-01-01T00:00:00Z") - extract date part
        const isoMatch = dateStr.match(/^(\d{4}-\d{2}-\d{2})/);
        if (isoMatch) return isoMatch[1];
        // Try to parse as Date object
        try {
          const parsed = new Date(dateStr);
          if (!isNaN(parsed.getTime())) {
            return parsed.toISOString().split('T')[0];
          }
        } catch (e) {}
        return null;
      };
      
      if (cleaned.start_date) {
        const normalized = normalizeDateString(cleaned.start_date);
        if (normalized) {
          cleaned.start_date = normalized;
        } else {
          console.log(`[LLM-Extract] âš ï¸ Invalid start_date format ${cleaned.start_date}, removing`);
          delete cleaned.start_date;
        }
      }
      if (cleaned.end_date) {
        const normalized = normalizeDateString(cleaned.end_date);
        if (normalized) {
          cleaned.end_date = normalized;
        } else {
          console.log(`[LLM-Extract] âš ï¸ Invalid end_date format ${cleaned.end_date}, removing`);
          delete cleaned.end_date;
        }
      }
      
      // Validate year - should be reasonable (1990-2050)
      if (cleaned.year && (cleaned.year < 1990 || cleaned.year > 2050)) {
        console.log(`[LLM-Extract] âš ï¸ Invalid year ${cleaned.year}, removing`);
        delete cleaned.year;
      }
      
      // Validate limit - should be positive and reasonable
      if (cleaned.limit && (cleaned.limit < 1 || cleaned.limit > 10000)) {
        console.log(`[LLM-Extract] âš ï¸ Invalid limit ${cleaned.limit}, removing`);
        delete cleaned.limit;
      }
      
      // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
      // DETERMINISTIC NORMALIZATION: Ensure state abbreviations are expanded
      // This catches cases where LLM returns "CA" instead of "California"
      // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
      const stateAbbreviations: Record<string, string> = {
        'AL': 'Alabama', 'AK': 'Alaska', 'AZ': 'Arizona', 'AR': 'Arkansas',
        'CA': 'California', 'CO': 'Colorado', 'CT': 'Connecticut', 'DE': 'Delaware',
        'FL': 'Florida', 'GA': 'Georgia', 'HI': 'Hawaii', 'ID': 'Idaho',
        'IL': 'Illinois', 'IN': 'Indiana', 'IA': 'Iowa', 'KS': 'Kansas',
        'KY': 'Kentucky', 'LA': 'Louisiana', 'ME': 'Maine', 'MD': 'Maryland',
        'MA': 'Massachusetts', 'MI': 'Michigan', 'MN': 'Minnesota', 'MS': 'Mississippi',
        'MO': 'Missouri', 'MT': 'Montana', 'NE': 'Nebraska', 'NV': 'Nevada',
        'NH': 'New Hampshire', 'NJ': 'New Jersey', 'NM': 'New Mexico', 'NY': 'New York',
        'NC': 'North Carolina', 'ND': 'North Dakota', 'OH': 'Ohio', 'OK': 'Oklahoma',
        'OR': 'Oregon', 'PA': 'Pennsylvania', 'RI': 'Rhode Island', 'SC': 'South Carolina',
        'SD': 'South Dakota', 'TN': 'Tennessee', 'TX': 'Texas', 'UT': 'Utah',
        'VT': 'Vermont', 'VA': 'Virginia', 'WA': 'Washington', 'WV': 'West Virginia',
        'WI': 'Wisconsin', 'WY': 'Wyoming', 'DC': 'District of Columbia'
      };
      
      if (cleaned.states && Array.isArray(cleaned.states)) {
        cleaned.states = cleaned.states.map((state: string) => {
          const upper = state.toUpperCase();
          if (stateAbbreviations[upper]) {
            console.log(`[LLM-Extract] ğŸ“ Normalized state "${state}" â†’ "${stateAbbreviations[upper]}"`);
            return stateAbbreviations[upper];
          }
          return state;
        });
      }
      
      // Also normalize state_code if it was extracted
      if (cleaned.state_code && typeof cleaned.state_code === 'string') {
        const upper = cleaned.state_code.toUpperCase();
        if (stateAbbreviations[upper]) {
          // Convert state_code to states array
          if (!cleaned.states) {
            cleaned.states = [stateAbbreviations[upper]];
          } else if (!cleaned.states.includes(stateAbbreviations[upper])) {
            cleaned.states.push(stateAbbreviations[upper]);
          }
          console.log(`[LLM-Extract] ğŸ“ Converted state_code "${cleaned.state_code}" â†’ states: ["${stateAbbreviations[upper]}"]`);
          delete cleaned.state_code;
        }
      }
      
      console.log(`[LLM-Extract] âœ… Final validated entities:`, JSON.stringify(cleaned, null, 2));
      
      return cleaned;
      
    } catch (error) {
      console.error(`[LLM-Extract] âŒ Entity extraction failed:`, error);
      // Return empty object on failure - will fall back to regex
      return {};
    }
  }

  /**
   * HYBRID APPROACH: Pre-extract query context using regex patterns
   * These extracted hints are passed TO the LLM for better classification
   * Kept for: project_type keywords, fee patterns, status, regions (reliable regex)
   * Removed: POC extraction (now handled by LLM)
   */
  extractQueryContext(userQuestion: string): Record<string, any> {
    const extractedContext: Record<string, any> = {};
    const questionLower = userQuestion.toLowerCase();
    
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    // 0. MODULE CONTEXT DETECTION (must run BEFORE project_type extraction)
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    // Detect if user is asking about modules (Opportunities, Tracked Work, Construction)
    // When these are mentioned together, "Construction" is a MODULE value, not a project_type
    const hasOpportunities = /\b(opportunities?|oppurtunities?)\b/i.test(userQuestion);
    const hasTrackedWork = /\btracked\s*work\b/i.test(userQuestion);
    const hasConstruction = /\bconstruction\b/i.test(userQuestion);
    // Also detect explicit "module" word - e.g., "list all opportunities module", "tracked work module"
    const hasExplicitModuleWord = /\bmodule[s]?\b/i.test(userQuestion);
    console.log(`[ExtractContext] ğŸ” MODULE DETECTION: hasOpportunities=${hasOpportunities}, hasTrackedWork=${hasTrackedWork}, hasConstruction=${hasConstruction}, hasExplicitModuleWord=${hasExplicitModuleWord}, question="${userQuestion}"`);
    const hasModuleContext = (hasOpportunities && hasConstruction) || 
                             (hasTrackedWork && hasConstruction) ||
                             (hasOpportunities && hasTrackedWork) ||
                             (/\b(across|between|compare|breakdown|summarize|aggregate)\b/i.test(userQuestion) && 
                              (hasOpportunities || hasTrackedWork || hasConstruction)) ||
                             // NEW: Explicit "module" word + any module name triggers module filtering
                             (hasExplicitModuleWord && (hasOpportunities || hasTrackedWork || hasConstruction));
    
    if (hasModuleContext) {
      const detectedModules: string[] = [];
      if (hasOpportunities) detectedModules.push('Opportunity');  // DB value is singular
      if (hasTrackedWork) detectedModules.push('Tracked Work');
      if (hasConstruction) detectedModules.push('Construction');
      extractedContext._module_context = true;
      extractedContext.modules = detectedModules;
      console.log(`[ExtractContext] ğŸ“¦ MODULE CONTEXT DETECTED: ${detectedModules.join(', ')} â†’ suppressing project_type extraction for "construction"`);
      // FILE TRACE FOR DEBUGGING
    }

    
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    // 1. PROJECT TYPE EXTRACTION
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    // IMPORTANT: If user explicitly mentions "request category", "category", or "sector",
    // we should NOT map keywords to project_type. Instead, let the LLM extract the 
    // category and use Request Category column directly.
    const usesExplicitCategoryWord = /\b(request\s*category|category|sector)\b/i.test(questionLower);
    
    if (usesExplicitCategoryWord) {
      console.log(`[ExtractContext] ğŸ“ User mentioned "category/sector" - skipping project_type mapping, will use Request Category column`);
      // Set flag to prevent safety net from moving categories to project_type
      extractedContext._explicit_category = true;
    } else {
      const KEYWORD_TO_PROJECT_TYPE: Record<string, string> = {
        'airport': 'Airports', 'airports': 'Airports', 'aviation': 'Airports',
        'bridge': 'Bridges', 'bridges': 'Bridges',
    'road': 'Road/Highway', 'roads': 'Road/Highway', 'highway': 'Road/Highway', 'highways': 'Road/Highway', 'road/highway': 'Road/Highway', 'transportation': 'Transportation',
        'hospital': 'Hospitals', 'hospitals': 'Hospitals',
        'healthcare': 'Hospitals', 'medical': 'Medical Buildings',
        'higher education': 'Higher Education', 'university': 'Higher Education', 'universities': 'Higher Education', 'college': 'Higher Education',
        'k-12': 'K-12', 'school': 'K-12', 'schools': 'K-12', 'elementary': 'K-12', 'high school': 'K-12',
        'transit': 'Transit', 'rail': 'Transit', 'railway': 'Transit', 'subway': 'Transit',
        'waterfront': 'Waterfront', 'port': 'Waterfront', 'marina': 'Waterfront',
        'corrections': 'Corrections', 'prison': 'Corrections', 'jail': 'Corrections',
        'civic': 'Civic', 'city hall': 'Civic', 'courthouse': 'Civic',
        'government': 'Government', 'governmental': 'Government', 'gov': 'Government', 'govt': 'Government',
        'energy': 'Energy', 'solar': 'Energy: Renewable', 'renewable': 'Energy: Renewable',
        'power plant': 'Energy/Power Plants', 'power plants': 'Energy/Power Plants',
        'hotel': 'HO - Hospitality/Hotel', 'hotels': 'HO - Hospitality/Hotel', 'hospitality': 'Hospitality',
        'industrial': 'Industrial', 'manufacturing': 'Industrial', 'warehouse': 'Industrial',
        'mixed use': 'Mixed Use', 'mixed-use': 'Mixed Use',
        'multi-family': 'Multi-Family', 'multifamily': 'Multi-Family', 'apartment': 'Multi-Family',
        'office': 'Office', 'commercial office': 'Office',
        'parking': 'Parking', 'parking garage': 'Parking', 'parking structure': 'Parking',
        'retail': 'Retail', 'shopping': 'Retail', 'mall': 'Retail',
        'sports': 'Sports', 'stadium': 'Sports', 'arena': 'Sports',
        'water': 'Water/Wastewater', 'wastewater': 'Water/Wastewater',
        'sewer': 'Water/Wastewater',
      };
      
      for (const [keyword, projectType] of Object.entries(KEYWORD_TO_PROJECT_TYPE)) {
        const regex = new RegExp(`\\b${keyword}\\b`, 'i');
        if (regex.test(questionLower)) {
          // SKIP construction keywords when module context is detected
          if (extractedContext._module_context && keyword.toLowerCase() === 'construction') {
            console.log(`[ExtractContext] â­ï¸ Skipping "construction" project_type - module context active`);
            continue;
          }
          extractedContext.project_type = projectType;
          extractedContext._project_type_keyword = keyword;
          console.log(`[ExtractContext] ğŸ—ï¸ Detected project type: "${keyword}" â†’ "${projectType}"`);
          break;
        }
      }
    }
    
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    // 2. FEE/BUDGET EXTRACTION
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    
    // SKIP fee extraction if question mentions win rate - prevents "win rate above 50" confusion
    const hasWinRateContext = /\b(?:win\s*%|win\s+rate|win\s+percentage|success\s+rate|probability)\b/i.test(questionLower);
    
    const feePatterns = [
      // "budget above $50M", "fee greater than 100 million" (accepts "then" typo)
      /(?:budget|fee|cost|revenue|value|price)\s*(?:above|over|greater\s+th[ae]n|more\s+th[ae]n|>=?|exceeding|at\s+least)\s*\$?([\d,]+(?:\.\d+)?)\s*(million|m|k|thousand|b|billion)?/i,
      // "above $50M budget" - REQUIRES $ sign AND optional keyword at END
      /(?:above|over|greater\s+th[ae]n|more\s+th[ae]n|>=?)\s*\$([\d,]+(?:\.\d+)?)\s*(million|m|k|thousand|b|billion)?\s*(?:budget|fee|cost|revenue|value)?/i,
      // "above 100 million" - requires million/m/b/billion suffix (explicit currency scale)
      /(?:above|over|greater\s+th[ae]n|more\s+th[ae]n|>=?)\s*([\d,]+(?:\.\d+)?)\s*(million|m|billion|b)\s*(?:budget|fee|cost|revenue|value)?/i,
      // "projects with budget above $50M"
      /(?:with|having)\s+(?:budget|fee|cost|revenue|value)\s+(?:above|over|greater\s+th[ae]n|more\s+th[ae]n)\s*\$?([\d,]+(?:\.\d+)?)\s*(million|m|k|thousand|b|billion)?/i,
    ];
    
    if (!hasWinRateContext) {
      for (const pattern of feePatterns) {
        const match = userQuestion.match(pattern);
        if (match) {
          let value = parseFloat(match[1].replace(/,/g, ''));
          const suffix = (match[2] || '').toLowerCase();
          if (suffix === 'billion' || suffix === 'b') value *= 1000000000;
          else if (suffix === 'million' || suffix === 'm') value *= 1000000;
          else if (suffix === 'thousand' || suffix === 'k') value *= 1000;
          // Only multiply by 1M if there's an explicit suffix OR explicit $ sign
          else if (value < 1000 && userQuestion.includes('$')) value *= 1000000;
          
          extractedContext.min_fee = value;
          console.log(`[ExtractContext] ğŸ’° Detected min_fee: $${value.toLocaleString()}`);
          break;
        }
      }
    }
    
    // NOTE: Size keywords (mega, large, small, etc.) are now handled dynamically
    // by the percentile-based size calculation system. We do NOT hardcode min_fee/max_fee
    // values here - the LLM extracts "size" parameter and the query executor uses
    // real data percentiles to determine size categories.
    
    // Max fee patterns - CRITICAL: All patterns MUST require explicit fee/cost/budget keywords
    // to prevent "win rate below 10" from being misinterpreted as fee < @p10M
    const maxFeePatterns = [
      // "budget below $50M", "fee less than 100 million" - keyword at START (accepts "then" typo)
      /(?:budget|fee|cost|revenue|value|price)\s*(?:below|under|less\s+th[ae]n|<=?|at\s+most)\s*\$?([\d,]+(?:\.\d+)?)\s*(million|m|k|thousand|b|billion)?/i,
      // "below $50M budget" - REQUIRES $ sign AND optional keyword at END
      /(?:below|under|less\s+th[ae]n|<=?)\s*\$([\d,]+(?:\.\d+)?)\s*(million|m|k|thousand|b|billion)?\s*(?:budget|fee|cost|revenue|value)?/i,
      // "below 100 million budget" - REQUIRES million/m/b/billion suffix (explicit currency scale)
      /(?:below|under|less\s+th[ae]n|<=?)\s*([\d,]+(?:\.\d+)?)\s*(million|m|billion|b)\s*(?:budget|fee|cost|revenue|value)?/i,
    ];
    
    // Use the same hasWinRateContext check from above for max_fee
    if (!hasWinRateContext) {
      for (const pattern of maxFeePatterns) {
        const match = userQuestion.match(pattern);
        if (match) {
          let value = parseFloat(match[1].replace(/,/g, ''));
          const suffix = (match[2] || '').toLowerCase();
          if (suffix === 'billion' || suffix === 'b') value *= 1000000000;
          else if (suffix === 'million' || suffix === 'm') value *= 1000000;
          else if (suffix === 'thousand' || suffix === 'k') value *= 1000;
          // Only multiply by 1M if there's an explicit suffix OR explicit $ sign
          else if (value < 1000 && userQuestion.includes('$')) value *= 1000000;
          
          extractedContext.max_fee = value;
          console.log(`[ExtractContext] ğŸ’° Detected max_fee: $${value.toLocaleString()}`);
          break;
        }
      }
    } else {
      console.log(`[ExtractContext] âš ï¸ Skipping fee extraction - question mentions win rate`);
    }
    
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    // 3. STATUS EXTRACTION
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    const statusValues = ['Lead', 'Qualified Lead', 'Unqualified', 'Pursue', 'Won', 'Lost', 'No-Go', 'Closed', 'Submitted', 'In Progress', 'Proposal Development', 'Hold'];
    for (const status of statusValues) {
      const regex = new RegExp(`\\b${status}\\b`, 'i');
      if (regex.test(userQuestion)) {
        extractedContext.status = status;
        console.log(`[ExtractContext] ğŸ“Š Detected status: "${status}"`);
        break;
      }
    }
    
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    // 4. POC/SALES REP EXTRACTION - NOW HANDLED BY LLM
    // Removed regex-based POC extraction - the LLM extractEntitiesWithLLM()
    // method now handles POC extraction more accurately, avoiding false
    // positives like "show me", "give me", etc.
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    // 5. STATE/REGION EXTRACTION
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    const statePatterns = [
      /\b(?:in|from|for)\s+(California|Texas|Florida|New York|Illinois|Pennsylvania|Ohio|Georgia|North Carolina|Michigan|New Jersey|Virginia|Washington|Arizona|Massachusetts|Tennessee|Indiana|Maryland|Minnesota|Wisconsin|Colorado|Missouri|South Carolina|Alabama|Louisiana|Kentucky|Oregon|Oklahoma|Connecticut|Utah|Iowa|Nevada|Arkansas|Mississippi|Kansas|New Mexico|Nebraska|Hawaii|West Virginia|Idaho|Maine|Montana|Rhode Island|Delaware|South Dakota|North Dakota|Alaska|Vermont|Wyoming|District of Columbia)\b/i,
    ];
    
    for (const pattern of statePatterns) {
      const match = userQuestion.match(pattern);
      if (match && match[1]) {
        extractedContext.states = [match[1]];
        console.log(`[ExtractContext] ğŸ“ Detected state: "${match[1]}"`);
        break;
      }
    }
    
    // Region detection
    const regionMap: Record<string, string[]> = {
      'west': ['California', 'Oregon', 'Washington', 'Nevada', 'Arizona', 'Utah', 'Colorado', 'New Mexico', 'Hawaii', 'Alaska', 'Idaho', 'Montana', 'Wyoming'],
      'midwest': ['Illinois', 'Indiana', 'Iowa', 'Kansas', 'Michigan', 'Minnesota', 'Missouri', 'Nebraska', 'North Dakota', 'Ohio', 'South Dakota', 'Wisconsin'],
      'south': ['Alabama', 'Arkansas', 'Delaware', 'Florida', 'Georgia', 'Kentucky', 'Louisiana', 'Maryland', 'Mississippi', 'North Carolina', 'Oklahoma', 'South Carolina', 'Tennessee', 'Texas', 'Virginia', 'West Virginia', 'District of Columbia'],
      'northeast': ['Connecticut', 'Maine', 'Massachusetts', 'New Hampshire', 'New Jersey', 'New York', 'Pennsylvania', 'Rhode Island', 'Vermont'],
      'east': ['Connecticut', 'Delaware', 'Maine', 'Maryland', 'Massachusetts', 'New Hampshire', 'New Jersey', 'New York', 'Pennsylvania', 'Rhode Island', 'Vermont', 'Virginia', 'West Virginia'],
    };
    
    // Region aliases: "north" â†’ "northeast" (removed "central" â†’ "midwest" since Central is a valid Region value)
    const regionAliases: Record<string, string> = {
      'north': 'northeast',
      'northern': 'northeast',
      // Geographic aliases for MENA region
      'uae': 'MENA',
      'united arab emirates': 'MENA',
      'middle east': 'MENA',
      'gulf': 'MENA',
      'gulf region': 'MENA',
      'abu dhabi': 'MENA',
      'dubai': 'MENA',
      // US region aliases
      'west coast': 'West',
      'pacific': 'West',
      'east coast': 'East',
      'atlantic': 'East',
      'midwest': 'Central',
      'central us': 'Central',
      // International aliases
      'asia': 'Central Asia',
      'hong kong': 'Hong Kong',
      'hk': 'Hong Kong',
    };
    
    // Short directional words that need explicit geographic context
    const shortDirectionals = ['east', 'west', 'north', 'south'];
    
    for (const [region, states] of Object.entries(regionMap)) {
      let regex: RegExp;
      
      if (shortDirectionals.includes(region)) {
        // For short directional words: REQUIRE geographic suffix OR "in the" prefix
        // Prevents "East Orange", "West Point", etc. from triggering region detection
        // Must match: "east region", "eastern region", "in the east", "east coast"
        // Must NOT match: "East Orange", "East Side", "West Point"
        regex = new RegExp(`\\b(in\\s+the\\s+)${region}\\b|\\b${region}(ern)?\\s+(region|states?|area|coast)\\b`, 'i');
      } else {
        // For compound regions like "northeast", "midwest" - these are unambiguous
        regex = new RegExp(`\\b${region}(?:ern)?\\s*(?:region|states?|area)?\\b`, 'i');
      }
      
      if (regex.test(questionLower) && !extractedContext.region) {
        extractedContext.region = region; // Query Region column directly
        extractedContext._region = region;
        console.log(`[ExtractContext] ğŸ“ Detected region: "${region}" â†’ ${states.length} states`);
        break;
      }
    }
    
    // Check for region aliases if no region found yet
    if (!extractedContext.region) {
      for (const [alias, targetRegion] of Object.entries(regionAliases)) {
        const regex = new RegExp(`\\b${alias}\\s*(?:region|states?|area)?\\b`, 'i');
        if (regex.test(questionLower)) {
          const states = regionMap[targetRegion];
          if (states) {
            extractedContext.region = targetRegion; // Query Region column directly
            extractedContext._region = targetRegion;
            console.log(`[ExtractContext] ğŸ“ Detected region alias: "${alias}" â†’ "${targetRegion}" â†’ ${states.length} states`);
            break;
          }
        }
      }
    }
    
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    // 6. COMPANY EXTRACTION
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    const companyPatterns = [
      /\b(?:from|by|for|at)\s+(Company\s+[A-Za-z]+)\b/i,
      /\b(Company\s+[A-Za-z]+)\b/i,
    ];
    
    for (const pattern of companyPatterns) {
      const match = userQuestion.match(pattern);
      if (match && match[1]) {
        extractedContext.company = match[1].trim();
        console.log(`[ExtractContext] ğŸ¢ Detected company: "${extractedContext.company}"`);
        break;
      }
    }
    
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    // 7. LIMIT EXTRACTION (top N, first N, etc.)
    // NOTE: Must NOT match time phrases like "last 3 months", "next 6 weeks"
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    // First, check if this is a time phrase (last/next N months/weeks/days/years)
    const isTimePhrase = /\b(?:last|next|past|previous)\s+\d+\s*(?:months?|weeks?|days?|years?|quarters?)\b/i.test(userQuestion);
    
    // Only extract limit if NOT a time phrase
    const limitMatch = !isTimePhrase ? userQuestion.match(/\b(?:top|first|bottom|largest|smallest)\s+(\d+)\b/i) : null;
    // Separate pattern for "last N" that requires it to NOT be followed by time units
    const lastNMatch = !isTimePhrase ? userQuestion.match(/\blast\s+(\d+)(?!\s*(?:months?|weeks?|days?|years?|quarters?))\b/i) : null;
    
    if (limitMatch) {
      extractedContext.limit = parseInt(limitMatch[1], 10);
      console.log(`[ExtractContext] ğŸ”¢ Detected limit: ${extractedContext.limit}`);
    } else if (lastNMatch) {
      extractedContext.limit = parseInt(lastNMatch[1], 10);
      console.log(`[ExtractContext] ğŸ”¢ Detected limit from 'last N': ${extractedContext.limit}`);
    } else if (/\b(?:the\s+)?(?:maximum|max|most|highest|best|largest|lowest|minimum|min|smallest|top|first)\b/i.test(questionLower)) {
      // Superlative implies limit=1
      extractedContext.limit = 1;
      extractedContext._superlative = true;
      console.log(`[ExtractContext] ğŸ”¢ Superlative detected - implied limit: 1`);
    }
    
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    // 8. WIN RATE EXTRACTION
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    const minWinMatch = userQuestion.match(/(?:win\s*%?|win\s+rate|success\s+rate)\s*(?:above|over|greater\s+than|more\s+than|>=?|at\s+least)\s*(\d+)\s*%?/i);
    if (minWinMatch) {
      extractedContext.min_win = parseInt(minWinMatch[1], 10);
      console.log(`[ExtractContext] ğŸ“ˆ Detected min_win: ${extractedContext.min_win}%`);
    }
    
    const maxWinMatch = userQuestion.match(/(?:win\s*%?|win\s+rate|success\s+rate)\s*(?:below|under|less\s+than|<=?|at\s+most)\s*(\d+)\s*%?/i);
    if (maxWinMatch) {
      extractedContext.max_win = parseInt(maxWinMatch[1], 10);
      console.log(`[ExtractContext] ğŸ“ˆ Detected max_win: ${extractedContext.max_win}%`);
    }
    
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    // 9. DATE/YEAR EXTRACTION
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    const yearMatch = userQuestion.match(/\b(?:in|for|during|from|starting|year)\s*(\d{4})\b/i);
    if (yearMatch) {
      const year = yearMatch[1];
      extractedContext.start_date = `${year}-01-01`;
      extractedContext.end_date = `${year}-12-31`;
      console.log(`[ExtractContext] ğŸ“… Detected year: ${year} â†’ ${extractedContext.start_date} to ${extractedContext.end_date}`);
    }
    
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    // 10. CATEGORY/SECTOR EXTRACTION
    // Maps "education sector", "healthcare industry" to Request Category
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    const categoryMap: Record<string, string> = {
      'education': 'Education',
      'healthcare': 'Healthcare',
      'transportation': 'Transportation',
      'aviation': 'Aviation',
      'commercial': 'Commercial',
      'corporate': 'Corporate',
      'civic': 'Civic',
      'entertainment': 'Entertainment',
      'energy': 'Energy',
      'corrections': 'Corrections',
      'cultural': 'Cultural',
      'industrial': 'Industrial',
      'mixed use': 'Mixed Use',
      'multifamily': 'Multifamily',
      'residential': 'Residential',
      'sports': 'Sports',
      'waterfront': 'Waterfront',
      'hospitality': 'Hospitality',
      'water': 'Water',
      'buildings': 'Buildings',
    };
    
    // Match patterns like "education sector", "in the healthcare industry", "from transportation"
    const sectorPatterns = [
      /\b(education|healthcare|transportation|aviation|commercial|corporate|civic|entertainment|energy|corrections|cultural|industrial|mixed\s*use|multifamily|residential|sports|waterfront|hospitality|water|buildings)\s+(?:sector|industry|field|area|domain)\b/i,
      /\bin\s+(?:the\s+)?(education|healthcare|transportation|aviation|commercial|corporate|civic|entertainment|energy|corrections|cultural|industrial|mixed\s*use|multifamily|residential|sports|waterfront|hospitality|water|buildings)(?:\s+sector|\s+industry)?\b/i,
      /\b(?:from|for|in)\s+(?:the\s+)?(education|healthcare|transportation|aviation|commercial|corporate|civic|entertainment|energy|corrections|cultural|industrial|mixed\s*use|multifamily|residential|sports|waterfront|hospitality|water|buildings)\b/i,
    ];
    
    for (const pattern of sectorPatterns) {
      const match = userQuestion.match(pattern);
      if (match && match[1]) {
        const categoryKey = match[1].toLowerCase().replace(/\s+/g, ' ');
        const category = categoryMap[categoryKey];
        if (category) {
          extractedContext.category = category;
          console.log(`[ExtractContext] ğŸ“ Detected category: "${category}" from "${match[0]}"`);
          break;
        }
      }
    }
    
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    // 11. MULTI-VALUE DIVISION/DEPARTMENT EXTRACTION
    // Handles: "X and Y divisions", "X and Y departments", "X division and Y department"
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    
    // Multi-value extraction is only valid in these cases:
    // A) PLURAL form: "X and Y divisions" / "X and Y departments" 
    // B) REPEATED keyword form: "X division and Y division" / "X department and Y department"
    // C) COMMA-SEPARATED with plural: "X, Y, and Z divisions" / "X, Y, and Z departments"
    // DO NOT split compound names like "Research and Development division" (singular, no repeated keyword)
    
    // Helper function to parse comma-and-separated lists: "A, B, and C" â†’ ["A", "B", "C"]
    const parseCommaSeparatedList = (listStr: string): string[] => {
      // Handle "A, B, and C" or "A, B and C" or "A and B" formats
      // First normalize: replace ", and " with "," and " and " with ","
      let normalized = listStr
        .replace(/,\s*and\s+/gi, ',')  // "A, and B" â†’ "A,B"
        .replace(/\s+and\s+/gi, ',');   // "A and B" â†’ "A,B"
      
      // Split by comma and clean up each part
      const parts = normalized.split(/,/)
        .map(p => p.trim())
        .filter(p => p.length > 0);
      
      return parts;
    };
    
    // Pattern A: Plural form - "projects in SCM and Architecture divisions"
    // Also handles: "projects in A, B, and C divisions"
    const multiDivisionPluralMatch = userQuestion.match(
      /(?:in|from|for|assigned\s+to|related\s+to)\s+(?:the\s+)?(.+?)\s+divisions(?:\s|$|,|\?)/i
    );
    // Pattern B: Repeated keyword form - "projects in SCM division and Architecture division"
    const multiDivisionRepeatedMatch = userQuestion.match(
      /(?:in|from|for|assigned\s+to|related\s+to)\s+(?:the\s+)?(.+?)\s+division\s+and\s+(.+?)\s+division(?:\s|$|,|\?)/i
    );
    
    if (multiDivisionRepeatedMatch && multiDivisionRepeatedMatch[1] && multiDivisionRepeatedMatch[2]) {
      // Repeated keyword form - extract two values
      let div1 = multiDivisionRepeatedMatch[1].trim().replace(/\s+divisions?$/i, '').trim();
      let div2 = multiDivisionRepeatedMatch[2].trim().replace(/\s+divisions?$/i, '').trim();
      if (!div1.match(/\b(with|where|having|fee|above|below|over|under|this|year|starting)\b/i) &&
          !div2.match(/\b(with|where|having|fee|above|below|over|under|this|year|starting)\b/i) &&
          div1.length > 0 && div2.length > 0) {
        extractedContext.divisions = [div1, div2];
        console.log(`[ExtractContext] ğŸ¢ Multi-division (repeated keyword): ["${div1}", "${div2}"]`);
      }
    } else if (multiDivisionPluralMatch && multiDivisionPluralMatch[1]) {
      // Plural form - parse comma-separated list
      const listStr = multiDivisionPluralMatch[1].trim();
      const divisions = parseCommaSeparatedList(listStr);
      // Only treat as multi-division if we get 2+ values
      if (divisions.length >= 2) {
        // Validate all parts
        const validDivisions = divisions.filter(d => 
          !d.match(/\b(with|where|having|fee|above|below|over|under|this|year|starting)\b/i) &&
          d.length > 0
        );
        if (validDivisions.length >= 2) {
          extractedContext.divisions = validDivisions;
          console.log(`[ExtractContext] ğŸ¢ Multi-division (plural form): ${JSON.stringify(validDivisions)}`);
        }
      }
    }
    
    // Pattern A: Plural form - "projects in IT and HR departments"
    // Also handles: "projects in A, B, and C departments"
    const multiDeptPluralMatch = userQuestion.match(
      /(?:in|from|for|assigned\s+to|related\s+to)\s+(?:the\s+)?(.+?)\s+departments(?:\s|$|,|\?)/i
    );
    // Pattern B: Repeated keyword form - "projects in IT department and HR department"
    const multiDeptRepeatedMatch = userQuestion.match(
      /(?:in|from|for|assigned\s+to|related\s+to)\s+(?:the\s+)?(.+?)\s+department\s+and\s+(.+?)\s+department(?:\s|$|,|\?)/i
    );
    
    if (multiDeptRepeatedMatch && multiDeptRepeatedMatch[1] && multiDeptRepeatedMatch[2]) {
      // Repeated keyword form - extract two values
      let dept1 = multiDeptRepeatedMatch[1].trim().replace(/\s+departments?$/i, '').trim();
      let dept2 = multiDeptRepeatedMatch[2].trim().replace(/\s+departments?$/i, '').trim();
      if (!dept1.match(/\b(with|where|having|fee|above|below|over|under|this|year|starting)\b/i) &&
          !dept2.match(/\b(with|where|having|fee|above|below|over|under|this|year|starting)\b/i) &&
          dept1.length > 0 && dept2.length > 0) {
        extractedContext.departments = [dept1, dept2];
        console.log(`[ExtractContext] ğŸ¢ Multi-department (repeated keyword): ["${dept1}", "${dept2}"]`);
      }
    } else if (multiDeptPluralMatch && multiDeptPluralMatch[1]) {
      // Plural form - parse comma-separated list
      const listStr = multiDeptPluralMatch[1].trim();
      const departments = parseCommaSeparatedList(listStr);
      // Only treat as multi-department if we get 2+ values
      if (departments.length >= 2) {
        // Validate all parts
        const validDepts = departments.filter(d => 
          !d.match(/\b(with|where|having|fee|above|below|over|under|this|year|starting)\b/i) &&
          d.length > 0
        );
        if (validDepts.length >= 2) {
          extractedContext.departments = validDepts;
          console.log(`[ExtractContext] ğŸ¢ Multi-department (plural form): ${JSON.stringify(validDepts)}`);
        }
      }
    }
    
    // Pattern: "projects in X division and Y department" - COMBINATION of division AND department
    // Also handles "projects assigned to X division and Y department"
    const divDeptComboMatch = userQuestion.match(
      /(?:in|from|for|assigned\s+to|related\s+to)\s+(?:the\s+)?([\w\s:\-&]+?)\s+division\s+and\s+([\w\s:\-&]+?)\s+department/i
    );
    if (divDeptComboMatch && divDeptComboMatch[1] && divDeptComboMatch[2]) {
      extractedContext.division = divDeptComboMatch[1].trim();
      extractedContext.department = divDeptComboMatch[2].trim();
      // Clear any array forms that might have been set
      delete extractedContext.divisions;
      delete extractedContext.departments;
      console.log(`[ExtractContext] ğŸ¢ Division + Department combo: division="${extractedContext.division}", department="${extractedContext.department}"`);
    }
    
    // Reverse pattern: "projects in X department and Y division"
    const deptDivComboMatch = userQuestion.match(
      /(?:in|from|for|assigned\s+to|related\s+to)\s+(?:the\s+)?([\w\s:\-&]+?)\s+department\s+and\s+([\w\s:\-&]+?)\s+division/i
    );
    if (deptDivComboMatch && deptDivComboMatch[1] && deptDivComboMatch[2]) {
      extractedContext.department = deptDivComboMatch[1].trim();
      extractedContext.division = deptDivComboMatch[2].trim();
      // Clear any array forms that might have been set
      delete extractedContext.divisions;
      delete extractedContext.departments;
      console.log(`[ExtractContext] ğŸ¢ Department + Division combo: department="${extractedContext.department}", division="${extractedContext.division}"`);
    }
    
    // Single division extraction (if not already multi-detected)
    if (!extractedContext.division && !extractedContext.divisions) {
      const singleDivMatch = userQuestion.match(
        /(?:in|from|for|assigned\s+to|related\s+to)\s+(?:the\s+)?([\w\s:\-&]+?)\s+division/i
      );
      if (singleDivMatch && singleDivMatch[1]) {
        extractedContext.division = singleDivMatch[1].trim();
        console.log(`[ExtractContext] ğŸ¢ Single division detected: "${extractedContext.division}"`);
      }
    }
    
    // Single department extraction (if not already multi-detected or combo-detected)
    if (!extractedContext.department && !extractedContext.departments) {
      const singleDeptMatch = userQuestion.match(
        /(?:in|from|for|assigned\s+to|related\s+to)\s+(?:the\s+)?([\w\s:\-&]+?)\s+department/i
      );
      if (singleDeptMatch && singleDeptMatch[1]) {
        extractedContext.department = singleDeptMatch[1].trim();
        console.log(`[ExtractContext] ğŸ¢ Single department detected: "${extractedContext.department}"`);
      }
    }
    
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    // 12. AGGREGATION/BREAKDOWN INTENT
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    if (/(?:break\s*down|breakdown|group\s*by|aggregate|summarize|by\s+(?:state|region|category|type|client|company|poc|sales\s*rep))/i.test(questionLower)) {
      extractedContext._intent = 'aggregation';
      console.log(`[ExtractContext] ğŸ“Š Detected aggregation intent`);
    } else if (/(?:top|best|highest|largest|maximum|rank|most)\s+(?:sales\s*reps?|pocs?|clients?|companies?)/i.test(questionLower)) {
      extractedContext._intent = 'ranking';
      console.log(`[ExtractContext] ğŸ† Detected ranking intent`);
    }
    
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    // 13. CLEANUP: Remove project_type if keyword appears in division name
    // When user says "LCC - Healthcare division", "Healthcare" is part of the division name,
    // NOT a filter for Healthcare project type
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    if ((extractedContext.division || extractedContext.divisions) && extractedContext.project_type && extractedContext._project_type_keyword) {
      const divisionName = extractedContext.division || (extractedContext.divisions && extractedContext.divisions[0]) || '';
      const keyword = extractedContext._project_type_keyword.toLowerCase();
      const divLower = divisionName.toLowerCase();
      
      if (divLower.includes(keyword)) {
        console.log(`[ExtractContext] âš ï¸ CLEANUP: Removing project_type="${extractedContext.project_type}" - keyword "${keyword}" is part of division="${divisionName}"`);
        delete extractedContext.project_type;
        delete extractedContext._project_type_keyword;
      }
    }
    
    console.log(`[ExtractContext] ğŸ“‹ Final extracted context:`, JSON.stringify(extractedContext, null, 2));
    return extractedContext;
  }

  async processQuery(
    userQuestion: string,
    externalDbQuery: (sql: string, params?: any[]) => Promise<any[]>,
    previousContext?: { question: string; function_name: string; arguments: Record<string, any>; result_data?: any[] },
    originalContext?: { question: string; function_name: string; arguments: Record<string, any>; result_data?: any[] }
  ): Promise<QueryResponse> {
    // ENTRY TRACE
    try {
      // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
      // LOAD CATEGORY/TYPE CACHE - needed for smart column detection
      // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
      await this.loadCategoryTypeCache(externalDbQuery);
      
      // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
      // QUERY SYNONYM NORMALIZATION - Replace synonyms before processing
      // e.g., "opportunities" â†’ "projects", "firm" â†’ "company"
      // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
      const originalUserQuestion = userQuestion;
      userQuestion = normalizeQuerySynonyms(userQuestion);
      if (userQuestion !== originalUserQuestion) {
        console.log(`[QueryEngine] ğŸ“ Normalized query: "${originalUserQuestion}" â†’ "${userQuestion}"`);
      }
      
      // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
      // EARLY FOLLOW-UP REFINEMENT DETECTION
      // Detect short follow-up questions like "open from last 10 years" or "which are won"
      // and merge with previous context to form a complete query
      // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
      if (previousContext?.arguments && previousContext?.function_name) {
        const questionLower = userQuestion.toLowerCase().trim();
        const prevArgs = previousContext.arguments;
        
        // Detect refinement patterns: status, date, status+date
        const statusPatterns = /\b(open|active|closed|won|lost|submitted|pursuing|dormant|proposal)\b/i;
        const datePatterns = /\b(last|past|from|since)\s+(\d+)\s+(year|month|day)s?\b/i;
        const filterRefinement = /^(?:which|show|those|ones?)?\s*(?:are|that are|from|with)?\s*/i;
        
        const hasStatus = statusPatterns.test(questionLower);
        const hasDate = datePatterns.test(questionLower);
        const isShortRefinement = questionLower.length < 50 && filterRefinement.test(questionLower);
        
        // Only intercept short refinement follow-ups
        if (isShortRefinement && (hasStatus || hasDate)) {
          console.log(`[QueryEngine] ğŸ”„ FOLLOW-UP REFINEMENT DETECTED: "${userQuestion}"`);
          console.log(`[QueryEngine] ğŸ”„ Previous function: ${previousContext.function_name}`);
          
          // Extract status filter from question
          let extractedStatus: string[] | null = null;
          const statusMatch = questionLower.match(statusPatterns);
          if (statusMatch) {
            const statusWord = statusMatch[1].toLowerCase();
            if (statusWord === 'open' || statusWord === 'active') {
              extractedStatus = ['Submitted', 'Proposal', 'Proposal Development', 'Pursuing', 'Qualified'];
            } else if (statusWord === 'closed') {
              extractedStatus = ['Won', 'Lost'];
            } else if (statusWord === 'won') {
              extractedStatus = ['Won'];
            } else if (statusWord === 'lost') {
              extractedStatus = ['Lost'];
            } else if (statusWord === 'submitted') {
              extractedStatus = ['Submitted'];
            } else if (statusWord === 'pursuing') {
              extractedStatus = ['Pursuing'];
            } else if (statusWord === 'dormant') {
              extractedStatus = ['Dormant'];
            } else if (statusWord === 'proposal') {
              extractedStatus = ['Proposal', 'Proposal Development'];
            }
          }
          
          // Extract date filter from question
          let extractedStartDate: string | null = null;
          let extractedEndDate: string | null = null;
          const dateMatch = questionLower.match(datePatterns);
          if (dateMatch) {
            const amount = parseInt(dateMatch[2], 10);
            const unit = dateMatch[3].toLowerCase();
            const today = new Date();
            const startDate = new Date(today);
            
            if (unit === 'year') {
              startDate.setFullYear(startDate.getFullYear() - amount);
            } else if (unit === 'month') {
              startDate.setMonth(startDate.getMonth() - amount);
            } else if (unit === 'day') {
              startDate.setDate(startDate.getDate() - amount);
            }
            
            extractedStartDate = startDate.toISOString().split('T')[0];
            extractedEndDate = today.toISOString().split('T')[0];
          }
          
          // Build merged args
          const mergedArgs: Record<string, any> = { ...prevArgs };
          if (extractedStatus) {
            mergedArgs.status = extractedStatus;
            console.log(`[QueryEngine] ğŸ”„ Merged status: ${JSON.stringify(extractedStatus)}`);
          }
          if (extractedStartDate) {
            mergedArgs.start_date = extractedStartDate;
            mergedArgs.end_date = extractedEndDate;
            console.log(`[QueryEngine] ğŸ”„ Merged dates: ${extractedStartDate} to ${extractedEndDate}`);
          }
          
          // Execute with merged args using combined_filters
          const functionToUse = 'get_projects_by_combined_filters';
          console.log(`[QueryEngine] ğŸ”„ Executing follow-up with: ${functionToUse}`);
          console.log(`[QueryEngine] ğŸ”„ Merged args: ${JSON.stringify(mergedArgs)}`);
          
          const normalizedMergedArgs = normalizeClassificationArguments(mergedArgs, userQuestion);
          const refinementResults = await this.executeQuery(functionToUse, normalizedMergedArgs, externalDbQuery, userQuestion);
          
          if (refinementResults.success) {
            const chartConfig = this.generateChartConfig(refinementResults.data, functionToUse);
            const summary = this.calculateSummaryStats(refinementResults.data);
            
            return {
              success: true,
              question: userQuestion,
              function_name: functionToUse,
              arguments: normalizedMergedArgs,
              data: refinementResults.data,
              row_count: refinementResults.data.length,
              summary,
              chart_config: chartConfig,
              message: refinementResults.data.length > 0 
                ? `Found ${refinementResults.data.length} projects`
                : `No projects found matching the criteria`,
              sql_query: refinementResults.sql_query,
              sql_params: refinementResults.sql_params
            };
          }
        }
      }
      
      // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
      // EARLY SPECIFIC PROJECT NAME DETECTION
      // Detect "provide/show/list projects [LONG SPECIFIC NAME]" or "list [LONG NAME]" and ask user
      // Skip if query already contains disambiguation selection [filter by ...]
      // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
      const hasDisambiguationFilter = userQuestion.includes('[filter by');
      // COLUMN KEYWORD BYPASS: Skip early detection if query contains explicit column keywords
      // This ensures queries like "show projects with title Highway" use the column keyword detection path
      const hasExplicitColumnKeyword = /\b(?:title|client|company|poc|point\s+of\s+contact|service\s+type|project\s+type|division|department|category|sector|region|state|country)\s+\w/i.test(userQuestion);
      if (!hasDisambiguationFilter && !hasExplicitColumnKeyword) {
      // Pattern 1: "list projects LONG_NAME" 
      // Pattern 2: "list LONG_NAME" (without "projects" - for direct entity names)
      const earlyProjectMatch = userQuestion.match(/(?:provide|show|list|get|find|display)\s+(?:all\s+)?(?:the\s+)?projects?\s+(.{25,})/i);
      // Pattern 2 captures long entity names, stopping at common query modifiers
      const earlyDirectMatch = userQuestion.match(/^(?:provide|show|list|get|find|display)\s+(?:the\s+)?(.+?)\s+(?:which|that|from|in|for|with|are|is|has|have|since|during|last|open|closed|won|lost|submitted)\b/i);
      // Pattern 3: Direct long entity name at end of query (no modifiers)
      const earlyEndMatch = !earlyDirectMatch ? userQuestion.match(/^(?:provide|show|list|get|find|display)\s+(?:the\s+)?([A-Z].{20,})$/i) : null;
      // Pattern 4: "provide/show/get details of X" - captures entity after "details of"
      const earlyDetailsMatch = userQuestion.match(/(?:provide|show|get|give)\s+(?:the\s+)?details?\s+(?:of|for|on|about)\s+(.+)/i);
      const earlyDirectOrEndMatch = earlyDirectMatch || earlyEndMatch || earlyDetailsMatch;
      const matchToUse = earlyProjectMatch || earlyDirectOrEndMatch;
      if (matchToUse && matchToUse[1]) {
        // Clean up the extracted entity - remove common trailing words like "projects", "project"
        let potentialProjectName = matchToUse[1].trim()
          .replace(/s+projects?$/i, '')  // Remove trailing "project" or "projects"
          .replace(/s+data$/i, '')        // Remove trailing "data"
          .trim();
        console.log(`[QueryEngine] ğŸ§¹ ENTITY CLEANUP: "${matchToUse[1].trim()}" â†’ "${potentialProjectName}"`);
        // Check it's not a common query phrase
        if (!potentialProjectName.match(/^(?:from|in|for|by|with|under|of|where|that|which|starting|ending|before|after|since|during|last|next|this|all|any|every|most|top|bottom|won|lost|submitted|qualified)\b/i)) {
          console.log(`[QueryEngine] ğŸ·ï¸ EARLY PROJECT NAME DETECTION: Detected specific name: "${potentialProjectName}"`);
          
          // Check which columns have this value
          const allMatches = await this.detectAllMatchingColumns(potentialProjectName, externalDbQuery);
          console.log(`[QueryEngine] ğŸ“Š Column matches for "${potentialProjectName}":`, JSON.stringify(allMatches));
          
          // AUTO-EXECUTE: If exactly 1 column matches, execute directly without asking
          if (allMatches.length === 1) {
            const singleMatch = allMatches[0];
            console.log(`[QueryEngine] âœ… AUTO-EXECUTE: Only 1 column matches ("${singleMatch.displayName}"), executing directly`);
            
            // Build the query with the single match's filter + extracted parameters (min_fee, status, etc.)
            const filterValue = singleMatch.column === 'Title' ? potentialProjectName : `%${potentialProjectName}%`;
            const regexExtractedParams = this.extractQueryContext(userQuestion);
            const autoArgs: Record<string, any> = {
              [singleMatch.paramName]: filterValue,
              _auto_disambiguated: true,
              _disambiguation_column: singleMatch.displayName,
              _disambiguation_function: singleMatch.functionName,
              // Merge extracted parameters (min_fee, max_fee, status, etc.)
              ...(regexExtractedParams.min_fee && { min_fee: regexExtractedParams.min_fee }),
              ...(regexExtractedParams.max_fee && { max_fee: regexExtractedParams.max_fee }),
              ...(regexExtractedParams.status && { status: regexExtractedParams.status }),
              ...(regexExtractedParams.start_date && { start_date: regexExtractedParams.start_date }),
              ...(regexExtractedParams.end_date && { end_date: regexExtractedParams.end_date }),
            };
            
            // Execute the function directly
            const normalizedArgs = normalizeClassificationArguments(autoArgs, userQuestion);
            const autoResults = await this.executeQuery(singleMatch.functionName, normalizedArgs, externalDbQuery, userQuestion);
            
            if (autoResults.success && autoResults.data && autoResults.data.length > 0) {
              const chartConfig = this.generateChartConfig(autoResults.data, singleMatch.functionName);
              const summary = this.calculateSummaryStats(autoResults.data);
              
              return {
                success: true,
                question: userQuestion,
                function_name: singleMatch.functionName,
                arguments: normalizedArgs,
                data: autoResults.data,
                row_count: autoResults.data.length,
                summary,
                chart_config: chartConfig,
                message: `Found ${autoResults.data.length} results`,
                sql_query: autoResults.sql_query,
                sql_params: autoResults.sql_params
              };
            }
          }
          
          // If multiple columns match, ask user which one
          if (allMatches.length > 1) {
            console.log(`[QueryEngine] ğŸ”€ ASKING USER: Which column to search for "${potentialProjectName}"`);
            return {
              success: true,
              question: userQuestion,
              function_name: 'disambiguation_required',
              arguments: { _detected_project_name: potentialProjectName },
              data: [{
                type: 'disambiguation',
                entity: potentialProjectName,
                columns: allMatches,
                message: `I found "${potentialProjectName.substring(0, 50)}..." Which column would you like to search?`
              }],
              row_count: 0,
              summary: {},
              chart_config: null,
              message: 'disambiguation_required'
            };
          }
        }
      }
      } // End of !hasDisambiguationFilter check

      // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
      // DISAMBIGUATION SELECTION HANDLER
      // Detect when user clicked a disambiguation option [filter by X: "Y"]
      // Extract pre-applied filter and continue to FULL LLM flow
      // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
      const disambiguationPattern = /\[filter by (Client|Company|Point of Contact|Project Type|Division|Department|Project Title|Category|City|Service Type|State|Region|Country|Status):\s*"([^"]+)"\]/i;
      console.log(`[QueryEngine] ğŸ” DISAMBIGUATION CHECK: question = "${userQuestion.substring(0, 100)}..."`);
      const disambiguationMatch = userQuestion.match(disambiguationPattern);
      console.log(`[QueryEngine] ğŸ” DISAMBIGUATION MATCH: ${disambiguationMatch ? 'YES - ' + JSON.stringify(disambiguationMatch.slice(0,3)) : 'NO MATCH'}`);
      let preAppliedFilters: Record<string, any> = {};
      let questionForLLM = userQuestion;
      
      if (disambiguationMatch) {
        const selectedColumn = disambiguationMatch[1];
        const entityValue = disambiguationMatch[2];
        console.log(`[QueryEngine] ğŸ¯ DISAMBIGUATION SELECTED: ${selectedColumn} = "${entityValue}"`);
        
        // Map display name to param name
        const columnToParam: Record<string, { paramName: string; functionName: string; isArray?: boolean }> = {
          'Client': { paramName: 'client', functionName: 'get_projects_by_client' },
          'Company': { paramName: 'company', functionName: 'get_projects_by_company' },
          'Point of Contact': { paramName: 'poc', functionName: 'get_projects_by_poc' },
          'Project Type': { paramName: 'project_type', functionName: 'get_projects_by_project_type' },
          'Division': { paramName: 'division', functionName: 'get_projects_by_division' },
          'Department': { paramName: 'department', functionName: 'get_projects_by_department' },
          'Project Title': { paramName: 'title', functionName: 'get_projects_by_combined_filters' },
          'Category': { paramName: 'category', functionName: 'get_projects_by_category' },
          'City': { paramName: 'city', functionName: 'get_projects_by_city' },
          'Service Type': { paramName: 'service_type', functionName: 'get_projects_by_service_type' },
          'State': { paramName: 'states', functionName: 'get_projects_by_combined_filters', isArray: true },
          'Region': { paramName: 'regions', functionName: 'get_projects_by_combined_filters', isArray: true },
          'Country': { paramName: 'countries', functionName: 'get_projects_by_combined_filters', isArray: true },
          'Status': { paramName: 'status', functionName: 'get_projects_by_status', isArray: true },
        };
        
        const mapping = columnToParam[selectedColumn];
        if (mapping) {
          // Remove the disambiguation tag and continue to LLM flow
          questionForLLM = userQuestion.replace(disambiguationPattern, '').trim();
          
          // Store pre-applied filter to be merged with LLM results
          // NORMALIZE entity value for geo columns (country/state/region)
          let normalizedValue = entityValue;
          if (selectedColumn === 'Country') {
            const countryNorm: Record<string, string> = {
              'usa': 'United States', 'us': 'United States', 'america': 'United States', 'unitedstates': 'United States',
              'uk': 'United Kingdom', 'britain': 'United Kingdom', 'unitedkingdom': 'United Kingdom',
              'uae': 'United Arab Emirates', 'emirates': 'United Arab Emirates',
              'ksa': 'Saudi Arabia', 'saudiarabia': 'Saudi Arabia',
            };
            const normalized = countryNorm[entityValue.toLowerCase().replace(/\s+/g, '')];
            if (normalized) {
              console.log(`[QueryEngine] ğŸŒ COUNTRY NORMALIZE: "${entityValue}" â†’ "${normalized}"`);
              normalizedValue = normalized;
            }
          } else if (selectedColumn === 'State') {
            const stateNorm: Record<string, string> = {
              // US States
              'newyork': 'New York', 'ny': 'New York', 'newjersey': 'New Jersey', 'nj': 'New Jersey',
              'northcarolina': 'North Carolina', 'nc': 'North Carolina', 'california': 'California', 'ca': 'California',
              'texas': 'Texas', 'tx': 'Texas', 'florida': 'Florida', 'fl': 'Florida',
              'pennsylvania': 'Pennsylvania', 'pa': 'Pennsylvania', 'illinois': 'Illinois', 'il': 'Illinois',
              'ohio': 'Ohio', 'oh': 'Ohio', 'georgia': 'Georgia', 'ga': 'Georgia',
              'michigan': 'Michigan', 'mi': 'Michigan', 'washington': 'Washington', 'wa': 'Washington',
              // Indian States - common misspellings
              'maharashtra': 'Maharashtra', 'mahastra': 'Maharashtra', 'maharastra': 'Maharashtra', 'mahrastra': 'Maharashtra',
              'karnataka': 'Karnataka', 'karnatak': 'Karnataka', 'kernataka': 'Karnataka',
              'tamilnadu': 'Tamil Nadu', 'tamil': 'Tamil Nadu', 'tn': 'Tamil Nadu',
              'andhrapradesh': 'Andhra Pradesh', 'andhra': 'Andhra Pradesh', 'ap': 'Andhra Pradesh',
              'telangana': 'Telangana', 'telengana': 'Telangana',
              'westbengal': 'West Bengal', 'bengal': 'West Bengal', 'wb': 'West Bengal',
              'madhyapradesh': 'Madhya Pradesh', 'mp': 'Madhya Pradesh',
              'uttarpradesh': 'Uttar Pradesh', 'up': 'Uttar Pradesh',
              'rajasthan': 'Rajasthan', 'rajsthan': 'Rajasthan',
              'gujarat': 'Gujarat', 'gujrat': 'Gujarat', 'gj': 'Gujarat',
              'kerala': 'Kerala', 'kerela': 'Kerala',
              'punjab': 'Punjab', 'panjab': 'Punjab',
              'haryana': 'Haryana', 'hariyana': 'Haryana',
              'delhi': 'Delhi', 'newdelhi': 'New Delhi',
              'mumbai': 'Mumbai', 'bombay': 'Mumbai',
              'bangalore': 'Bangalore', 'bengaluru': 'Bangalore',
              'chennai': 'Chennai', 'madras': 'Chennai',
              'kolkata': 'Kolkata', 'calcutta': 'Kolkata',
              'hyderabad': 'Hyderabad', 'hydrabad': 'Hyderabad',
              // UK regions
              'london': 'London', 'manchester': 'Manchester', 'birmingham': 'Birmingham',
              'scotland': 'Scotland', 'wales': 'Wales', 'ireland': 'Ireland',
            };
            const normalized = stateNorm[entityValue.toLowerCase().replace(/\s+/g, '')];
            if (normalized) {
              console.log(`[QueryEngine] ğŸ—ºï¸ STATE NORMALIZE: "${entityValue}" â†’ "${normalized}"`);
              normalizedValue = normalized;
            }
          }
          
          // Use array format for countries and regions
          if (mapping.isArray) {
            preAppliedFilters[mapping.paramName] = [normalizedValue];
            console.log(`[QueryEngine] ğŸ”µ DEBUG: Set preAppliedFilters[${mapping.paramName}] = ["${normalizedValue}"] (array)`);
          } else {
            preAppliedFilters[mapping.paramName] = normalizedValue;
            console.log(`[QueryEngine] ğŸ”µ DEBUG: Set preAppliedFilters[${mapping.paramName}] = "${normalizedValue}" (type: ${typeof normalizedValue})`);
          }
          preAppliedFilters._disambiguation_column = selectedColumn;
          preAppliedFilters._disambiguation_function = mapping.functionName;
          if (mapping.paramName === 'client') preAppliedFilters._client_already_applied = true;
          if (mapping.paramName === 'poc') preAppliedFilters._poc_already_applied = true;
          if (mapping.paramName === 'company') preAppliedFilters._company_already_applied = true;
          if (mapping.paramName === 'keyword') preAppliedFilters._keyword_already_applied = true;
          if (mapping.paramName === 'title') preAppliedFilters._title_already_applied = true;
          if (mapping.paramName === 'service_type') {
            preAppliedFilters._service_type_already_applied = true;
            preAppliedFilters._service_type_original_value = entityValue;
            console.log(`[QueryEngine] ğŸ”µ DEBUG: _service_type_original_value = "${entityValue}"`);
          }
          if (mapping.paramName === 'division') preAppliedFilters._division_already_applied = true;
          if (mapping.paramName === 'department') preAppliedFilters._department_already_applied = true;
          if (mapping.paramName === 'category') preAppliedFilters._category_already_applied = true;
          if (mapping.paramName === 'project_type') preAppliedFilters._project_type_already_applied = true;
          if (mapping.paramName === 'city') preAppliedFilters._city_already_applied = true;
          
          console.log(`[QueryEngine] ğŸ¯ DISAMBIGUATION: Pre-applied filters: ${JSON.stringify(preAppliedFilters)}`);
          console.log(`[QueryEngine] ğŸ¯ DISAMBIGUATION: Cleaned question for LLM: "${questionForLLM}"`);
        }
      }
      
      // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
      // DISAMBIGUATION OVERRIDE: When user selected a disambiguation option,
      // create an override object that will bypass regex branches.
      // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
      const disambiguationOverride = preAppliedFilters._disambiguation_function ? {
        function: preAppliedFilters._disambiguation_function,
        args: { ...preAppliedFilters }
      } : null;
      
      if (disambiguationOverride) {
        console.log(`[QueryEngine] ğŸ¯ DISAMBIGUATION OVERRIDE: Will use function "${disambiguationOverride.function}"`);
        console.log(`[QueryEngine] ğŸ¯ DISAMBIGUATION OVERRIDE: Args = ${JSON.stringify(disambiguationOverride.args)}`);
      }
      
      // Use cleaned question for LLM processing
      const effectiveQuestion = questionForLLM;
      
      // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
      // TWO-PASS LLM APPROACH: Extract entities using GPT-5.2-mini
      // Pass 1: Fast entity extraction (replaces brittle regex for POC, etc.)
      // Pass 2: Classification (uses extracted entities as context)
      // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
      // Use effectiveQuestion (cleaned, without [filter by] tag) for all extraction
      const llmExtractedEntities = await this.extractEntitiesWithLLM(effectiveQuestion);
      console.log(`[QueryEngine] ğŸ¤– LLM-extracted entities from "${effectiveQuestion}":`, JSON.stringify(llmExtractedEntities));
      
      // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
      // HYBRID APPROACH: Also run regex for reliable patterns
      // (project types, fee patterns, regions - things regex does well)
      // NOTE: Use effectiveQuestion for consistent parsing
      // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
      const regexExtractedHints = this.extractQueryContext(effectiveQuestion);
      console.log(`[QueryEngine] ğŸ“ Regex-extracted hints:`, JSON.stringify(regexExtractedHints));
      
      // Merge: LLM entities take precedence ONLY when they have concrete values
      // Regex fills gaps for values LLM didn't extract
      // EXCEPTION: Regex-extracted arrays (divisions, departments) take precedence over LLM single values
      // EXCEPTION: Regex-extracted compound divisions (with hyphen/colon) take precedence over LLM split values
      const extractedHints: Record<string, any> = { ...regexExtractedHints };
      // DEBUG FILE TRACE: Log extractedHints to file
      try { fs.writeFileSync('/tmp/debug-hints.json', JSON.stringify({ question: userQuestion, extractedHints }, null, 2)); } catch(e) {}
      
      // COMPOUND DIVISION DETECTION: Check if regex extracted a division with punctuation (hyphen, colon, ampersand)
      // These are compound names like "LCC - Healthcare", "SPM: Project Management", "Civil & Structural"
      const regexDivision = regexExtractedHints.division || '';
      const isCompoundDivision = /[-:&]/.test(regexDivision);
      
      for (const [key, value] of Object.entries(llmExtractedEntities)) {
        // Only override if LLM returned a concrete value (not null/undefined)
        if (value !== null && value !== undefined) {
          // Special case: If regex extracted an array (divisions/departments), 
          // DON'T override with LLM's single value (division/department)
          if (key === 'division' && regexExtractedHints.divisions && Array.isArray(regexExtractedHints.divisions)) {
            console.log(`[Merge] âš ï¸ Keeping regex divisions array, ignoring LLM division="${value}"`);
            continue;
          }
          if (key === 'department' && regexExtractedHints.departments && Array.isArray(regexExtractedHints.departments)) {
            console.log(`[Merge] âš ï¸ Keeping regex departments array, ignoring LLM department="${value}"`);
            continue;
          }
          
          // COMPOUND DIVISION PRIORITY: If regex extracted a compound division, keep it
          // and reject LLM's division if it's just part of the compound name
          if (key === 'division' && isCompoundDivision) {
            const llmDivLower = String(value).toLowerCase();
            const regexDivLower = regexDivision.toLowerCase();
            if (regexDivLower.includes(llmDivLower) || llmDivLower !== regexDivLower) {
              console.log(`[Merge] âš ï¸ Keeping regex compound division="${regexDivision}", ignoring LLM division="${value}"`);
              continue;
            }
          }
          
          // COMPOUND DIVISION CLEANUP: If regex extracted a compound division,
          // reject LLM's company/poc/category/project_type if they're substrings of the division name
          if (isCompoundDivision && (key === 'company' || key === 'poc' || key === 'category' || key === 'project_type')) {
            const entityLower = String(value).toLowerCase();
            const regexDivLower = regexDivision.toLowerCase();
            if (regexDivLower.includes(entityLower)) {
              console.log(`[Merge] âš ï¸ Skipping LLM ${key}="${value}" - it's part of compound division="${regexDivision}"`);
              continue;
            }
          }
          
          extractedHints[key] = value;
        }
      }
      console.log(`[QueryEngine] ğŸ¯ Merged hints for classification:`, JSON.stringify(extractedHints));
      
      // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
      // CENTRALIZED HELPER: Merge extractedHints into any override args
      // This ensures ALL override paths preserve extracted entities
      // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
      
      // Check if current question is extracting a division (e.g., "LFDH NY division")
      // If so, skip adding state filters from extractedHints - the "NY" is part of the division name
      const isDivisionQuestion = /(?:related\s+to|in|of|for|from|under|assigned\s+to)\s+(?:the\s+)?[\w\s]+?\s+division/i.test(userQuestion) ||
                                  /[\w\s]+?\s+division\s+projects?/i.test(userQuestion) ||
                                  /division/i.test(userQuestion);
      
      const mergeExtractedHints = (baseArgs: Record<string, any>): Record<string, any> => {
        const merged = { ...baseArgs };
        
        // FIRST: Apply pre-applied filters from disambiguation selection
        // These have highest priority as user explicitly selected them
        console.log(`[QueryEngine] ğŸ”’ ENFORCEMENT CHECK: preAppliedFilters = ${JSON.stringify(preAppliedFilters)}`);
        if (Object.keys(preAppliedFilters).length > 0) {
          console.log(`[mergeExtractedHints] ğŸ¯ Applying disambiguation pre-filters: ${JSON.stringify(preAppliedFilters)}`);
          for (const [key, value] of Object.entries(preAppliedFilters)) {
            if (!key.startsWith('_')) {
              // ALWAYS apply pre-applied filter values (they override LLM/regex)
              merged[key] = value;
              console.log(`[mergeExtractedHints] ğŸ¯ Setting ${key} = "${value}" from disambiguation`);
              
              // If title is set from disambiguation, clear conflicting organization/keyword
              if (key === 'title') {
                if (merged.organization) {
                  console.log(`[mergeExtractedHints] ğŸ¯ Clearing conflicting organization: "${merged.organization}"`);
                  delete merged.organization;
                }
                // DO NOT delete keyword when it matches title - the keyword is the search term!
                // This was causing "East Orange BOE Civil Engineering Services" to fail
                // because the keyword was being treated as duplicate of title
                // if (merged.keyword && merged.keyword === merged.title) {
                //   console.log(`[mergeExtractedHints] ğŸ¯ Clearing duplicate keyword`);
                //   delete merged.keyword;
                // }
              }
            } else {
              // Always copy internal flags
              merged[key] = value;
            }
          }
        }
        
        // Include ALL filter-related entities from extractedHints if not already set
        // This ensures 100% accuracy for any parameter combination
        
        // Entity filters
        if (extractedHints.company && !merged.company) merged.company = extractedHints.company;
        if (extractedHints.client && !merged.client) merged.client = extractedHints.client;
        if (extractedHints.poc && !merged.poc) merged.poc = extractedHints.poc;
        if (extractedHints.person_name && !merged.person_name) merged.person_name = extractedHints.person_name;
        
        // Status filter
        if (extractedHints.status && !merged.status) merged.status = extractedHints.status;
        
        // Geographic filters - SKIP for division questions to avoid "NY" in "LFDH NY" being treated as state
        // ALSO skip states if regions array is set (prefer Region column over state expansion)
        if (extractedHints.regions && !merged.regions) {
          merged.regions = extractedHints.regions;
          // CLEAR any states that might conflict with Region column approach
          if (merged.states) {
            console.log(`[mergeExtractedHints] ğŸ—ºï¸ CLEARING states (using Region column instead): ${merged.states.length} states â†’ regions: ${extractedHints.regions.join(', ')}`);
            delete merged.states;
          }
          if (merged.state_code) {
            console.log(`[mergeExtractedHints] ğŸ—ºï¸ CLEARING state_code (using Region column instead)`);
            delete merged.state_code;
          }
        } else if (!isDivisionQuestion) {
          if (extractedHints.states && !merged.states) merged.states = extractedHints.states;
          if (extractedHints.state_code && !merged.state_code) merged.state_code = extractedHints.state_code;
        } else if (extractedHints.states || extractedHints.state_code) {
          console.log(`[mergeExtractedHints] âš ï¸ SKIPPING state extraction for division question - "${userQuestion}"`);
        }
        if (extractedHints.region && !merged.region) merged.region = extractedHints.region;
        
        // Category/Type filters (with conditional logic to prevent conflicts)
        // ALWAYS pass through _explicit_category flag to prevent safety net overrides
        if (extractedHints._explicit_category) {
          merged._explicit_category = true;
        }
        if (extractedHints.category && !merged.category && !merged.categories && !merged._explicit_category) {
          merged.category = extractedHints.category;
        }
        if (extractedHints.project_type && !merged.project_type && !merged._explicit_category && !merged.categories) {
          merged.project_type = extractedHints.project_type;
        }
        
        // Fee range filters
        if (extractedHints.min_fee && !merged.min_fee) merged.min_fee = extractedHints.min_fee;
        if (extractedHints.max_fee && !merged.max_fee) merged.max_fee = extractedHints.max_fee;
        
        // Win rate filters
        if (extractedHints.min_win && !merged.min_win) merged.min_win = extractedHints.min_win;
        if (extractedHints.max_win && !merged.max_win) merged.max_win = extractedHints.max_win;
        
        // Division/Department filters (support both single and array forms)
        if (extractedHints.division && !merged.division && !merged.divisions) merged.division = extractedHints.division;
        if (extractedHints.divisions && !merged.divisions && !merged.division) merged.divisions = extractedHints.divisions;
        if (extractedHints.department && !merged.department && !merged.departments) merged.department = extractedHints.department;
        if (extractedHints.departments && !merged.departments && !merged.department) merged.departments = extractedHints.departments;
        
        // Year filter (for "this year", "2024", etc.)
        if (extractedHints.year && !merged.year) merged.year = extractedHints.year;
        
        // Other filters
        if (extractedHints.tags && !merged.tags) merged.tags = extractedHints.tags;
        if (extractedHints.start_date && !merged.start_date) merged.start_date = extractedHints.start_date;
        if (extractedHints.end_date && !merged.end_date) merged.end_date = extractedHints.end_date;
        if (extractedHints.limit && !merged.limit) merged.limit = extractedHints.limit;
        if (extractedHints.size && !merged.size) merged.size = extractedHints.size;
        
        // Module filters (for Opportunities, Tracked Work, Construction breakdown)
        if (extractedHints._module_context && !merged._module_context) merged._module_context = extractedHints._module_context;
        if (extractedHints.modules && !merged.modules) merged.modules = extractedHints.modules;
        return merged;
      };
      
      // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
      // EARLY EXIT: Simple count follow-ups that don't need OpenAI
      // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
      // Detect patterns like "how many are there", "total", "what's the count"
      // These can be answered directly from previousContext without re-running queries
      const simpleCountPatterns = [
        /^(total\s*)?(how\s+many|count)(\s+are\s+there|\s+in\s+total|\s+total)?(\?)?$/i,
        /^(what('?s)?|whats)\s+(the\s+)?(total|count)(\?)?$/i,
        /^(give\s+me\s+)?(the\s+)?(total|count)(\?)?$/i,
        /^how\s+many\s+(projects?\s+)?are\s+(there|these|those)(\?)?$/i,
        /^total\s+count(\?)?$/i,
        /^how\s+many\s+total(\?)?$/i,
      ];
      
      const isSimpleCountQuestion = simpleCountPatterns.some(pattern => pattern.test(userQuestion.trim()));
      
      if (isSimpleCountQuestion && previousContext?.result_data && previousContext.result_data.length > 0) {
        const count = previousContext.result_data.length;
        console.log(`[SimpleCount] Detected simple count follow-up: "${userQuestion}" â†’ Answering with previous result count: ${count}`);
        
        // Calculate summary stats from previous data
        const data = previousContext.result_data;
        let totalFee = 0;
        let validFeeCount = 0;
        let totalWinRate = 0;
        let validWinCount = 0;
        
        for (const row of data) {
          const fee = parseFloat(String(row.Fee || row.fee || '').replace(/[^0-9.-]/g, ''));
          if (!isNaN(fee) && fee > 0) {
            totalFee += fee;
            validFeeCount++;
          }
          const win = parseFloat(String(row['Win %'] || row.win_rate || row.Win || '').replace(/[^0-9.-]/g, ''));
          if (!isNaN(win)) {
            totalWinRate += win;
            validWinCount++;
          }
        }
        
        const avgFee = validFeeCount > 0 ? totalFee / validFeeCount : 0;
        const avgWinRate = validWinCount > 0 ? totalWinRate / validWinCount : 0;
        
        return {
          success: true,
          data: previousContext.result_data,
          message: `There are **${count.toLocaleString()} projects** in the previous results.`,
          summary: {
            total_records: count,
            total_value: totalFee,
            avg_fee: avgFee,
            avg_win_rate: avgWinRate,
          },
          function_name: 'simple_count_followup',
          sql_query: `-- Count extracted from previous result (no new query needed)`,
          sql_params: [],
          row_count: count,
        };
      }

      // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
      // EARLY EXIT: Field lookup for "the largest/biggest/first one"
      // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
      // Detect patterns like "what is the start date for the largest one", "show me the fee of the first one"
      // These can be answered from the first record of previous results (sorted by fee DESC)
      const fieldLookupPatterns = [
        /what(?:'?s| is)(?: the)?\s+(?:exact\s+)?(.+?)\s+(?:for|of)\s+(?:the\s+)?(?:largest|biggest|top|first|highest|best)\s+(?:one|project|record|item)?/i,
        /(?:the\s+)?(?:largest|biggest|top|first|highest|best)\s+(?:one|project|record)(?:'?s)?\s+(.+)/i,
        /show(?:\s+me)?\s+(?:the\s+)?(.+?)\s+(?:for|of)\s+(?:the\s+)?(?:largest|biggest|top|first|highest|best)/i,
      ];
      
      // Field name mapping to database columns
      const fieldColumnMap: Record<string, string> = {
        'start date': 'ConstStartDate',
        'startdate': 'ConstStartDate',
        'date': 'ConstStartDate',
        'construction start date': 'ConstStartDate',
        'const start date': 'ConstStartDate',
        'fee': 'Fee',
        'average fee': 'avg_fee',
        'avg fee': 'avg_fee',
        'average fees': 'avg_fee',
        'total revenue': 'total_revenue',
        'total fee': 'total_revenue',
        'total fees': 'total_revenue',
        'average win rate': 'avg_win_rate',
        'avg win rate': 'avg_win_rate',
        'win rate': 'avg_win_rate',
        'success rate': 'avg_win_rate',
        'chance of success': 'avg_win_rate',
        'project count': 'project_count',
        'count': 'project_count',
        'number of projects': 'project_count',
        'project type': 'project_type',
        'value': 'Fee',
        'cost': 'Fee',
        'amount': 'Fee',
        'title': 'Title',
        'name': 'Title',
        'project name': 'Title',
        'project': 'Title',
        'client': 'Client',
        'client name': 'Client',
        'company': 'Company',
        'status': 'StatusChoice',

        'chance': 'ChanceOfSuccess',
        'probability': 'ChanceOfSuccess',
        'win %': 'ChanceOfSuccess',
        'category': 'RequestCategory',
        'type': 'ProjectType',

        'poc': 'PointOfContact',
        'point of contact': 'PointOfContact',
        'contact': 'PointOfContact',
        'division': 'Division',
        'department': 'Department',
        'state': 'State',
        'city': 'City',
        'region': 'Region',
      };
      
      let fieldMatch: RegExpMatchArray | null = null;
      for (const pattern of fieldLookupPatterns) {
        fieldMatch = userQuestion.match(pattern);
        if (fieldMatch) break;
      }
      
      if (fieldMatch && previousContext?.result_data && previousContext.result_data.length > 0) {
        const requestedField = fieldMatch[1]?.toLowerCase().trim();
        const columnName = fieldColumnMap[requestedField];
        
        if (columnName) {
          const firstRecord = previousContext.result_data[0]; // First record is largest (sorted by fee DESC)
          const fieldValue = firstRecord[columnName];
          
          console.log(`[FieldLookup] Detected field lookup: "${userQuestion}" â†’ field="${requestedField}" â†’ column="${columnName}"`);
          console.log(`[FieldLookup] First record value for ${columnName}: ${fieldValue}`);
          
          // Format the value for display
          let displayValue = fieldValue;
          if (columnName === 'Fee' && typeof fieldValue === 'number') {
            displayValue = `$${(fieldValue / 1000000).toFixed(1)}M`;
          } else if (columnName === 'ChanceOfSuccess') {
            displayValue = `${fieldValue}%`;
          }
          
          const projectTitle = firstRecord.Title || firstRecord.title || 'the largest project';
          
          return {
            success: true,
            data: [firstRecord], // Return just the largest project
            message: `The **${requestedField}** for the largest project ("${projectTitle}") is: **${displayValue}**`,
            summary: {
              total_records: 1,
            },
            function_name: 'field_lookup_followup',
            sql_query: `-- Field extracted from previous result (no new query needed)`,
            sql_params: [],
            row_count: 1,
          };
        }
      }

      // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
      // EARLY EXIT: Simple column lookup from previous results
      // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
      // Detect patterns like "when was the start date", "what is the division", "who is the POC"
      // These ask about a specific column from all previous results
      const simpleColumnPatterns = [
        /when\s+(?:was|is|are)\s+(?:the\s+)?(.+?)(?:\?)?$/i,
        /what\s+(?:is|are|was|were)\s+(?:the\s+)?(.+?)(?:\?)?$/i,
        /which\s+(.+?)(?:\s+do\s+they\s+work\s+for)?(?:\?)?$/i,
        /(?:show|tell)\s+(?:me\s+)?(?:the\s+)?(.+?)(?:\?)?$/i,
        /who\s+(?:is|are)\s+(?:the\s+)?(.+?)(?:\?)?$/i,
      ];
      
      // Extended field name mapping to database columns (including common typos)
      const simpleColumnMap: Record<string, string> = {
        'start date': 'ConstStartDate',
        'start dates': 'ConstStartDate',
        'starrt date': 'ConstStartDate',  // typo variant
        'strat date': 'ConstStartDate',   // typo variant
        'sart date': 'ConstStartDate',    // typo variant
        'date': 'ConstStartDate',
        'dates': 'ConstStartDate',
        'construction date': 'ConstStartDate',
        'project date': 'ConstStartDate',
        'division': 'Division',
        'divisions': 'Division',
        'department': 'Department',
        'departments': 'Department',
        'poc': 'PointOfContact',
        'point of contact': 'PointOfContact',
        'contact': 'PointOfContact',
        'assigned': 'PointOfContact',
        'assigned to': 'PointOfContact',
        'status': 'StatusChoice',
        'current status': 'StatusChoice',
        'fee': 'Fee',
        'average fee': 'avg_fee',
        'avg fee': 'avg_fee',
        'average fees': 'avg_fee',
        'total revenue': 'total_revenue',
        'total fee': 'total_revenue',
        'total fees': 'total_revenue',
        'average win rate': 'avg_win_rate',
        'avg win rate': 'avg_win_rate',
        'win rate': 'avg_win_rate',
        'success rate': 'avg_win_rate',
        'chance of success': 'avg_win_rate',
        'project count': 'project_count',
        'count': 'project_count',
        'number of projects': 'project_count',
        'project type': 'project_type',
        'fees': 'Fee',
        'revenue': 'Fee',
        'value': 'Fee',
        'client': 'Client',
        'clients': 'Client',
        'company': 'Company',
        'companies': 'Company',
        'category': 'RequestCategory',
        'categories': 'RequestCategory',
        'type': 'ProjectType',
        'types': 'ProjectType',

        'state': 'State',
        'states': 'State',
        'location': 'State',
        'region': 'Region',
        'regions': 'Region',
        'country': 'Country',
        'countries': 'Country',
        'city': 'City',
        'cities': 'City',
        'title': 'Title',
        'titles': 'Title',
        'project name': 'Title',
        'project names': 'Title',

        'win rates': 'ChanceOfSuccess',
        'chance': 'ChanceOfSuccess',
      };
      
      if (previousContext?.result_data && previousContext.result_data.length > 0) {
        for (const pattern of simpleColumnPatterns) {
          const match = userQuestion.match(pattern);
          if (match) {
            const requestedField = match[1]?.toLowerCase().trim();
            const columnName = simpleColumnMap[requestedField];
            
            if (columnName) {
              console.log(`[SimpleColumnLookup] Detected simple column lookup: "${userQuestion}" â†’ field="${requestedField}" â†’ column="${columnName}"`);
              
              // Extract unique values for the column from all results
              const values = previousContext.result_data.map(r => r[columnName]).filter(v => v !== null && v !== undefined && v !== 'NULL');
              const uniqueValues = Array.from(new Set(values));
              
              // Format the response based on number of unique values
              let displayValue: string;
              let message: string;
              
              if (uniqueValues.length === 0) {
                message = `No ${requestedField} data is available for these projects.`;
              } else if (uniqueValues.length === 1) {
                displayValue = String(uniqueValues[0]);
                if (columnName === 'Fee' && typeof uniqueValues[0] === 'number') {
                  displayValue = `$${(uniqueValues[0] / 1000000).toFixed(1)}M`;
                }
                message = `The **${requestedField}** is: **${displayValue}**`;
              } else if (uniqueValues.length <= 10) {
                const formattedValues = uniqueValues.map(v => {
                  if (columnName === 'Fee' && typeof v === 'number') return `$${(v / 1000000).toFixed(1)}M`;
                  return String(v);
                });
                message = `The **${requestedField}** values include: ${formattedValues.join(', ')}`;
              } else {
                const sample = uniqueValues.slice(0, 5).map(v => {
                  if (columnName === 'Fee' && typeof v === 'number') return `$${(v / 1000000).toFixed(1)}M`;
                  return String(v);
                });
                message = `There are **${uniqueValues.length} different ${requestedField}** values, including: ${sample.join(', ')}...`;
              }
              
              return {
                success: true,
                data: previousContext.result_data,
                message: message,
                summary: {
                  total_records: previousContext.result_data.length,
                },
                function_name: 'simple_column_lookup',
                sql_query: `-- Column extracted from previous result (no new query needed)`,
                sql_params: [],
                row_count: previousContext.result_data.length,
              };
            }
          }
        }
      }

      // Step 1: Classify query with LLM (text understanding only)
      // If we have previous context, provide it to help maintain filters
      const previousResultContext = previousContext?.result_data && previousContext.result_data.length > 0
        ? `\n\nPREVIOUS RESULT DATA (top rows):\n${JSON.stringify(previousContext.result_data.slice(0, 3), null, 2)}`
        : '';

      const enhancedQuestion = previousContext
        ? `CONTEXT: The user previously asked: "${previousContext.question}"
Previous query type: ${previousContext.function_name}
Applied filters: ${JSON.stringify(previousContext.arguments)}${previousResultContext}

FOLLOW-UP REFINEMENT: ${effectiveQuestion}

CRITICAL INSTRUCTIONS FOR FOLLOW-UP QUERIES:
1. **DETERMINE THE CORRECT QUERY TYPE** based on what the user is asking NOW:
   - If asking for opposite/different intent (e.g., "bottom" after "top", "smallest" after "largest", "lost" after "won"), choose the appropriate function
   - If just refining filters (e.g., "with status won", "limit to 5"), keep same function type (${previousContext.function_name})
2. **EXTRACT ONLY NEW/CHANGED PARAMETERS** from the follow-up question - DO NOT repeat previous parameters
3. The system will automatically merge your extracted parameters with previous ones

IMPORTANT: Only extract parameters that are EXPLICITLY mentioned or changed in the follow-up question "${effectiveQuestion}".
- TAGS EXTRACTION RULES (CRITICAL):
  * If query contains COMMAS (e.g., "Rail, Transit, Hospital") â†’ Split on commas: tags=["Rail", "Transit", "Hospital"]
  * If query has NO COMMAS (e.g., "aviation pavement curbs and gutters") â†’ ONE multi-word tag: tags=["aviation pavement curbs and gutters"]
  * "tags X and Y" where X,Y are single words WITH commas â†’ tags=["X", "Y"]
  * "tags X and Y" where "X and Y" is one phrase WITHOUT commas â†’ tags=["X and Y"]
  * Examples: "tags Rail, Transit" = tags:["Rail","Transit"], "tags aviation pavement curbs and gutters" = tags:["aviation pavement curbs and gutters"]
- If the follow-up is "also add X" (in context of previous tags) â†’ Treat X as a TAG (e.g., "also add Hospital" = tags: ["Hospital"])

- If the follow-up mentions a date â†’ Extract ONLY the new date
- If the follow-up explicitly says "size" â†’ Extract as size
- If the follow-up mentions fee/money â†’ Extract as min_fee/max_fee
- If asking for "best of best", "top one", "number one", "the best" â†’ Extract limit=1
- **AGGREGATION/BREAKDOWN FOLLOW-UPS** (CRITICAL - switches function type):
  * "break down by region", "breakdown by state", "aggregate by state", "by region" â†’ Use **compare_states** (DO NOT use ai_fallback!)
  * "break down by category", "aggregate by category" â†’ Use **get_category_breakdown**
  * "break down by client", "aggregate by client" â†’ Use **get_top_clients**
  * "break down by project type", "aggregate by type" â†’ Use **get_project_type_breakdown**
  * These ALWAYS switch to the aggregation function - pass project_type/status from previous context as filters
- If asking to "show only X", "display just Y", "provide only Z", "give me the X column" â†’ Use select_specific_columns
  * Examples: "provide only the projects" â†’ select_specific_columns with columns="Title"
- DO NOT include previous parameters unless they're explicitly mentioned again

CRITICAL DISTINCTION - Category vs Tags:
"Transportation projects" â†’ category: "Transportation" (use get_projects_by_category)
"Healthcare related projects" â†’ category: "Healthcare" (use get_projects_by_category)
"show tags: Rail, Transit" â†’ tags: ["Rail", "Transit"] (use get_projects_by_combined_filters)
"Rail, Transit, Hospital" â†’ tags: [...] (comma-separated list = tags)
"also add Hospital" (when previous context had tags) â†’ tags: ["Hospital"] (additive)

âš ï¸ CRITICAL: "PROJECT TYPE" COLUMN vs "TAGS" COLUMN âš ï¸
The database has TWO DIFFERENT columns:
1. **"ProjectType" column** = Specific types like 'Hospitals', 'Higher Education', 'Bridges', 'Solar', 'Pharma/Life Sciences'

ROUTING RULES:
- If user says "project type" or "project [name]" or "type [name]" â†’ Use "ProjectType" column (get_projects_by_project_type or get_project_type_breakdown)
- If user says "projects under project Higher Education" â†’ project_type="Higher Education" (Project Type column!)
- If user says "most repeated project type" â†’ Use get_project_type_breakdown (Project Type column!)
- NEVER confuse "project Higher Education" with a tag - it's a Project Type!

EXAMPLES:
"most repeated project type in Other category" â†’ get_project_type_breakdown with categories=["Other"]
"projects with project type Higher Education" â†’ get_projects_by_project_type with project_type="Higher Education"
"projects under project Hospitals" â†’ get_projects_by_project_type with project_type="Hospitals"
"how many projects are Higher Education type" â†’ get_projects_by_project_type with project_type="Higher Education"
"how many projects are under project Higher Education with fee above 50M" â†’ get_projects_by_project_type with project_type="Higher Education", min_fee=50000000

EXAMPLES:
Previous: get_projects_by_date_range with tags=["Rail","Transit"], start_date="2025-10-31"
Follow-up: "Healthcare, Medical, Hospital, Medium"
â†’ Extract: tags=["Healthcare","Medical","Hospital","Medium"] (system will clear old tags)

Previous: get_projects_by_year with year=2024
Follow-up: "only mega sized"
â†’ Extract: size="mega" ONLY (year will be preserved by system)

Previous: get_largest_projects with start_date="2025-01-01"
Follow-up: "last 3 months"
â†’ Extract: start_date and end_date for last 3 months (replaces previous date)

Extract ONLY the parameters mentioned in: "${effectiveQuestion}"`
        : effectiveQuestion;
      
      // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
      // HYBRID APPROACH: Add pre-extracted hints to help LLM
      // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
      let hintsSection = '';
      const hintKeys = Object.keys(extractedHints).filter(k => !k.startsWith('_'));
      if (hintKeys.length > 0) {
        hintsSection = `\n\nğŸ¯ PRE-EXTRACTED HINTS (use these to guide your classification):
${hintKeys.map(k => `- ${k}: ${JSON.stringify(extractedHints[k])}`).join('\n')}

IMPORTANT: These hints were extracted from the query using pattern matching. 
You SHOULD use them in your function arguments, but you can also extract additional parameters.
If a hint conflicts with your understanding, trust the hint - they are reliable.`
      }
      
      const questionWithHints = enhancedQuestion + hintsSection;

      // ğŸ†• RAG: Retrieve relevant context before classification
      let ragContextString = "";
      let ragConfidence = 0;
      let ragFunctions: any[] = [];
      
      // ğŸ§  CONVERSATIONAL MEMORY: Add previous AI Analysis narrative for context
      // This enables questions like "provide main limitations" or "explain assumptions"
      let isAiAnalysisFollowUp = false;
      if (previousContext?.result_data?.[0]?.type === 'ai_analysis') {
        const aiAnalysisData = previousContext.result_data[0];
        const narrative = aiAnalysisData.narrative;
        const samples = aiAnalysisData.samples || [];
        const aggregates = aiAnalysisData.aggregates || {};
        
        if (narrative) {
          isAiAnalysisFollowUp = true;
          console.log(`[QueryEngine] ğŸ§  AI Analysis follow-up detected - restricting to conversational extraction`);
          console.log(`[QueryEngine] ğŸ§  Adding previous AI Analysis narrative to context (${narrative.length} chars)`);
          console.log(`[QueryEngine] ğŸ§  Including ${samples.length} sample projects and aggregates`);
          
          ragContextString += "\n\nğŸ“Š PREVIOUS AI ANALYSIS RESPONSE:\n";
          ragContextString += `Question: "${previousContext.question}"\n`;
          ragContextString += `Total Projects Analyzed: ${aggregates.count || 'Unknown'}\n`;
          ragContextString += `\nAnalysis Narrative:\n${narrative}\n`;
          
          // ğŸ†• ENHANCEMENT: Include raw sample data for extraction
          if (samples.length > 0) {
            ragContextString += `\nğŸ“‹ SAMPLE PROJECTS PROVIDED TO ANALYSIS (Top ${samples.length}):\n`;
            samples.forEach((sample: any, idx: number) => {
              ragContextString += `${idx + 1}. ${sample.project_name || 'Unknown'} - `;
              ragContextString += `Company: ${sample.company || 'N/A'}, `;
              ragContextString += `Client: ${sample.client || 'N/A'}, `;
              ragContextString += `Status: ${sample.status || 'N/A'}, `;
              ragContextString += `Fee: $${sample.fee ? parseFloat(sample.fee).toLocaleString() : 'N/A'}, `;
              ragContextString += `Win Rate: ${sample.win_rate || 'N/A'}%`;
              if (sample.category) ragContextString += `, Category: ${sample.category}`;
              if (sample.project_type) ragContextString += `, Type: ${sample.project_type}`;
              ragContextString += '\n';
            });
          }
          
          ragContextString += "\nğŸ’¡ CRITICAL INSTRUCTIONS FOR AI ANALYSIS FOLLOW-UPS:\n";
          ragContextString += "- This is a FOLLOW-UP to the AI Analysis above\n";
          ragContextString += "- You MUST answer purely from the narrative AND sample data above - DO NOT fetch new data from database\n";
          ragContextString += "- Extract from BOTH SOURCES:\n";
          ragContextString += "  1. The narrative text (main analysis)\n";
          ragContextString += "  2. The sample projects list (detailed project data)\n";
          ragContextString += "- CAREFULLY search BOTH the narrative and sample projects list for requested information\n";
          ragContextString += "- Extract requested information (limitations, assumptions, specific PIDs, project names, best project, recommendations, etc.)\n";
          ragContextString += "- For project names/IDs: Check BOTH narrative and the numbered sample projects list above\n";
          ragContextString += "- If user asks for 'all projects' or 'project names', list ALL projects from the sample projects section\n";
          ragContextString += "- Use 'provide_simple_answer' function to return extracted text\n";
          ragContextString += "- DO NOT use ai_data_analysis or any data-fetching functions\n";
          ragContextString += "- Only say information is missing if you've thoroughly searched BOTH sources and it's truly absent\n\n";
        }
      }
      // ğŸ”— TABULAR DATA FOLLOW-UP: Add context for follow-up on regular (non-AI-analysis) query results
      // This enables questions like "open from last 10 years" or "which are won" after disambiguation
      else if (previousContext?.function_name && previousContext?.arguments && !isAiAnalysisFollowUp) {
        console.log(`[QueryEngine] ğŸ”— Tabular data follow-up detected`);
        console.log(`[QueryEngine] ğŸ”— Previous function: ${previousContext.function_name}`);
        console.log(`[QueryEngine] ğŸ”— Previous args: ${JSON.stringify(previousContext.arguments)}`);
        
        // Extract key filters from previous context
        const prevArgs = previousContext.arguments;
        const contextParts: string[] = [];
        
        if (prevArgs.company || prevArgs._company_already_applied) {
          contextParts.push(`Company: ${prevArgs.company}`);
        }
        if (prevArgs.client || prevArgs._client_already_applied) {
          contextParts.push(`Client: ${prevArgs.client}`);
        }
        if (prevArgs.poc || prevArgs._poc_already_applied) {
          contextParts.push(`POC: ${prevArgs.poc}`);
        }
        if (prevArgs.category || prevArgs._category_already_applied) {
          contextParts.push(`Category: ${prevArgs.category}`);
        }
        if (prevArgs.keyword) {
          contextParts.push(`Keyword: ${prevArgs.keyword}`);
        }
        
        if (contextParts.length > 0) {
          ragContextString += "\n\nğŸ”— PREVIOUS QUERY CONTEXT:\n";
          ragContextString += `The user's previous query filtered by: ${contextParts.join(", ")}\n`;
          ragContextString += "This is a FOLLOW-UP question to further filter those results.\n";
          ragContextString += "ğŸ’¡ CRITICAL: You MUST preserve the previous filter while applying the new filter from this question.\n";
          ragContextString += "For example, if previous was 'Company: Palladium' and user now asks 'open from last 10 years',\n";
          ragContextString += "you should use get_projects_by_combined_filters with company='Palladium' AND status=['Submitted','Proposal','Pursuing'] AND start_date calculated from 10 years ago.\n\n";
        }
      }
      
      console.log(`[QueryEngine] RAG Store available: ${!!this.ragStore}`);
      
      if (this.ragStore) {
        try {
          console.log(`[QueryEngine] Calling RAG retrieveContext for: "${userQuestion}"`);
          const ragContext = await this.ragStore.retrieveContext(userQuestion, 5);
          console.log(`[QueryEngine] RAG returned:`, JSON.stringify({
            functions: ragContext.functions?.length || 0,
            schemas: ragContext.schemas?.length || 0,
            examples: ragContext.examples?.length || 0,
            parameters: ragContext.parameters?.length || 0,
            confidence: ragContext.confidence
          }));
          ragConfidence = ragContext.confidence;
          ragFunctions = ragContext.functions || [];
          
          // Build context string from retrieved documents
          if (ragContext.functions.length > 0) {
            ragContextString += "\n\nğŸ“š RELEVANT FUNCTIONS:\n";
            ragContext.functions.forEach((func: any) => {
              ragContextString += `- ${func.function_name}: ${func.description}\n`;
              if (func.examples && func.examples.length > 0) {
                ragContextString += `  Examples: ${func.examples.join('; ')}\n`;
              }
            });
          }
          
          if (ragContext.parameters.length > 0) {
            ragContextString += "\nğŸ“ PARAMETER MEANINGS:\n";
            ragContext.parameters.forEach((param: any) => {
              ragContextString += `- "${param.user_term}": ${param.meaning}\n`;
            });
          }
          
          if (ragContext.schemas.length > 0) {
            ragContextString += "\nğŸ—„ï¸ SCHEMA DEFINITIONS:\n";
            ragContext.schemas.forEach((schema: any) => {
              ragContextString += `- ${schema.field}: ${schema.meaning}\n`;
              if (schema.categories) {
                ragContextString += `  Categories: ${JSON.stringify(schema.categories)}\n`;
              }
            });
          }
          
          if (ragContext.examples.length > 0) {
            ragContextString += "\nâœ… SIMILAR SUCCESSFUL QUERIES:\n";
            ragContext.examples.forEach((example: any) => {
              ragContextString += `- "${example.question}" â†’ ${example.function}(${JSON.stringify(example.params)})\n`;
            });
          }
          
          console.log(`[RAG] Retrieved context with confidence: ${(ragConfidence * 100).toFixed(1)}%`);
        } catch (error) {
          console.error('[RAG] Failed to retrieve context:', error);
          // Continue without RAG context
        }
      }

      // Enhance question with RAG context for better classification
      // Use questionWithHints which includes pre-extracted filter hints for the LLM
      const finalQuestion = ragContextString 
        ? `${ragContextString}\n\nâ“ USER QUESTION: ${questionWithHints}`
        : questionWithHints;

      // ğŸ¯ Function filtering based on context
      let functionsToSend = this.functionDefinitions;
      
      // ğŸ§  AI ANALYSIS FOLLOW-UP: Restrict to extraction-only functions
      if (isAiAnalysisFollowUp) {
        console.log(`[QueryEngine] ğŸ”’ AI Analysis follow-up - restricting to extraction functions only`);
        functionsToSend = this.functionDefinitions.filter((f: any) => 
          f.name === 'provide_simple_answer' || 
          f.name === 'clarify_status_transition_not_supported'
        );
        console.log(`[QueryEngine] ğŸ”’ Reduced functions from ${this.functionDefinitions.length} to ${functionsToSend.length} (extraction only)`);
      }
      // ğŸ¯ RAG: Only send RAG-retrieved functions to GPT to avoid token limit
      else if (ragFunctions.length > 0) {
        // Extract function names from RAG results
        const ragFunctionNames = new Set(ragFunctions.map((f: any) => f.function_name));
        
        // Filter to only include RAG-retrieved functions + essential fallbacks
        const essentialFallbacks = [
          'get_projects_by_combined_filters',  // Catch-all filter function
          'select_specific_columns',           // Column selection
          'get_client_summary',                // Client aggregation (sum, total, avg)
          'get_company_summary',               // Company aggregation (sum, total, avg)
          'get_category_breakdown',            // Category aggregation (for each category...)
          'get_project_type_breakdown',        // Project type aggregation (most repeated, breakdown)
          'get_projects_by_project_type',      // Projects by Project Type column
          'clarify_status_transition_not_supported', // Error handling - status transitions
          'ai_data_analysis',                   // AI-powered analysis on data
          'provide_simple_answer',             // Simple answer extraction
          'compare_states',                    // State/region breakdown and comparison
          'get_top_clients',                   // Client aggregation and ranking
          'get_projects_by_poc',               // POC-based queries (person names)
          'compare_divisions',                 // Division aggregation and comparison
          'compare_departments',               // Department aggregation and comparison
          'get_division_breakdown',            // Division breakdown
          'get_department_breakdown',          // Department breakdown
          'get_revenue_by_division',           // Revenue by division
          'get_revenue_by_department',         // Revenue by department
          'get_projects_by_division',          // Projects filtered by division
          'get_projects_by_department',        // Projects filtered by department
          'get_department_fee_trend',          // Department fee trend over years
          'get_division_fee_trend',            // Division fee trend over years
          'get_fee_extremes',                  // Fee outliers - highest vs lowest
          'get_projects_vs_average',           // Projects above/below average fee
          'get_fee_variance_by_scope',         // Similar scope, different fees
          'get_fee_percentile',                // Custom percentile threshold
          'get_top_fee_bracket',               // Top 10% fee bracket
          'get_bottom_fee_bracket',            // Bottom 20% fee bracket
          'get_top_vs_bottom_fee_comparison',  // Compare top 5 vs bottom 5
          'get_revenue_concentration',         // Revenue % from top projects
          'get_projects_vs_median',            // Above/below median fee
          'get_fee_distribution_stats',        // Fee skewness/distribution stats
          'get_fee_clustering',                // Fee clustering by range
          'get_project_closest_to_average',    // Project closest to avg fee
          'get_middle_fee_project',            // Project at fee midpoint
        ];
        
        functionsToSend = this.functionDefinitions.filter((f: any) => 
          ragFunctionNames.has(f.name) || essentialFallbacks.includes(f.name)
        );
        
        console.log(`[RAG] ğŸ¯ Reduced functions from ${this.functionDefinitions.length} to ${functionsToSend.length} for GPT`);
      }

      // PRE-CLASSIFICATION KEYWORD OVERRIDE: Dual-path routing for domain-specific keywords
      // 1. Keywords that match Project Type column values â†’ use get_projects_by_project_type
      // 2. Keywords for description search (construction terms, etc.) â†’ use search_description
      
      // Map of keywords to canonical Project Type column values
      const KEYWORD_TO_PROJECT_TYPE: Record<string, string> = {
        'airport': 'Airports',
        'airports': 'Airports',
        'aviation': 'Airports',
        'bridge': 'Bridges',
        'bridges': 'Bridges',
        'hospitality': 'Hospitality',
        'hospitality projects': 'Hospitality',
        'hotel': 'HO - Hospitality/Hotel',
        'hotels': 'HO - Hospitality/Hotel',
        'hospital': 'Hospitals',
        'hospitals': 'Hospitals',
        'medical buildings': 'Medical Buildings',
        'medical building': 'Medical Buildings',
        'medical': 'Hospitals',
        'healthcare': 'Hospitals',
        'higher education': 'Higher Education',
        'university': 'Higher Education',
        'universities': 'Higher Education',
        'college': 'Higher Education',
        'colleges': 'Higher Education',
        'k-12': 'K-12',
        'k12': 'K-12',
        'school': 'K-12',
        'schools': 'K-12',
        'elementary': 'K-12',
        'high school': 'K-12',
        'transit': 'Transit',
        'rail': 'Transit',
        'railway': 'Transit',
        'subway': 'Transit',
        'waterfront': 'Waterfront',
        'port': 'Waterfront',
        'ports': 'Waterfront',
        'marina': 'Waterfront',
        'corrections': 'Corrections',
        'prison': 'Corrections',
        'prisons': 'Corrections',
        'jail': 'Corrections',
        'civic': 'Civic',
        'government': 'Civic',
        'municipal building': 'Civic',
        'city hall': 'Civic',
        'courthouse': 'Civic',
        'energy': 'Energy',
        'energy projects': 'Energy',
        'solar': 'Energy: Renewable',
        'renewable': 'Energy: Renewable',
        'power plant': 'Energy/Power Plants',
        'power plants': 'Energy/Power Plants',
        // NOTE: "education" is NOT mapped to "Higher Education" - they are distinct values
        // If user wants "Higher Education", they must say "higher education" explicitly
      };
      
      // Keywords that should search Description column (not Project Type)
      const descriptionOnlyKeywords = ['municipal', 'facility', 'facilities', 'building', 'buildings', 'renovation', 'construction', 'pavement', 'water'] // NOTE: 'road' and 'highway' removed - these are project types (Transportation);
      
      // IMPORTANT: Use user's actual question for keyword matching, NOT finalQuestion
      // finalQuestion includes RAG context which may contain keywords not in user's query
      const questionForKeywords = userQuestion.toLowerCase();
      
      // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
      // REQUEST CATEGORY OVERRIDE: When user explicitly says "request category",
      // route to Request Category column, NOT Project Type
      // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
      // Pattern 1: "request category is Healthcare" or "request category: Healthcare"
      const requestCategoryAfter = /\brequest\s+category\s+(?:is|=|:)\s*(\w+)/i;
      // Pattern 2: "Healthcare request category" (value comes BEFORE)
      const requestCategoryBefore = /\b(healthcare|education|transportation|aviation|commercial|corporate|civic|entertainment|energy|corrections|cultural|industrial|mixed\s*use|multifamily|residential|sports|waterfront)\s+request\s+category\b/i;
      
      // Try both patterns
      let requestCategoryMatch = userQuestion.match(requestCategoryAfter);
      if (!requestCategoryMatch) {
        const beforeMatch = userQuestion.match(requestCategoryBefore);
        if (beforeMatch) {
          // Create a match object similar to the "after" pattern
          requestCategoryMatch = [beforeMatch[0], beforeMatch[1]];
        }
      }
      // Check if user explicitly mentions "request category", "category", or "sector"
      // If so, we should ONLY filter by Request Category column, NOT Project Type
      const usesExplicitCategoryWord = /\b(request\s*category|category|sector)\b/i.test(questionForKeywords);
      
      // MODULE CONTEXT DETECTION: Detect if user is asking about modules (Opportunities, Tracked Work, Construction)
      // When these are mentioned together, "construction" should NOT be matched as a project_type keyword
      const hasOpportunitiesLocal = /\b(opportunities?|oppurtunities?)\b/i.test(questionForKeywords);
      const hasTrackedWorkLocal = /\btracked\s*work\b/i.test(questionForKeywords);
      const hasConstructionLocal = /\bconstruction\b/i.test(questionForKeywords);
      const hasExplicitModuleWordLocal = /\bmodule[s]?\b/i.test(questionForKeywords);
      const hasModuleContext = (hasOpportunitiesLocal && hasConstructionLocal) ||
                               (hasTrackedWorkLocal && hasConstructionLocal) ||
                               (hasOpportunitiesLocal && hasTrackedWorkLocal) ||
                               (/\b(across|between|compare|breakdown|summarize|aggregate)\b/i.test(questionForKeywords) &&
                                (hasOpportunitiesLocal || hasTrackedWorkLocal || hasConstructionLocal)) ||
                               // NEW: Explicit "module" word + any module name triggers module context
                               (hasExplicitModuleWordLocal && (hasOpportunitiesLocal || hasTrackedWorkLocal || hasConstructionLocal));
      
      // First, check for Project Type keywords (prioritize longer matches first)
      // Use word boundary regex to avoid false matches like "port" in "transportation"
      // BUT skip this if user explicitly mentions "request category", "category", or "sector"
      const projectTypeKeywords = Object.keys(KEYWORD_TO_PROJECT_TYPE).sort((a, b) => b.length - a.length);
      const matchedProjectTypeKeyword = (usesExplicitCategoryWord || hasModuleContext) ? null : projectTypeKeywords.find(kw => {
        // Skip "construction" when module context is detected
        if (hasModuleContext && kw.toLowerCase() === 'construction') return false;
        const regex = new RegExp(`\\b${kw}\\b`, 'i');
        return regex.test(questionForKeywords);
      });
      
      if (usesExplicitCategoryWord) {
        console.log(`[QueryEngine] ğŸ“ User mentioned "category/sector" - skipping project type keyword override, will use Request Category`);
      }
      
      // Then check for description-only keywords (also use word boundary regex)
      // BUT skip if user explicitly says "category", "request category", or "sector" - they want category filter, not description search
      const matchedDescriptionKeyword = (usesExplicitCategoryWord || hasModuleContext) ? null : descriptionOnlyKeywords.find(kw => {
        // Skip 'construction' when module context is detected - it refers to ModuleName, not description content
        if (hasModuleContext && kw.toLowerCase() === 'construction') return false;
        const regex = new RegExp(`\\b${kw}\\b`, 'i');
        return regex.test(questionForKeywords);
      });

      let classification: { function_name: string; arguments: Record<string, any> } = { function_name: "", arguments: {} };
      
      // Don't apply keyword overrides for follow-up queries - let AI handle context
      const hasFollowUpContext = previousContext && previousContext.function_name;
      
      // ğŸ”„ BREAKDOWN/AGGREGATION FOLLOW-UP OVERRIDE: These patterns should ALWAYS route to aggregation functions
      // even when there's follow-up context, because they explicitly ask for a different query type
      // NOTE: "by region" routes to compare_regions (groups by West/Midwest/South/Northeast)
      // NOTE: "by state" or "by state lookup" routes to compare_states (groups by individual states)
      // Supports many variations: "break down by", "show by", "group by", "by", "per", etc.
      const breakdownPatterns = [
        // REGION patterns (groups by West/Midwest/South/Northeast)
        { pattern: /(?:break\s*down|breakdown|show|display|group|aggregate|list|view|see)\s+(?:the\s+)?(?:project[s]?\s+)?(?:by|per)\s+(?:the\s+)?region/i, fn: 'compare_regions' },
        { pattern: /(?:by|per)\s+(?:the\s+)?region\s*$/i, fn: 'compare_regions' },
        { pattern: /(?:projects?\s+)?(?:by|per)\s+(?:the\s+)?region/i, fn: 'compare_regions' },
        { pattern: /region\s+(?:breakdown|summary|analysis)/i, fn: 'compare_regions' },
        // "show me the region of X" or "show all regions"
        { pattern: /(?:show|display|list|get)\s+(?:me\s+)?(?:the\s+)?regions?\s+(?:of|for)/i, fn: 'compare_regions' },
        { pattern: /(?:show|display|list|get)\s+(?:me\s+)?all\s+regions?/i, fn: 'compare_regions' },
        { pattern: /(?:what|which)\s+regions?\s+(?:have|has|are|is|do|does)/i, fn: 'compare_regions' },
        
        // STATE patterns (groups by individual states)
        { pattern: /(?:break\s*down|breakdown|show|display|group|aggregate|list|view|see)\s+(?:the\s+)?(?:project[s]?\s+)?(?:by|per)\s+(?:the\s+)?(?:distinct\s+)?(?:state|state\s*lookup)/i, fn: 'compare_states' },
        { pattern: /(?:by|per)\s+(?:the\s+)?(?:distinct\s+)?(?:state|state\s*lookup)\s*$/i, fn: 'compare_states' },
        { pattern: /(?:projects?\s+)?(?:by|per)\s+(?:the\s+)?(?:distinct\s+)?(?:state|state\s*lookup)/i, fn: 'compare_states' },
        { pattern: /(?:state|state\s*lookup)\s+(?:breakdown|summary|analysis)/i, fn: 'compare_states' },
        
        // DEPARTMENT patterns (organizational departments like Civil & Structural, Engineering, etc.)
        { pattern: /(?:break\s*down|breakdown|show|display|group|aggregate|list|view|see)\s+(?:the\s+)?(?:project[s]?\s+)?(?:by|per)\s+(?:the\s+)?department/i, fn: 'get_department_breakdown' },
        { pattern: /(?:by|per)\s+(?:the\s+)?department\s*$/i, fn: 'get_department_breakdown' },
        { pattern: /department\s+(?:breakdown|summary|analysis|details)/i, fn: 'get_department_breakdown' },
        { pattern: /(?:provide|show|list|get|display)\s+(?:all\s+)?(?:\w+\s+)?departments?\s+(?:details|breakdown|summary|info)/i, fn: 'get_department_breakdown' },
        { pattern: /(?:civil|structural|engineering|operations|sales|marketing)\s+departments?\s+(?:details|breakdown|summary|info)/i, fn: 'get_department_breakdown' },
        // COMPARE DEPARTMENTS - only match generic "compare departments" without specific names
        // Specific department comparisons like "compare Environmental with Civil" are handled by LLM extraction
        // The LLM has 'departments' array parameter in its schema to extract specific department names
        { pattern: /^compare\s+(?:the\s+)?departments?\s*$/i, fn: 'compare_departments' },
        { pattern: /^compare\s+all\s+departments?\s*$/i, fn: 'compare_departments' },
        // "Which department has highest/most" queries - route to department breakdown for aggregation
        { pattern: /(?:which|what)\s+department\s+(?:is|has|handles?)\s+(?:the\s+)?(?:highest|most|largest|maximum|lowest|minimum)/i, fn: 'get_department_breakdown' },
        { pattern: /department\s+(?:with|having)\s+(?:the\s+)?(?:highest|most|largest|maximum|lowest|minimum)/i, fn: 'get_department_breakdown' },
        // DEPARTMENT FEE TREND patterns - for year-over-year analysis
        { pattern: /department\s+(?:fee\s+)?(?:trend|trends|trending)/i, fn: 'get_department_fee_trend' },
        { pattern: /departments?\s+(?:with\s+)?(?:declining|decreasing|dropping|falling|growing|increasing)\s+(?:fees?|average|avg)/i, fn: 'get_department_fee_trend' },
        { pattern: /(?:declining|decreasing|dropping|falling|growing|increasing)\s+(?:fees?|average|avg)\s+(?:by|per|for)\s+department/i, fn: 'get_department_fee_trend' },
        { pattern: /department\s+(?:fees?|average|avg)\s+(?:over\s+time|year\s+over\s+year|yearly|by\s+year|across\s+years?)/i, fn: 'get_department_fee_trend' },
        { pattern: /(?:identify|find|show)\s+departments?\s+(?:where|with)\s+(?:.*)?(?:declining|decreasing|growing|increasing)/i, fn: 'get_department_fee_trend' },
        { pattern: /department\s+performance\s+(?:over\s+)?(?:time|years?)/i, fn: 'get_department_fee_trend' },
        // DEPARTMENT PROJECT patterns - for listing actual projects in a department
        // CRITICAL: Use (?!s) negative lookahead to avoid matching "departments" (plural) - multi-department queries handled elsewhere
        // CRITICAL: Use lookahead to avoid "X department and Y department" but ALLOW "Operations and Maintenance department"
        { pattern: /(?:all\s+)?projects?\s+(?:related\s+to|in|of|for|from|under)\s+(?:the\s+)?(?![\w\s]+\s+department\s+and\s+[\w\s]+\s+department)(?:\w+\s+)?department(?!s)/i, fn: 'get_projects_by_department', extractDepartment: true },
        { pattern: /(?:provide|show|list|get|display)\s+(?:all\s+)?projects?\s+(?:related\s+to|in|of|for|from|under)\s+(?:the\s+)?(?![\w\s]+\s+department\s+and\s+[\w\s]+\s+department)(?:\w+\s+)?department(?!s)/i, fn: 'get_projects_by_department', extractDepartment: true },
        { pattern: /(?:civil|structural|engineering|operations|sales|marketing)\s+department(?!s)\s+projects?/i, fn: 'get_projects_by_department', extractDepartment: true },
        { pattern: /projects?\s+(?:of|in|for|from)\s+(?:the\s+)?(?:civil|structural|engineering|operations|sales|marketing)\s+department(?!s)/i, fn: 'get_projects_by_department', extractDepartment: true },
        // Additional department project patterns - handle "assigned to X department" and any department name
        // NOTE: Include colons and hyphens to match department names like "SCM: Cost Management"
        // CRITICAL: Use (?!s) negative lookahead to avoid matching "departments" (plural)
        // CRITICAL: Use lookahead to avoid "X department and Y department" but ALLOW compound names
        { pattern: /(?:all\s+)?projects?\s+assigned\s+to\s+(?:the\s+)?(?![\w&:\-\s]+\s+department\s+and\s+[\w&:\-\s]+\s+department)(?:[\w&:\-]+(?:\s+[\w&:\-]+)*)\s+department(?!s)/i, fn: 'get_projects_by_department', extractDepartment: true },
        { pattern: /(?:list|show|get|provide|display)\s+(?:all\s+)?projects?\s+assigned\s+to\s+(?:the\s+)?(?![\w&:\-\s]+\s+department\s+and\s+[\w&:\-\s]+\s+department)(?:[\w&:\-]+(?:\s+[\w&:\-]+)*)\s+department(?!s)/i, fn: 'get_projects_by_department', extractDepartment: true },
        
        // DIVISION patterns (organizational divisions like LFDH NY, Ajax, Dallas, etc.)
        { pattern: /(?:break\s*down|breakdown|show|display|group|aggregate|list|view|see)\s+(?:the\s+)?(?:project[s]?\s+)?(?:by|per)\s+(?:the\s+)?division/i, fn: 'get_division_breakdown' },
        { pattern: /(?:by|per)\s+(?:the\s+)?division\s*$/i, fn: 'get_division_breakdown' },
        // "show it by division" or "by the Division doing the work" - flexible pattern for division breakdown
        { pattern: /\bby\s+(?:the\s+)?division(?:\s+doing|\s+handling|\s+working|\s+responsible)?/i, fn: 'get_division_breakdown' },
        // "group by division" anywhere in query
        { pattern: /(?:group|grouped|aggregate|aggregated)\s+by\s+(?:the\s+)?division/i, fn: 'get_division_breakdown' },
        { pattern: /division\s+(?:breakdown|summary|analysis|details)/i, fn: 'get_division_breakdown' },
        { pattern: /(?:provide|show|list|get|display)\s+(?:all\s+)?(?:\w+\s+)?divisions?\s+(?:details|breakdown|summary|info)/i, fn: 'get_division_breakdown' },
        { pattern: /compare\s+(?:the\s+)?divisions?/i, fn: 'compare_divisions' },
        // DIVISION FEE TREND patterns - for year-over-year analysis
        { pattern: /division\s+(?:fee\s+)?(?:trend|trends|trending)/i, fn: 'get_division_fee_trend' },
        { pattern: /divisions?\s+(?:with\s+)?(?:declining|decreasing|dropping|falling|growing|increasing)\s+(?:fees?|average|avg)/i, fn: 'get_division_fee_trend' },
        { pattern: /(?:declining|decreasing|dropping|falling|growing|increasing)\s+(?:fees?|average|avg)\s+(?:by|per|for)\s+division/i, fn: 'get_division_fee_trend' },
        { pattern: /division\s+(?:fees?|average|avg)\s+(?:over\s+time|year\s+over\s+year|yearly|by\s+year|across\s+years?)/i, fn: 'get_division_fee_trend' },
        { pattern: /division\s+performance\s+(?:over\s+)?(?:time|years?)/i, fn: 'get_division_fee_trend' },
        
        // FEE EXTREMES/OUTLIERS patterns - projects with unusually large fee differences
        { pattern: /(?:pair\s+of\s+)?projects?\s+(?:where|with)\s+(?:the\s+)?(?:fee\s+)?(?:difference|gap)\s+(?:is\s+)?(?:unusually\s+)?(?:large|big|huge|significant)/i, fn: 'get_fee_extremes' },
        { pattern: /(?:fee\s+)?(?:outliers?|extremes?)/i, fn: 'get_fee_extremes' },
        { pattern: /(?:projects?\s+with\s+)?(?:unusual|extreme|outlier)\s+(?:fees?)/i, fn: 'get_fee_extremes' },
        { pattern: /(?:highest|largest|biggest)\s+(?:and|vs\.?|versus)\s+(?:lowest|smallest)\s+(?:fee|fees)/i, fn: 'get_fee_extremes' },
        { pattern: /(?:compare|show|find)\s+(?:the\s+)?(?:highest|largest)\s+(?:fee\s+)?(?:vs\.?|versus|and|compared\s+to)\s+(?:the\s+)?(?:lowest|smallest)/i, fn: 'get_fee_extremes' },
        { pattern: /largest\s+fee\s+(?:difference|gap|spread)/i, fn: 'get_fee_extremes' },
        
        // PROJECTS VS AVERAGE patterns - classify projects above/below average fee
        { pattern: /(?:average|avg)\s+(?:project\s+)?fee.*(?:above|below|fall)/i, fn: 'get_projects_vs_average' },
        { pattern: /projects?\s+(?:that\s+)?(?:fall|are)\s+(?:above|below)\s+(?:and\s+)?(?:above|below)?\s*(?:the\s+)?average/i, fn: 'get_projects_vs_average' },
        { pattern: /(?:above|below)\s+(?:the\s+)?(?:average|mean)\s+(?:fee|revenue)/i, fn: 'get_projects_vs_average' },
        { pattern: /projects?\s+(?:vs\.?|versus|compared?\s+to)\s+(?:the\s+)?average/i, fn: 'get_projects_vs_average' },
        { pattern: /(?:what|which)\s+(?:is\s+the\s+)?average.*(?:and|,)\s*(?:which|what)\s+projects?/i, fn: 'get_projects_vs_average' },
        
        // FEE VARIANCE BY SCOPE patterns - projects with similar scope but different fees
        { pattern: /(?:nearly\s+)?(?:identical|similar)\s+scope.*(?:different|varying)\s+(?:fees?|pricing)/i, fn: 'get_fee_variance_by_scope' },
        { pattern: /(?:same|similar)\s+(?:type|category|scope).*(?:different|varying|significantly\s+different)\s+(?:fees?|pricing)/i, fn: 'get_fee_variance_by_scope' },
        { pattern: /(?:fee|pricing)\s+(?:variance|variation|inconsistenc|anomal)/i, fn: 'get_fee_variance_by_scope' },
        { pattern: /(?:outliers?|anomal)\s+(?:within|in)\s+(?:same|similar)\s+(?:category|type|scope)/i, fn: 'get_fee_variance_by_scope' },
        { pattern: /(?:similar\s+)?projects?\s+(?:with\s+)?(?:significantly\s+)?different\s+(?:fees?|pricing)/i, fn: 'get_fee_variance_by_scope' },
        { pattern: /(?:underpriced|overpriced)\s+(?:relative\s+to|compared\s+to)\s+(?:peer|similar)/i, fn: 'get_fee_variance_by_scope' },
        
        // FEE PERCENTILE patterns - flexible percentile queries
        { pattern: /(?:top|bottom)\s+(\d+)\s*(?:%|percent)\s+(?:by\s+)?(?:fee|revenue)/i, fn: 'get_fee_percentile' },
        { pattern: /(?:projects?\s+)?(?:in\s+)?(?:the\s+)?(?:top|bottom)\s+(\d+)\s*(?:%|percent)(?:ile)?/i, fn: 'get_fee_percentile' },
        
        // TOP FEE BRACKET patterns - top 10% by fee
        { pattern: /(?:top|highest)\s+10\s*%\s*(?:fee|by\s+fee)?/i, fn: 'get_top_fee_bracket' },
        { pattern: /(?:top|highest)\s+(?:fee\s+)?(?:bracket|tier|percentile|decile)/i, fn: 'get_top_fee_bracket' },
        { pattern: /(?:premium)\s+(?:fee|pricing)\s+(?:projects?|tier)/i, fn: 'get_top_fee_bracket' },
        
        // BOTTOM FEE BRACKET patterns - bottom 20% by fee
        { pattern: /(?:bottom|lowest)\s+20\s*%\s*(?:of\s+)?(?:total\s+)?(?:revenue|fee)/i, fn: 'get_bottom_fee_bracket' },
        { pattern: /(?:bottom|lowest)\s+(?:fee\s+)?(?:bracket|tier|percentile|quintile)/i, fn: 'get_bottom_fee_bracket' },
        { pattern: /(?:low|lowest)[\s-]+fee\s+projects?\s+(?:for|to)\s+(?:review|optimization)/i, fn: 'get_bottom_fee_bracket' },
        
        // TOP VS BOTTOM FEE COMPARISON patterns
        { pattern: /(?:compare|comparison)\s+(?:average\s+)?(?:fee\s+)?(?:of\s+)?(?:top|highest)\s+\d+\s+(?:with|vs\.?|versus|to|and)\s+(?:bottom|lowest)/i, fn: 'get_top_vs_bottom_fee_comparison' },
        { pattern: /(?:top|highest)\s+\d+\s+(?:vs\.?|versus|compared?\s+to|with)\s+(?:bottom|lowest)\s+\d+/i, fn: 'get_top_vs_bottom_fee_comparison' },
        { pattern: /(?:fee\s+)?(?:gap|difference)\s+(?:between\s+)?(?:top|highest)\s+(?:and|vs\.?)\s+(?:bottom|lowest)/i, fn: 'get_top_vs_bottom_fee_comparison' },
        
        // REVENUE CONCENTRATION patterns
        { pattern: /(?:revenue|fee)\s+(?:concentration|dominat)/i, fn: 'get_revenue_concentration' },
        { pattern: /(?:does\s+)?(?:one|single)\s+project\s+(?:dominat|contribut)/i, fn: 'get_revenue_concentration' },
        { pattern: /(?:percent(?:age)?|%)\s+(?:of\s+)?(?:total\s+)?revenue\s+(?:by|from|generated\s+by)\s+(?:top|highest)/i, fn: 'get_revenue_concentration' },
        { pattern: /(?:cumulative|total)\s+(?:revenue\s+)?(?:contribution|percentage)/i, fn: 'get_revenue_concentration' },
        { pattern: /(?:how\s+many|which)\s+projects?\s+(?:together\s+)?(?:contribute|make\s+up)\s+\d+\s*%/i, fn: 'get_revenue_concentration' },
        { pattern: /(?:if\s+only\s+)?(?:three|3)\s+projects?\s+(?:could\s+be\s+)?(?:retain|maximize\s+revenue)/i, fn: 'get_revenue_concentration' },
        
        // MEDIAN FEE COMPARISON patterns
        { pattern: /(?:above|below)\s+(?:the\s+)?median\s+(?:fee|price)/i, fn: 'get_projects_vs_median' },
        { pattern: /(?:more\s+)?projects?\s+(?:priced\s+)?(?:above|below)\s+(?:or\s+)?(?:above|below)?\s*(?:the\s+)?median/i, fn: 'get_projects_vs_median' },
        { pattern: /median\s+(?:fee\s+)?(?:comparison|analysis)/i, fn: 'get_projects_vs_median' },
        
        // FEE DISTRIBUTION STATS patterns
        { pattern: /(?:how\s+)?(?:evenly\s+)?distribut(?:ed|ion)\s+(?:are\s+)?(?:the\s+)?fees?/i, fn: 'get_fee_distribution_stats' },
        { pattern: /(?:are\s+)?(?:project\s+)?fees?\s+skewed\s+(?:toward|to)/i, fn: 'get_fee_distribution_stats' },
        { pattern: /(?:fee\s+)?(?:skew|skewness|distribution)\s+(?:analysis|statistics)/i, fn: 'get_fee_distribution_stats' },
        { pattern: /(?:fee\s+)?(?:spread|variance|deviation)\s+(?:analysis|statistics)/i, fn: 'get_fee_distribution_stats' },
        // More flexible variance patterns - "variance of projects", "project variance"
        { pattern: /variance\s+(?:of\s+)?(?:the\s+)?(?:project|fee)s?/i, fn: 'get_fee_distribution_stats' },
        { pattern: /(?:project|fee)\s+variance/i, fn: 'get_fee_distribution_stats' },
        { pattern: /(?:show|get|display|what\s+is)\s+(?:me\s+)?(?:the\s+)?variance/i, fn: 'get_fee_distribution_stats' },
        { pattern: /(?:statistical?\s+)?(?:variance|std\s*dev|standard\s+deviation)/i, fn: 'get_fee_distribution_stats' },
        
        // FEE CLUSTERING patterns
        { pattern: /(?:fee\s+)?(?:cluster(?:ing)?|grouping)\s+(?:around|by)/i, fn: 'get_fee_clustering' },
        { pattern: /(?:fees?\s+)?(?:distribution|breakdown)\s+(?:by|across)\s+(?:range|bucket|tier)/i, fn: 'get_fee_clustering' },
        { pattern: /(?:noticeable\s+)?(?:fee\s+)?clustering\s+(?:around\s+)?(?:certain\s+)?(?:price|fee)\s+points?/i, fn: 'get_fee_clustering' },
        { pattern: /(?:pricing\s+)?(?:tiers?|brackets?|buckets?)\s+(?:breakdown|analysis)/i, fn: 'get_fee_clustering' },
        
        // PROJECT CLOSEST TO AVERAGE patterns
        { pattern: /(?:project|which)\s+(?:has\s+)?(?:a\s+)?fee\s+(?:closest\s+)?(?:to\s+)?(?:the\s+)?(?:overall\s+)?average/i, fn: 'get_project_closest_to_average' },
        { pattern: /(?:fee\s+)?closest\s+to\s+(?:the\s+)?(?:overall\s+)?average/i, fn: 'get_project_closest_to_average' },
        { pattern: /(?:most\s+)?(?:typical|representative)\s+(?:fee\s+)?project/i, fn: 'get_project_closest_to_average' },
        
        // MIDDLE FEE PROJECT patterns
        { pattern: /(?:project\s+)?(?:sits?|between|exactly\s+between)\s+(?:the\s+)?(?:highest|max)\s+(?:and|&)\s+(?:lowest|min)\s+fee/i, fn: 'get_middle_fee_project' },
        { pattern: /(?:midpoint|middle)\s+(?:fee\s+)?project/i, fn: 'get_middle_fee_project' },
        { pattern: /(?:fee\s+)?midpoint/i, fn: 'get_middle_fee_project' },
        
        // DIVISION PROJECT patterns - for listing actual projects in a division
        // NOTE: Use [\w\s\-:&]+ to match division names with colons like "SCM: Cost Management"
        // CRITICAL: Use (?!s) negative lookahead to avoid matching "divisions" (plural) - multi-division queries handled elsewhere
        // CRITICAL: Use lookahead to avoid "X division and Y division" but ALLOW "Research and Development division"
        { pattern: /(?:all\s+)?projects?\s+(?:related\s+to|in|of|for|from|under|assigned\s+to)\s+(?:the\s+)?(?![\w\s\-:&]+\s+division\s+and\s+[\w\s\-:&]+\s+division)[\w\s\-:&]+\s+division(?!s)/i, fn: 'get_projects_by_division', extractDivision: true },
        { pattern: /(?:provide|show|list|get|display)\s+(?:all\s+)?projects?\s+(?:related\s+to|in|of|for|from|under|assigned\s+to)\s+(?:the\s+)?(?![\w\s\-:&]+\s+division\s+and\s+[\w\s\-:&]+\s+division)[\w\s\-:&]+\s+division(?!s)/i, fn: 'get_projects_by_division', extractDivision: true },
        { pattern: /(?:(?:show|list|get|display|provide)\s+)?(?:ajax|dallas|lfdh|dias|abbott)\s+division(?!s)\s+projects?(?!\s+in\s+.*\s+division)/i, fn: 'get_projects_by_division', extractDivision: true },
        // Exclude multi-division patterns with "X division and Y division"
        { pattern: /projects?\s+(?:of|in|for|from|assigned\s+to)\s+(?:the\s+)?(?:ajax|dallas|lfdh|dias|abbott)\s+division(?!s)(?!\s+and\s+)/i, fn: 'get_projects_by_division', extractDivision: true },
        // SECTOR + DIVISION combo patterns - "X sector projects [over $100M] assigned to Y division"
        // Must match patterns like "Mission Critical sector projects assigned to SPM division"
        // Also handles filler tokens like "over $100M" between "projects" and "assigned to"
        // CRITICAL: Use (?!s) negative lookahead to avoid matching "divisions" (plural)
        { pattern: /\w+(?:\s+\w+)*\s+sector\s+projects?(?:\s+\S+){0,4}\s+assigned\s+to\s+(?:the\s+)?[\w\s\-:&]+\s+division(?!s)/i, fn: 'get_projects_by_combined_filters', extractDivision: true, extractSectorFromPhrase: true },
        { pattern: /(?:list|show|get|display)\s+\w+(?:\s+\w+)*\s+sector\s+projects?(?:\s+\S+){0,4}\s+assigned\s+to\s+(?:the\s+)?[\w\s\-:&]+\s+division(?!s)/i, fn: 'get_projects_by_combined_filters', extractDivision: true, extractSectorFromPhrase: true },
        // Alternative format: "projects in X sector ... assigned to Y division"
        { pattern: /projects?\s+(?:in|from|for|of)\s+(?:the\s+)?\w+(?:\s+\w+)*\s+sector(?:\s+\S+){0,4}\s+assigned\s+to\s+(?:the\s+)?[\w\s\-:&]+\s+division(?!s)/i, fn: 'get_projects_by_combined_filters', extractDivision: true, extractSectorFromPhrase: true },
        { pattern: /(?:list|show|get|display)\s+projects?\s+(?:in|from|for|of)\s+(?:the\s+)?\w+(?:\s+\w+)*\s+sector(?:\s+\S+){0,4}\s+assigned\s+to\s+(?:the\s+)?[\w\s\-:&]+\s+division(?!s)/i, fn: 'get_projects_by_combined_filters', extractDivision: true, extractSectorFromPhrase: true },
        
        // TOP PROJECTS BY WIN RATE patterns - individual project ranking, NOT aggregation
        // MUST come BEFORE category patterns to ensure "top 3 projects by win%" returns individual projects
        { pattern: /(?:top|best|highest)\s+(\d+)\s+projects?\s+(?:based\s+on|by|with\s+highest)\s+(?:win\s*(?:rate|%|percent(?:age)?)|success\s*rate)/i, fn: 'get_top_projects_by_win_rate', extractLimit: true },
        { pattern: /projects?\s+(?:with\s+)?(?:highest|best|top)\s+(?:win\s*(?:rate|%|percent(?:age)?)|success\s*rate)/i, fn: 'get_top_projects_by_win_rate' },
        { pattern: /(?:rank|sort|list|show)\s+(?:top\s+)?(\d+)?\s*projects?\s+by\s+(?:win\s*(?:rate|%|percent(?:age)?)|success\s*rate)/i, fn: 'get_top_projects_by_win_rate', extractLimit: true },
        
        // CATEGORY patterns
        { pattern: /(?:break\s*down|breakdown|show|display|group|aggregate|list|view|see)\s+(?:the\s+)?(?:project[s]?\s+)?(?:by|per)\s+(?:the\s+)?category/i, fn: 'get_category_breakdown' },
        { pattern: /(?:by|per)\s+(?:the\s+)?category\s*$/i, fn: 'get_category_breakdown' },
        { pattern: /category\s+(?:breakdown|summary|analysis)/i, fn: 'get_category_breakdown' },
        
        // SEGMENT patterns - "segment" = RequestCategory (business segment)
        // "provide segments", "show segments with status X", "segments by X", etc.
        // Also handles common typo "segements"
        { pattern: /(?:provide|show|display|list|get|view)\s+(?:all\s+)?(?:business\s+)?seg[ea]?ments?\b/i, fn: 'get_category_breakdown' },
        { pattern: /\bseg[ea]?ments?\s+(?:with|by|for|in)\s+/i, fn: 'get_category_breakdown' },
        { pattern: /\b(?:business\s+)?seg[ea]?ments?\s+(?:breakdown|summary|analysis)/i, fn: 'get_category_breakdown' },
        { pattern: /\btop\s+\d+\s+(?:business\s+)?seg[ea]?ments?\b/i, fn: 'get_category_breakdown' },
        
        // MARKET CATEGORY patterns - "market category" = RequestCategory (same as segment)
        // "market category top 10 projects" â†’ category breakdown, not projects in a category named "market"
        { pattern: /\bmarket\s+categor(?:y|ies)\s+(?:top|best)\s+\d+/i, fn: 'get_category_breakdown' },
        { pattern: /\b(?:top|best)\s+\d+\s+(?:by\s+)?market\s+categor(?:y|ies)/i, fn: 'get_category_breakdown' },
        { pattern: /\bmarket\s+categor(?:y|ies)\s+(?:breakdown|summary|analysis|distribution)/i, fn: 'get_category_breakdown' },
        { pattern: /(?:provide|show|display|list|get|view)\s+(?:all\s+)?market\s+categor(?:y|ies)/i, fn: 'get_category_breakdown' },
        
        // SPECIFIC CATEGORY patterns - route to compare_categories when user mentions a specific category
        { pattern: /(?:average|avg|mean)\s+(?:win\s*%|win\s*rate|win\s*percentage).*(?:category|categorized|categorised)\s+(?:as\s+)?(\w+)/i, fn: 'compare_categories', extractCategory: true },
        { pattern: /(?:category|categorized|categorised)\s+(?:as\s+)?(\w+).*(?:average|avg|mean)\s+(?:win\s*%|win\s*rate|win\s*percentage)/i, fn: 'compare_categories', extractCategory: true },
        { pattern: /(?:win\s*%|win\s*rate|win\s*percentage).*(?:for\s+)?(?:projects?\s+)?(?:in\s+|under\s+)?(?:the\s+)?(\w+)\s+category/i, fn: 'compare_categories', extractCategory: true },
        { pattern: /(?:statistics|stats|summary|info|information)\s+(?:for\s+)?(?:the\s+)?(\w+)\s+category/i, fn: 'compare_categories', extractCategory: true },
        
        // SECTOR patterns - "sector" = RequestCategory column (NOT ProjectType column)
        // "X sector projects", "list X sector", "show X sector projects", etc.
        // MUST route to get_projects_by_category, NOT get_projects_by_project_type
        { pattern: /(?:list|show|display|get|provide|find)\s+(?:all\s+)?(education|healthcare|transportation|aviation|commercial|corporate|civic|entertainment|energy|corrections|cultural|industrial|mixed\s*use|multifamily|residential|sports|waterfront|hospitality|water|buildings)\s+sector\s+projects?/i, fn: 'get_projects_by_category', extractSector: true },
        { pattern: /(education|healthcare|transportation|aviation|commercial|corporate|civic|entertainment|energy|corrections|cultural|industrial|mixed\s*use|multifamily|residential|sports|waterfront|hospitality|water|buildings)\s+sector\s+projects?/i, fn: 'get_projects_by_category', extractSector: true },
        { pattern: /(?:list|show|display|get|provide|find)\s+(?:all\s+)?projects?\s+(?:in|from|for|of)\s+(?:the\s+)?(education|healthcare|transportation|aviation|commercial|corporate|civic|entertainment|energy|corrections|cultural|industrial|mixed\s*use|multifamily|residential|sports|waterfront|hospitality|water|buildings)\s+sector/i, fn: 'get_projects_by_category', extractSector: true },
        { pattern: /projects?\s+(?:in|from|for|of)\s+(?:the\s+)?(education|healthcare|transportation|aviation|commercial|corporate|civic|entertainment|energy|corrections|cultural|industrial|mixed\s*use|multifamily|residential|sports|waterfront|hospitality|water|buildings)\s+sector/i, fn: 'get_projects_by_category', extractSector: true },
        
        // NON-SECTOR PATTERNS for terms that could match multiple columns
        // "building projects", "buildings", etc. without "sector" keyword
        // These trigger column-based disambiguation just like sector patterns
        { pattern: /(?:list|show|display|get|provide|find)\s+(?:all\s+)?(building|buildings)\s+projects?/i, fn: 'get_projects_by_category', extractSector: true },
        { pattern: /(building|buildings)\s+projects?$/i, fn: 'get_projects_by_category', extractSector: true },
        
        
        // PROJECT TYPE patterns
        { pattern: /(?:break\s*down|breakdown|show|display|group|aggregate|list|view|see)\s+(?:the\s+)?(?:project[s]?\s+)?(?:by|per)\s+(?:the\s+)?(?:project\s+)?type/i, fn: 'get_project_type_breakdown' },
        { pattern: /(?:by|per)\s+(?:the\s+)?(?:project\s+)?type\s*$/i, fn: 'get_project_type_breakdown' },
        { pattern: /(?:project\s+)?type\s+(?:breakdown|summary|analysis)/i, fn: 'get_project_type_breakdown' },
        
        // CLIENT patterns
        { pattern: /(?:break\s*down|breakdown|show|display|group|aggregate|list|view|see)\s+(?:the\s+)?(?:project[s]?\s+)?(?:by|per)\s+(?:the\s+)?client/i, fn: 'get_top_clients' },
        { pattern: /(?:by|per)\s+(?:the\s+)?client\s*$/i, fn: 'get_top_clients' },
        { pattern: /client\s+(?:breakdown|summary|analysis)/i, fn: 'get_top_clients' },
        
        // WIN RATE BY COMPANY/CLIENT patterns - route to aggregation function
        { pattern: /(?:win\s*(?:rate|%|percent(?:age)?)|success\s*rate)\s+(?:by|per)\s+(?:the\s+)?(?:company|client|opco)/i, fn: 'get_clients_by_highest_win_rate' },
        { pattern: /(?:by|per)\s+(?:the\s+)?(?:company|client|opco)\s*(?:'s|s)?\s*(?:win\s*(?:rate|%|percent(?:age)?)|success\s*rate)/i, fn: 'get_clients_by_highest_win_rate' },
        { pattern: /(?:company|client|opco)\s+(?:win\s*(?:rate|%|percent(?:age)?)|success\s*rate)/i, fn: 'get_clients_by_highest_win_rate' },
        
        // TITLE/PROJECT NAME aggregation patterns - route to get_top_titles
        { pattern: /(?:most\s+)?(?:used|common|frequent|popular|repeated)\s+(?:project\s+)?(?:titles?|names?)/i, fn: 'get_top_titles' },
        { pattern: /(?:provide|show|list|display|get)\s+(?:the\s+)?(?:most\s+)?(?:used|common|frequent|popular)\s+(?:project\s+)?(?:titles?|names?)/i, fn: 'get_top_titles' },
        { pattern: /(?:top|best|highest)\s+(?:\d+\s+)?(?:project\s+)?(?:titles?|names?)/i, fn: 'get_top_titles' },
        { pattern: /(?:top|first|last)\s+\d+\s+(?:project\s+)?(?:titles?|names?)/i, fn: 'get_top_titles' },
        { pattern: /(?:break\s*down|breakdown|group|aggregate)\s+(?:by|per)\s+(?:project\s+)?(?:title|name)/i, fn: 'get_top_titles' },
        { pattern: /(?:title|project\s+name)\s+(?:breakdown|frequency|count)/i, fn: 'get_top_titles' },
        
        // SIZE DISTRIBUTION patterns - route to get_size_distribution for aggregation
        { pattern: /(?:break\s*down|breakdown|show|display|group|aggregate|list|view|see)\s+(?:the\s+)?(?:project[s]?\s+)?(?:by|per)\s+(?:the\s+)?size/i, fn: 'get_size_distribution' },
        { pattern: /(?:by|per)\s+(?:the\s+)?(?:project\s+)?size\s*$/i, fn: 'get_size_distribution' },
        { pattern: /(?:project\s+)?size\s+(?:breakdown|summary|analysis|distribution)/i, fn: 'get_size_distribution' },
        { pattern: /(?:mega|large|medium|small|micro)\s+(?:and|,)\s+(?:mega|large|medium|small|micro).*?(?:distribution|breakdown|count)/i, fn: 'get_size_distribution' },
        // Catch "size like mega, medium, small, micro" phrasing - these are size tier names, not tags
        { pattern: /\bsize\b.*\b(?:like|such\s+as|categories?|tiers?)\b.*\b(?:mega|large|medium|small|micro)\b/i, fn: 'get_size_distribution' },
        { pattern: /\b(?:mega|large|medium|small|micro)\b.*\b(?:mega|large|medium|small|micro)\b.*\bsize/i, fn: 'get_size_distribution' },
        
        // POC/SALES REP aggregation patterns - must come BEFORE LLM classification
        // Allow optional words like "submitted", "approved", "won" between "of" and "projects"
        { pattern: /(?:sales\s*rep|poc|contact|point\s+of\s+contact)\s+with\s+(?:the\s+)?(?:most|highest|maximum|max|largest|minimum|min|lowest)\s+(?:number\s+of\s+)?(?:\w+\s+)?(?:projects?|total|revenue|value|fee)/i, fn: 'get_top_pocs' },
        { pattern: /(?:which|what|who)\s+(?:sales\s*rep|poc|contact|point\s+of\s+contact)\s+(?:has|with)\s+(?:the\s+)?(?:most|highest|maximum|max)\s+(?:number\s+of\s+)?(?:\w+\s+)?(?:projects?|total|revenue|value|fee)/i, fn: 'get_top_pocs' },
        { pattern: /(?:top|best|highest|most\s+productive)\s+(?:sales\s*reps?|pocs?|contacts?|point\s+of\s+contacts?)/i, fn: 'get_top_pocs' },
        { pattern: /(?:who|which)\s+(?:sales\s*rep|poc|contact)\s+(?:generates?|has|handles?|manages?)\s+(?:the\s+)?(?:most|highest|maximum)/i, fn: 'get_top_pocs' },
        { pattern: /(?:break\s*down|breakdown|show|display|group|aggregate|list|view|see)\s+(?:the\s+)?(?:project[s]?\s+)?(?:by|per)\s+(?:the\s+)?(?:sales\s*rep|poc|contact|point\s+of\s+contact)/i, fn: 'get_top_pocs' },
        { pattern: /(?:by|per)\s+(?:the\s+)?(?:sales\s*rep|poc|contact|point\s+of\s+contact)\s*$/i, fn: 'get_top_pocs' },
        
        // MODULE patterns (Opportunities, Tracked Work, Construction - project pipeline stages)
        { pattern: /(?:break\s*down|breakdown|show|display|group|aggregate|summarize)\s+(?:the\s+)?(?:project[s]?\s+)?(?:by|per|across|of)\s+(?:the\s+)?(?:opportunities|tracked\s*work|construction)\s*,\s*(?:and\s+)?(?:opportunities|tracked\s*work|construction)/i, fn: 'get_module_breakdown' },
        { pattern: /(?:opportunities|tracked\s*work|construction)\s*,\s*(?:opportunities|tracked\s*work|construction)\s*,?\s*(?:and\s+)?(?:opportunities|tracked\s*work|construction)?\s*module/i, fn: 'get_module_breakdown' },
        { pattern: /(?:break\s*down|breakdown|show|display|group|aggregate|list|view|see)\s+(?:the\s+)?(?:project[s]?\s+)?(?:by|per)\s+(?:the\s+)?module/i, fn: 'get_module_breakdown' },
        { pattern: /(?:by|per)\s+(?:the\s+)?module\s*$/i, fn: 'get_module_breakdown' },
        { pattern: /module\s+(?:breakdown|summary|analysis)/i, fn: 'get_module_breakdown' },
        { pattern: /(?:opportunities|tracked\s*work|construction)\s+(?:and\s+)?(?:opportunities|tracked\s*work|construction)?\s+modules?/i, fn: 'get_module_breakdown' },
        // GENERAL "X projects" pattern - catches any term followed by "projects"
        // This handles country names, state names, company names, etc.
        // Uses extractGeneralTerm flag to trigger column-based disambiguation
        // Pattern 1: "[value] projects" - standard format
        { pattern: /(?:(?:list|show|display|get|provide|find|give|pull|fetch)\s+)?(?:all\s+)?(?:the\s+)?([\w-]+(?:\s+[\w-]+){0,3})\s+projects?$/i, fn: 'get_projects_by_category', extractGeneralTerm: true },
        // Pattern 2: "[value] [keyword]" - keyword at end (e.g., "Microsoft client", "Hospital title")
        // Note: Also handles multi-word keywords like "project type", "module name"
        // Uses negative lookahead to not capture "project" or "module" when followed by their compound keywords
        { pattern: /^([\w-]+(?:\s+(?!project\s+type|module\s+name)[\w-]+)?)\s+(?:project\s+type|module\s+name|client|clients|title|titles|type|company|companies|module|modules|sector|sectors|category|categories|division|divisions|department|departments|region|regions|state|states|country|countries|status)$/i, fn: 'get_projects_by_category', extractGeneralTerm: true },
        // Pattern 3: "[keyword] [value]" - keyword at start (e.g., "client DFW", "title Hospital")
        { pattern: /^(?:client|clients|title|titles|type|company|companies|module|modules|sector|sectors|category|categories|division|divisions|department|departments|region|regions|state|states|country|countries|status)\s+([\w-]+(?:\s+[\w-]+){0,2})$/i, fn: 'get_projects_by_category', extractGeneralTerm: true },
      ];
      
      // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
      // AI-FIRST CLASSIFICATION: Call OpenAI FIRST to determine function
      // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
      // EARLY COLUMN DETECTION: Intercept simple "X projects" queries
      // and run column-based disambiguation BEFORE AI classification
      // This handles queries like "provide canada projects", "google projects", etc.
      // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
      // Pattern 1: "[value] projects" - standard format
      const generalTermPattern1 = /(?:(?:list|show|display|get|provide|find|give|pull|fetch)\s+)?(?:all\s+)?(?:the\s+)?([\w-]+(?:\s+[\w-]+){0,3})\s+projects?$/i;
      // Pattern 2: "[value] [keyword]" - keyword at end (e.g., "Microsoft client")
      // Also handles multi-word keywords like "project type", "module name"
      // Uses non-greedy matching to prefer "project type" over just "type"
      const generalTermPattern2 = /^([\w-]+(?:\s+(?!project\s+type|module\s+name|service\s+type|point\s+of\s+contact)[\w-]+)?)\s+(?:project\s+type|module\s+name|service\s+type|point\s+of\s+contact|poc|client|clients|title|titles|type|company|companies|module|modules|sector|sectors|category|categories|division|divisions|department|departments|region|regions|state|states|country|countries|status|servicetype)$/i;
      // Pattern 3: "[keyword] [value]" - keyword at start (e.g., "client DFW")
      const generalTermPattern3 = /^(?:client|clients|title|titles|type|company|companies|module|modules|sector|sectors|category|categories|division|divisions|department|departments|region|regions|state|states|country|countries|status|poc|servicetype|service\s+type|point\s+of\s+contact)\s+([\w-]+(?:\s+[\w-]+){0,5})$/i;
      
      // Pattern 4: "... title VALUE" - keyword in middle of query (e.g., "provide details of title 1200 CPP Assessment")
      const generalTermPattern4 = /(?:details?|info|information|projects?|with|for)\s+(?:of|about|on|for)?\s*(?:title|client|company|module|sector|category|division|department|region|state|country|poc|point\s+of\s+contact|service\s+type|servicetype|project\s+type|projecttype)\s+(.+)$/i;
      
      const generalTermMatch = userQuestion.match(generalTermPattern1) || userQuestion.match(generalTermPattern2) || userQuestion.match(generalTermPattern3) || userQuestion.match(generalTermPattern4);
      if (generalTermMatch && generalTermMatch[1]) {
        const generalTerm = generalTermMatch[1].trim();
        // Skip known keywords that should go to specific handlers
        const skipTerms = ['all', 'some', 'my', 'our', 'top', 'bottom', 'won', 'lost', 'open', 'closed'];
        
        // REGION BYPASS: Skip disambiguation for directional/regional terms
        // These should use Region column filtering, not disambiguation
        const REGIONAL_TERMS = ['east', 'west', 'north', 'south', 'northeast', 'northwest', 'southeast', 'southwest', 'midwest', 'pacific', 'gulf', 'eastern', 'western', 'southern', 'northern', 'midwestern'];
        const generalTermLower = generalTerm.toLowerCase().trim();
        if (REGIONAL_TERMS.includes(generalTermLower)) {
          console.log(`[QueryEngine] ğŸŒ REGION BYPASS (EARLY): "${generalTerm}" is a regional term - setting Region filter, skipping disambiguation`);
          // Set regions filter and skip the EARLY DETECTION block
          extractedHints.regions = [generalTermLower];
        } else if (!skipTerms.includes(generalTermLower)) {
          console.log(`[QueryEngine] ğŸ“Š EARLY DETECTION: Found term "${generalTerm}" in "X projects" pattern`);
          
          // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
          // EXPLICIT COLUMN DETECTION: If user mentions column keyword,
          // use that column directly without disambiguation
          // "Sub-Saharan Africa region projects" â†’ use Region column
          // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
          const columnKeywords: Record<string, { column: string; functionName: string; paramName: string; displayName: string; isArray?: boolean }> = {
            // Geographic columns (array format)
            'region': { column: 'Region', functionName: 'get_projects_by_combined_filters', paramName: 'regions', displayName: 'Region', isArray: true },
            'regions': { column: 'Region', functionName: 'get_projects_by_combined_filters', paramName: 'regions', displayName: 'Region', isArray: true },
            'country': { column: 'Country', functionName: 'get_projects_by_combined_filters', paramName: 'countries', displayName: 'Country', isArray: true },
            'countries': { column: 'Country', functionName: 'get_projects_by_combined_filters', paramName: 'countries', displayName: 'Country', isArray: true },
            'state': { column: 'State', functionName: 'get_projects_by_combined_filters', paramName: 'states', displayName: 'State', isArray: true },
            'states': { column: 'State', functionName: 'get_projects_by_combined_filters', paramName: 'states', displayName: 'State', isArray: true },
            // Organizational columns
            'division': { column: 'Division', functionName: 'get_projects_by_division', paramName: 'division', displayName: 'Division' },
            'divisions': { column: 'Division', functionName: 'get_projects_by_division', paramName: 'division', displayName: 'Division' },
            'department': { column: 'Department', functionName: 'get_projects_by_department', paramName: 'department', displayName: 'Department' },
            'departments': { column: 'Department', functionName: 'get_projects_by_department', paramName: 'department', displayName: 'Department' },
            // Category/Sector columns - "sector" is a common synonym for category
            'category': { column: 'RequestCategory', functionName: 'get_projects_by_category', paramName: 'category', displayName: 'Category' },
            'categories': { column: 'RequestCategory', functionName: 'get_projects_by_category', paramName: 'category', displayName: 'Category' },
            'sector': { column: 'RequestCategory', functionName: 'get_projects_by_category', paramName: 'category', displayName: 'Category' },
            'sectors': { column: 'RequestCategory', functionName: 'get_projects_by_category', paramName: 'category', displayName: 'Category' },
            // Entity columns - when user explicitly says "company X" or "client Y"
            'company': { column: 'Company', functionName: 'get_projects_by_combined_filters', paramName: 'company', displayName: 'Company' },
            'companies': { column: 'Company', functionName: 'get_projects_by_combined_filters', paramName: 'company', displayName: 'Company' },
            'client': { column: 'Client', functionName: 'get_projects_by_client', paramName: 'client', displayName: 'Client' },
            'clients': { column: 'Client', functionName: 'get_projects_by_client', paramName: 'client', displayName: 'Client' },
            // Module column
            'module': { column: 'Module', functionName: 'get_projects_by_combined_filters', paramName: 'module', displayName: 'Module' },
            'modules': { column: 'Module', functionName: 'get_projects_by_combined_filters', paramName: 'module', displayName: 'Module' },
            // Status column
            'status': { column: 'StatusChoice', functionName: 'get_projects_by_status', paramName: 'status', displayName: 'Status', isArray: true },
            'statuschoice': { column: 'StatusChoice', functionName: 'get_projects_by_status', paramName: 'status', displayName: 'Status', isArray: true },
            // Project type column
            'projecttype': { column: 'ProjectType', functionName: 'get_projects_by_project_type', paramName: 'project_type', displayName: 'Project Type' },
            'project type': { column: 'ProjectType', functionName: 'get_projects_by_project_type', paramName: 'project_type', displayName: 'Project Type' },
            'type': { column: 'ProjectType', functionName: 'get_projects_by_project_type', paramName: 'project_type', displayName: 'Project Type' },
            // Module name column
            'modulename': { column: 'ModuleName', functionName: 'get_projects_by_combined_filters', paramName: 'module', displayName: 'Module Name' },
            'module name': { column: 'ModuleName', functionName: 'get_projects_by_combined_filters', paramName: 'module', displayName: 'Module Name' },
            // Title/keyword
            'title': { column: 'Title', functionName: 'search_projects_by_keyword', paramName: 'keyword', displayName: 'Project Title' },
            'titles': { column: 'Title', functionName: 'search_projects_by_keyword', paramName: 'keyword', displayName: 'Project Title' },
            // Service Type column
            'servicetype': { column: 'ServiceType', functionName: 'get_projects_by_service_type', paramName: 'service_type', displayName: 'Service Type' },
            'service type': { column: 'ServiceType', functionName: 'get_projects_by_service_type', paramName: 'service_type', displayName: 'Service Type' },
            // Point of Contact / POC column
            'poc': { column: 'PointOfContact', functionName: 'get_projects_by_poc', paramName: 'poc', displayName: 'Point of Contact' },
            'point of contact': { column: 'PointOfContact', functionName: 'get_projects_by_poc', paramName: 'poc', displayName: 'Point of Contact' },
            'pointofcontact': { column: 'PointOfContact', functionName: 'get_projects_by_poc', paramName: 'poc', displayName: 'Point of Contact' },
          };
          
          // Check if the QUERY contains a column keyword ANYWHERE
          // For patterns 2/3, generalTerm is just the value, so we search the full query
          // e.g., "Microsoft client" â†’ finds "client", generalTerm is "Microsoft"
          // e.g., "client DFW" â†’ finds "client", generalTerm is "DFW"
          const termWordsLower = userQuestion.toLowerCase().split(/\s+/);
          const originalWords = userQuestion.split(/\s+/);
          
          // Find the first column keyword in the query (check multi-word keywords first)
          let explicitColumn: { column: string; functionName: string; paramName: string; displayName: string; isArray?: boolean } | null = null;
          let keywordIndex = -1;
          let keywordLength = 1; // How many words the keyword spans
          
          // First check for 3-word keywords (e.g., "point of contact")
          for (let i = 0; i < termWordsLower.length - 2; i++) {
            const threeWordKey = termWordsLower[i] + ' ' + termWordsLower[i + 1] + ' ' + termWordsLower[i + 2];
            if (columnKeywords[threeWordKey]) {
              explicitColumn = columnKeywords[threeWordKey];
              keywordIndex = i;
              keywordLength = 3;
              console.log(`[ExplicitColumn] Found 3-word keyword "${threeWordKey}" at position ${i} â†’ column: ${explicitColumn.column}`);
              break;
            }
          }
          
          // Then check for 2-word keywords (e.g., "project type", "module name", "service type")
          if (!explicitColumn) {
            for (let i = 0; i < termWordsLower.length - 1; i++) {
              const twoWordKey = termWordsLower[i] + ' ' + termWordsLower[i + 1];
              if (columnKeywords[twoWordKey]) {
                explicitColumn = columnKeywords[twoWordKey];
                keywordIndex = i;
                keywordLength = 2;
                console.log(`[ExplicitColumn] Found 2-word keyword "${twoWordKey}" at position ${i} â†’ column: ${explicitColumn.column}`);
                break;
              }
            }
          }
          
          // If no multi-word keyword found, check for single-word keywords
          if (!explicitColumn) {
            for (let i = 0; i < termWordsLower.length; i++) {
              if (columnKeywords[termWordsLower[i]]) {
                explicitColumn = columnKeywords[termWordsLower[i]];
                keywordIndex = i;
                keywordLength = 1;
                console.log(`[ExplicitColumn] Found keyword "${termWordsLower[i]}" at position ${i} â†’ column: ${explicitColumn.column}`);
                break;
              }
            }
          }
          
          let smartSearchTerm = generalTerm;
          
          if (explicitColumn && keywordIndex >= 0) {
            // User explicitly mentioned a column - extract the value
            // For patterns 2/3 (keyword at start/end), generalTerm is already the extracted value
            // For pattern 1 (X projects), we need to extract from full query
            const wordsBefore = originalWords.slice(0, keywordIndex).join(' ');
            const wordsAfter = originalWords.slice(keywordIndex + keywordLength).join(' ');
            
            // Filter out common command words from the extracted term
            const commandWords = ['projects', 'project', 'list', 'show', 'get', 'display', 'provide', 'find', 'all', 'details', 'info', 'information', 'of', 'about', 'for', 'give', 'me', 'point', 'contact', 'service', 'with', 'from', 'by'];
            const filterCommandWords = (term: string) => {
              return term.split(/\s+/).filter(w => !commandWords.includes(w.toLowerCase())).join(' ').trim();
            };
            
            // If generalTerm doesn't contain the keyword, use generalTerm directly (patterns 2/3)
            const generalTermContainsKeyword = termWordsLower.some(w => columnKeywords[w]) || 
              (keywordLength === 2 && termWordsLower.slice(0, -1).some((w, i) => columnKeywords[w + ' ' + termWordsLower[i+1]]));
            
            // Check if generalTerm contains multi-word column keywords (like "point of contact")
            const gtWords = generalTerm.toLowerCase().split(/\s+/);
            let generalTermContainsMultiWord = false;
            // Check 3-word keywords
            for (let i = 0; i < gtWords.length - 2 && !generalTermContainsMultiWord; i++) {
              const tw = gtWords[i] + " " + gtWords[i+1] + " " + gtWords[i+2];
              if (columnKeywords[tw]) generalTermContainsMultiWord = true;
            }
            // Check 2-word keywords
            for (let i = 0; i < gtWords.length - 1 && !generalTermContainsMultiWord; i++) {
              const tw = gtWords[i] + " " + gtWords[i+1];
              if (columnKeywords[tw]) generalTermContainsMultiWord = true;
            }
            
            if (!generalTermContainsMultiWord && !generalTerm.toLowerCase().split(/\s+/).some(w => columnKeywords[w])) {
              // generalTerm is already the value (patterns 2/3)
              smartSearchTerm = generalTerm;
              console.log(`[ExplicitColumn] Using generalTerm directly: "${smartSearchTerm}" (pattern 2/3)`);
            } else {
              // Try words before keyword first, fall back to words after
              const filteredBefore = wordsBefore.trim() ? filterCommandWords(wordsBefore) : '';
              const filteredAfter = wordsAfter.trim() ? filterCommandWords(wordsAfter) : '';
              
              if (filteredBefore.length > 0) {
                smartSearchTerm = filteredBefore;
                console.log(`[ExplicitColumn] Extracted value: "${smartSearchTerm}" (from words BEFORE keyword)`);
              } else if (filteredAfter.length > 0) {
                smartSearchTerm = filteredAfter;
                console.log(`[ExplicitColumn] Extracted value: "${smartSearchTerm}" (from words AFTER keyword)`);
              } else {
                smartSearchTerm = generalTerm;
                console.log(`[ExplicitColumn] Using generalTerm as fallback: "${smartSearchTerm}"`);
              }
            }
            console.log(`[ExplicitColumn] Final extracted value: "${smartSearchTerm}"`);
            
            // STATE NAME NORMALIZATION: Handle common patterns like "newyork" â†’ "New York"
            if (explicitColumn.column === 'State') {
              const stateNormalization: Record<string, string> = {
                // US States
                'newyork': 'New York', 'ny': 'New York',
                'california': 'California', 'ca': 'California',
                'texas': 'Texas', 'tx': 'Texas',
                'florida': 'Florida', 'fl': 'Florida',
                'illinois': 'Illinois', 'il': 'Illinois',
                'pennsylvania': 'Pennsylvania', 'pa': 'Pennsylvania',
                'ohio': 'Ohio', 'oh': 'Ohio',
                'georgia': 'Georgia', 'ga': 'Georgia',
                'northcarolina': 'North Carolina', 'nc': 'North Carolina',
                'southcarolina': 'South Carolina', 'sc': 'South Carolina',
                'newjersey': 'New Jersey', 'nj': 'New Jersey',
                'virginia': 'Virginia', 'va': 'Virginia',
                'westvirginia': 'West Virginia', 'wv': 'West Virginia',
                'washington': 'Washington', 'wa': 'Washington',
                'massachusetts': 'Massachusetts', 'ma': 'Massachusetts',
                // Indian States - common misspellings
                'maharashtra': 'Maharashtra', 'mahastra': 'Maharashtra', 'maharastra': 'Maharashtra', 'mahrastra': 'Maharashtra',
                'karnataka': 'Karnataka', 'karnatak': 'Karnataka', 'kernataka': 'Karnataka',
                'tamilnadu': 'Tamil Nadu', 'tamil': 'Tamil Nadu', 'tn': 'Tamil Nadu',
                'andhrapradesh': 'Andhra Pradesh', 'andhra': 'Andhra Pradesh', 'ap': 'Andhra Pradesh',
                'telangana': 'Telangana', 'telengana': 'Telangana',
                'westbengal': 'West Bengal', 'bengal': 'West Bengal', 'wb': 'West Bengal',
                'madhyapradesh': 'Madhya Pradesh', 'mp': 'Madhya Pradesh',
                'uttarpradesh': 'Uttar Pradesh', 'up': 'Uttar Pradesh',
                'rajasthan': 'Rajasthan', 'rajsthan': 'Rajasthan',
                'gujarat': 'Gujarat', 'gujrat': 'Gujarat', 'gj': 'Gujarat',
                'kerala': 'Kerala', 'kerela': 'Kerala',
                'punjab': 'Punjab', 'panjab': 'Punjab',
                'haryana': 'Haryana', 'hariyana': 'Haryana',
                'delhi': 'Delhi', 'newdelhi': 'New Delhi',
                'mumbai': 'Mumbai', 'bombay': 'Mumbai',
                'arizona': 'Arizona', 'az': 'Arizona',
                'tennessee': 'Tennessee', 'tn': 'Tennessee',
                'indiana': 'Indiana', 'in': 'Indiana',
                'maryland': 'Maryland', 'md': 'Maryland',
                'colorado': 'Colorado', 'co': 'Colorado',
                'minnesota': 'Minnesota', 'mn': 'Minnesota',
                'wisconsin': 'Wisconsin', 'wi': 'Wisconsin',
                'missouri': 'Missouri', 'mo': 'Missouri',
                'connecticut': 'Connecticut', 'ct': 'Connecticut',
                'oregon': 'Oregon', 'or': 'Oregon',
                'nevada': 'Nevada', 'nv': 'Nevada',
                'newmexico': 'New Mexico', 'nm': 'New Mexico',
                'newhampshire': 'New Hampshire', 'nh': 'New Hampshire',
                'rhodeisland': 'Rhode Island', 'ri': 'Rhode Island',
                'districtofcolumbia': 'District of Columbia', 'dc': 'District of Columbia', 'washingtondc': 'District of Columbia',
              };
              const normalizedState = stateNormalization[smartSearchTerm.toLowerCase().replace(/\s+/g, '')];
              if (normalizedState) {
                console.log(`[QueryEngine] ğŸ“Š STATE NORMALIZE: "${smartSearchTerm}" â†’ "${normalizedState}"`);
                smartSearchTerm = normalizedState;
              }
            }
            
            // COUNTRY NAME NORMALIZATION: Handle common patterns like "usa" â†’ "United States"
            if (explicitColumn.column === 'Country') {
              const countryNormalization: Record<string, string> = {
                'usa': 'United States', 'us': 'United States', 'america': 'United States', 'unitedstates': 'United States',
                'uk': 'United Kingdom', 'britain': 'United Kingdom', 'england': 'United Kingdom', 'unitedkingdom': 'United Kingdom',
                'uae': 'United Arab Emirates', 'emirates': 'United Arab Emirates', 'unitedarabemirates': 'United Arab Emirates',
                'ksa': 'Saudi Arabia', 'saudiarabia': 'Saudi Arabia',
                'southkorea': 'South Korea', 'korea': 'South Korea',
                'hongkong': 'Hong Kong', 'hk': 'Hong Kong',
                'newzealand': 'New Zealand', 'nz': 'New Zealand',
                'southafrica': 'South Africa', 'za': 'South Africa',
              };
              const normalizedCountry = countryNormalization[smartSearchTerm.toLowerCase().replace(/\s+/g, '')];
              if (normalizedCountry) {
                console.log(`[QueryEngine] ğŸ“Š COUNTRY NORMALIZE: "${smartSearchTerm}" â†’ "${normalizedCountry}"`);
                smartSearchTerm = normalizedCountry;
              }
            }
            
            console.log(`[QueryEngine] ğŸ“Š EXPLICIT COLUMN: User specified "${termWordsLower[keywordIndex]}" â†’ using ${explicitColumn.column} column for "${smartSearchTerm}"`);
            
            if (smartSearchTerm.length >= 2) {
              // Execute directly on the specified column - bypass AI classification
              console.log(`[QueryEngine] ğŸ“Š EXPLICIT COLUMN: Executing ${explicitColumn.functionName} with ${explicitColumn.paramName}="${smartSearchTerm}"`);
              
              // Build the classification directly
              // Use array format for parameters like regions that expect arrays
              const paramValue = explicitColumn.isArray ? [smartSearchTerm] : smartSearchTerm;
              const explicitClassification = {
                function_name: explicitColumn.functionName,
                arguments: {
                  [explicitColumn.paramName]: paramValue,
                  _disambiguation_column: explicitColumn.displayName,
                  _disambiguation_value: smartSearchTerm
                }
              };
              
              // Execute the query directly
              console.log(`[QueryEngine] ğŸ“Š EXPLICIT COLUMN DEBUG: Calling executeQuery with args=${JSON.stringify(explicitClassification.arguments)}`);
              const explicitResult = await this.executeQuery(
                explicitClassification.function_name,
                explicitClassification.arguments,
                externalDbQuery,
                originalUserQuestion
              );
              
              const explicitRowCount = explicitResult.data?.length || 0;
              console.log(`[QueryEngine] ğŸ“Š EXPLICIT COLUMN: Got ${explicitRowCount} results from ${explicitColumn.column}`);
              console.log(`[QueryEngine] ğŸ“Š EXPLICIT COLUMN: sql_query present=${!!explicitResult.sql_query}, success=${explicitResult.success}, error=${explicitResult.error || 'none'}`);
              console.log(`[QueryEngine] ğŸ“Š EXPLICIT COLUMN: SQL=${explicitResult.sql_query?.substring(0, 400)}`);
              
              // Calculate summary statistics for the results
              const explicitSummary = this.calculateSummaryStats(explicitResult.data || []);
              console.log(`[QueryEngine] ğŸ“Š EXPLICIT COLUMN: Summary calculated - total_records=${explicitSummary.total_records}, avg_fee=${explicitSummary.avg_fee}`);
              
              return {
                success: true,
                question: originalUserQuestion,
                function_name: explicitClassification.function_name,
                arguments: explicitClassification.arguments,
                data: explicitResult.data || [],
                row_count: explicitRowCount,
                sql_query: explicitResult.sql_query,
                sql_params: explicitResult.sql_params || [],
                summary_stats: explicitResult.summary_stats || null,
                summary: explicitSummary,
                chart_config: explicitResult.chart_config || null,
                message: `Showing projects from ${explicitColumn.displayName}: "${smartSearchTerm}"`
              };
            }
          }
          
          // REGION BYPASS: Skip disambiguation for directional/regional terms
          // These should be handled by Region column filtering, not disambiguation
          const REGIONAL_TERMS = ['east', 'west', 'north', 'south', 'northeast', 'northwest', 'southeast', 'southwest', 'midwest', 'pacific', 'gulf'];
          const generalTermLower = generalTerm.toLowerCase().trim();
          if (REGIONAL_TERMS.includes(generalTermLower)) {
            console.log(`[QueryEngine] ğŸŒ REGION BYPASS: "${generalTerm}" is a regional term - skipping disambiguation, using Region column`);
            extractedHints.regions = [generalTermLower];
            // Don't run disambiguation - let the region filter handle it
          }
          
          // Run column detection (with original term to show options if no explicit column)
          // Skip if we already identified a regional term
          const allColumnMatches = extractedHints.regions?.length > 0 ? [] : await this.detectAllMatchingColumns(generalTerm, externalDbQuery);
          const columnsWithMatches = allColumnMatches.filter(m => m.count > 0);
          console.log(`[QueryEngine] ğŸ“Š EARLY DETECTION: Columns with matches: ${columnsWithMatches.map(m => m.column + ":" + m.count).join(", ")}`);
          
          // If explicit column specified, skip disambiguation
          if (explicitColumn && smartSearchTerm.length >= 2) {
            console.log(`[QueryEngine] ğŸ“Š EXPLICIT COLUMN: Skipping disambiguation - user specified ${explicitColumn.column}`);
            // Let the query continue with the specified column filter
          } else if (columnsWithMatches.length > 1) {
            // If multiple columns have matches, return disambiguation
            console.log(`[QueryEngine] ğŸ“Š EARLY DETECTION: "${generalTerm}" found in ${columnsWithMatches.length} columns - returning disambiguation`);
            return {
              success: true,
              question: originalUserQuestion,
              function_name: "disambiguation_required",
              arguments: { term: generalTerm },
              data: [{
                type: "disambiguation",
                entity: generalTerm,
                search_term: generalTerm,
                message: `The term "${generalTerm}" was found in multiple columns. Please select which column you meant:`,
                options: columnsWithMatches.map(m => ({
                  column: m.column,
                  displayName: m.displayName,
                  count: m.count,
                  value: generalTerm,
                  label: `${m.displayName} (${m.count.toLocaleString()} matches)`
                }))
              }]
            };
          } else if (columnsWithMatches.length === 1) {
            console.log(`[QueryEngine] ğŸ“Š EARLY DETECTION: "${generalTerm}" found only in ${columnsWithMatches[0].displayName} - will auto-execute`);
            // Set up for auto-execution on the single column
            extractedHints._disambiguation_column = columnsWithMatches[0].column;
            extractedHints._disambiguation_value = generalTerm;
          }
        }
      }

      // Then use regex patterns ONLY for parameter extraction/validation
      // This improves accuracy by leveraging AI's natural language understanding
      // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
      
      // AI-FIRST MODE: When enabled, call OpenAI first for classification
      // Then use regex patterns only for parameter extraction/enhancement
      const AI_FIRST_MODE = true;
      
      if (AI_FIRST_MODE) {
        console.log(`[QueryEngine] ğŸ¤– AI-FIRST MODE ENABLED: AI classification first, regex for parameter enrichment`);
      }
      
      // Check for matched breakdown patterns - used for PARAMETER EXTRACTION
      let matchedBreakdown = breakdownPatterns.find(bp => bp.pattern.test(userQuestion));
      
      console.log(`[QueryEngine] ğŸ” matchedBreakdown = ${matchedBreakdown ? matchedBreakdown.fn : "null"}`);
      // CRITICAL: Check if query ALSO contains a breakdown modifier like "by department", "by division"
      // If so, adjust the matched pattern for proper parameter extraction
      if (matchedBreakdown && matchedBreakdown.fn === 'get_projects_by_category') {
        const genericBreakdown = detectBreakdownPattern(userQuestion);
        if (genericBreakdown.breakdownFunction) {
          console.log(`[QueryEngine] ğŸ”„ BREAKDOWN MODIFIER DETECTED in sector query:`);
          console.log(`[QueryEngine]    Original: ${matchedBreakdown.fn} â†’ For extraction: ${genericBreakdown.breakdownFunction}`);
          // Adjust pattern for proper parameter extraction while preserving sector context
          matchedBreakdown = {
            pattern: matchedBreakdown.pattern,
            fn: genericBreakdown.breakdownFunction,
            extractSector: true  // Still extract the sector as a filter
          } as typeof matchedBreakdown;
        }
      }
      
      // AI-FIRST: Use regex patterns for PARAMETER EXTRACTION only, not classification
      // The function_name will be determined by AI
      // However, we still do early execution for breakdown patterns for performance
      // The AI-first approach is used for complex queries that don't match clear patterns
      if (matchedBreakdown && !isAiAnalysisFollowUp) {
        console.log(`[QueryEngine] ğŸ“Š REGEX PATTERN MATCH: "${userQuestion}" â†’ ${matchedBreakdown.fn} (for parameter extraction)`);
        
        // Build arguments from BOTH originalContext AND previousContext
        // originalContext = root query filters (priority)
        // previousContext = immediate prior query filters (fallback)
        const breakdownArgs: Record<string, any> = {};
        
        // Check if this pattern needs to extract limit from the match (for "top N projects" patterns)
        if ((matchedBreakdown as any).extractLimit) {
          const match = userQuestion.match(matchedBreakdown.pattern);
          if (match && match[1]) {
            breakdownArgs.limit = parseInt(match[1], 10);
            console.log(`[QueryEngine] ğŸ“Š Extracted limit=${breakdownArgs.limit} from pattern match`);
          }
        }
        
        // Check if this pattern needs to extract a category from the match
        // PRIORITY: Use LLM-extracted category (from extractedHints) if available, as it's more accurate
        if ((matchedBreakdown as any).extractCategory) {
          if (extractedHints.category) {
            // Use the LLM-extracted category - it's more accurate than regex
            breakdownArgs.categories = [extractedHints.category];
            console.log(`[QueryEngine] ğŸ“Š Using LLM-extracted category: "${extractedHints.category}"`);
          } else {
            // Fallback to regex extraction if LLM didn't extract a category
            const match = userQuestion.match(matchedBreakdown.pattern);
            if (match && match[1]) {
              // Capitalize the first letter of the extracted category
              const categoryName = match[1].charAt(0).toUpperCase() + match[1].slice(1).toLowerCase();
              breakdownArgs.categories = [categoryName];
              console.log(`[QueryEngine] ğŸ“Š Extracted category from query (regex): "${categoryName}"`);
            }
          }
        }
        
        // ALWAYS pass through LLM-extracted category if present (for all patterns, not just extractCategory)
        // This ensures "top 3 projects by win% in education category" gets the Education filter
        if (!breakdownArgs.categories && extractedHints.category) {
          breakdownArgs.categories = [extractedHints.category];
          console.log(`[QueryEngine] ğŸ“Š Passing through LLM-extracted category: "${extractedHints.category}"`);
        }
        
        // Extract department name from query for department project patterns
        console.log(`[QueryEngine] ğŸ” DEPT DEBUG: extractDepartment flag = ${(matchedBreakdown as any).extractDepartment}`);
        if ((matchedBreakdown as any).extractDepartment) {
          // Try to extract department name from query
          // Pattern: "projects related to civil department" â†’ extract "civil"
          // Pattern: "projects assigned to Architecture department" â†’ extract "Architecture"
          // Pattern: "projects assigned to Civil & Structural department" â†’ extract "Civil & Structural"
          // Pattern: "projects assigned to SCM: Cost Management department" â†’ extract "SCM: Cost Management"
          // CRITICAL: Use ORIGINAL query to preserve names that might be corrupted by synonym replacement
          // NOTE: Use GREEDY + (not +?) to capture the full multi-word department name including colons
          console.log(`[QueryEngine] ğŸ” DEPT DEBUG: originalUserQuestion = "${originalUserQuestion}"`);
          const deptMatch = originalUserQuestion.match(/(?:related\s+to|in|of|for|from|under|assigned\s+to)\s+(?:the\s+)?([\w&\s:\-]+)\s+department/i) ||
                           originalUserQuestion.match(/([\w&\s:\-]+)\s+department\s+projects?/i);
          console.log(`[QueryEngine] ğŸ” DEPT DEBUG: deptMatch = ${deptMatch ? JSON.stringify(deptMatch[1]) : 'null'}`);
          if (deptMatch && deptMatch[1]) {
            // Clean up extracted department - strip trailing keywords
            let extractedDept = deptMatch[1].trim();
            extractedDept = extractedDept
              .replace(/\s+(?:starting|in|for|during|this|current|last)\s*$/i, '')
              .trim();
            breakdownArgs.department = extractedDept;
            console.log(`[QueryEngine] ğŸ“Š Extracted department: "${breakdownArgs.department}" from query`);
          } else if (extractedHints.department) {
            breakdownArgs.department = extractedHints.department;
            console.log(`[QueryEngine] ğŸ“Š Using LLM-extracted department: "${breakdownArgs.department}"`);
          }
          console.log(`[QueryEngine] ğŸ” DEPT DEBUG: breakdownArgs.department = "${breakdownArgs.department}"`);
        }
        
        // Extract specific department names for comparison patterns
        // "compare the department of environment with civil and structure" â†’ ["Environment", "Civil and Structure"]
        if ((matchedBreakdown as any).extractSpecificDepartments) {
          const match = originalUserQuestion.match(matchedBreakdown.pattern);
          if (match && match[1] && match[2]) {
            const dept1 = match[1].trim();
            const dept2 = match[2].trim()
              .replace(/\s*department\s*$/i, '')  // Remove trailing "department"
              .trim();
            breakdownArgs.departments = [dept1, dept2];
            console.log(`[QueryEngine] ğŸ“Š Extracted specific departments to compare: "${dept1}" and "${dept2}"`);
          }
        }
        
        // Extract division name from query for division project patterns
        if ((matchedBreakdown as any).extractDivision) {
          // Try to extract division name from query - handle multi-word division names like "LFDH NY"
          // Also handle division names with hyphens like "Hill - Saudi Arabia - Projects"
          // Pattern: "projects related to ajax division" â†’ extract "ajax"
          // Pattern: "projects assigned to DIAS division" â†’ extract "DIAS"
          // Pattern: "projects assigned to LFDH NY division" â†’ extract "LFDH NY"
          // Pattern: "projects assigned to Hill - Saudi Arabia - Projects division" â†’ extract "Hill - Saudi Arabia - Projects"
          // Pattern: "projects assigned to SPM: Project & Programme Management-Private division" â†’ extract "SPM: Project & Programme Management-Private"
          // NOTE: Use GREEDY + (not +?) to capture the full multi-word division name including colons
          // CRITICAL: Use ORIGINAL query (not normalized) to preserve division names like "SCM: Cost Management"
          // The synonym normalization replaces "cost" â†’ "fee" which corrupts division names
          // Try multiple patterns in order of specificity
          // Pattern 1: "projects related to|in|of|for|from|under|assigned to <division> division"
          // Pattern 2: "show/list/get <division> division projects" - strip verb prefix
          // Pattern 3: "<division> division projects" - simple case
          let divMatch = originalUserQuestion.match(/(?:related\s+to|in|of|for|from|under|assigned\s+to)\s+(?:the\s+)?([\w\s\-:&]+)\s+division/i);
          if (!divMatch) {
            // Try pattern with verb prefix - strip the verb when extracting
            const verbMatch = originalUserQuestion.match(/(?:show|list|get|display|provide)\s+([\w\s\-:&]+)\s+division\s+projects?/i);
            if (verbMatch) {
              divMatch = verbMatch;
            } else {
              // Simple pattern without verb
              divMatch = originalUserQuestion.match(/([\w\s\-:&]+)\s+division\s+projects?/i);
            }
          }
          console.log(`[QueryEngine] ğŸ” DIVISION EXTRACTION - originalQuery: "${originalUserQuestion}"`);
          console.log(`[QueryEngine] ğŸ” divMatch: ${divMatch ? JSON.stringify(divMatch[1]) : 'null'}`);
          if (divMatch && divMatch[1]) {
            breakdownArgs.division = divMatch[1].trim();
            console.log(`[QueryEngine] ğŸ“Š Extracted division: "${breakdownArgs.division}" from query (length: ${breakdownArgs.division.length})`);
          } else if (extractedHints.division) {
            breakdownArgs.division = extractedHints.division;
            console.log(`[QueryEngine] ğŸ“Š Using LLM-extracted division: "${breakdownArgs.division}"`);
          }
          
          // CLEANUP: Strip trailing fee/sector/time fragments from division name
          // This handles cases like "Education sector over 100M fee assigned to Ajax" â†’ "Ajax"
          if (breakdownArgs.division) {
            let cleanedDivision = breakdownArgs.division;
            
            // If "assigned to" appears in the string, keep only the text after the LAST "assigned to"
            const assignedToMatch = cleanedDivision.match(/.*assigned\s+to\s+(?:the\s+)?([\w\s\-:]+?)$/i);
            if (assignedToMatch && assignedToMatch[1]) {
              cleanedDivision = assignedToMatch[1].trim();
              console.log(`[QueryEngine] ğŸ“Š Division cleanup: extracted "${cleanedDivision}" after 'assigned to'`);
            }
            
            // Strip trailing clauses beginning with sector/fee/time keywords
            cleanedDivision = cleanedDivision
              .replace(/\s+(?:sector|over|fee|revenue|starting|in|for|during|this|current|last|after|before)\s+.*/i, '')
              .trim();
            
            if (cleanedDivision !== breakdownArgs.division) {
              console.log(`[QueryEngine] ğŸ“Š Division cleanup: "${breakdownArgs.division}" â†’ "${cleanedDivision}"`);
              breakdownArgs.division = cleanedDivision;
            }
          }
        }
        
        // GENERAL TERM HANDLER: Extract term from "X projects" queries and run column detection
        // This catches queries like "canada projects", "texas projects", "google projects", etc.
        if ((matchedBreakdown as any).extractGeneralTerm && !preAppliedFilters._disambiguation_column) {
          const match = userQuestion.match(matchedBreakdown.pattern);
          if (match && match[1]) {
            const generalTerm = match[1].trim();
            const generalTermLower = generalTerm.toLowerCase().trim();
            
            // REGION BYPASS: Skip disambiguation for directional/regional terms
            // These should use Region column filtering, not disambiguation
            const REGIONAL_TERMS_HANDLER = ['east', 'west', 'north', 'south', 'northeast', 'northwest', 'southeast', 'southwest', 'midwest', 'pacific', 'gulf', 'eastern', 'western', 'southern', 'northern', 'midwestern'];
            if (REGIONAL_TERMS_HANDLER.includes(generalTermLower)) {
              console.log(`[QueryEngine] ğŸŒ REGION BYPASS (GENERAL TERM HANDLER): "${generalTerm}" is a regional term - setting Region filter, skipping disambiguation`);
              extractedHints.regions = [generalTermLower];
              // Skip the column detection - fall through to region-based execution
            } else {
              console.log(`[QueryEngine] ğŸ“Š GENERAL TERM: "${generalTerm}" - Running column detection...`);
            
            // Run column detection to find all columns with matches
            const allColumnMatches = await this.detectAllMatchingColumns(generalTerm, externalDbQuery);
            console.log(`[QueryEngine] ğŸ“Š GENERAL TERM COLUMN MATCHES: ${JSON.stringify(allColumnMatches)}`);
            
            // Filter to columns that actually have matches
            const columnsWithMatches = allColumnMatches.filter(m => m.count > 0);
            console.log(`[QueryEngine] ğŸ“Š GENERAL TERM COLUMNS WITH DATA: ${columnsWithMatches.map(m => m.column + ":" + m.count).join(", ")}`);
            
            // If multiple columns have matches, return disambiguation
            if (columnsWithMatches.length > 1) {
              console.log(`[QueryEngine] ğŸ“Š GENERAL TERM "${generalTerm}" found in ${columnsWithMatches.length} columns - returning disambiguation`);
              return {
                success: true,
                question: originalUserQuestion,
                function_name: "disambiguation_required",
                arguments: { term: generalTerm },
                data: [{
                  type: "disambiguation",
                entity: generalTerm,
                search_term: generalTerm,
                  message: `The term "${generalTerm}" was found in multiple columns. Please select which column you meant:`,
                  options: columnsWithMatches.map(m => ({
                    column: m.column,
                    displayName: m.displayName,
                    count: m.count,
                  value: generalTerm,
                    label: `${m.displayName} (${m.count.toLocaleString()} matches)`
                  }))
                }]
              };
            } else if (columnsWithMatches.length === 1) {
              // Auto-execute on the single matching column
              console.log(`[QueryEngine] ğŸ“Š GENERAL TERM "${generalTerm}" found only in ${columnsWithMatches[0].displayName} - auto-executing`);
              breakdownArgs._disambiguation_column = columnsWithMatches[0].column;
              breakdownArgs._disambiguation_value = generalTerm;
            } else {
              console.log(`[QueryEngine] ğŸ“Š GENERAL TERM "${generalTerm}" not found in any columns - falling through to LLM`);
            }
            } // Close the else block for non-regional terms
          }
        }

        // Extract sector name from query for sector project patterns
        // "sector" = RequestCategory column (NOT ProjectType)
        // NEW: Use column-based detection to check if term exists in multiple columns
        if ((matchedBreakdown as any).extractSector && !preAppliedFilters._disambiguation_column) {
          const match = userQuestion.match(matchedBreakdown.pattern);
          if (match && match[1]) {
            // Capitalize the first letter of the extracted sector
            let sectorName = match[1].charAt(0).toUpperCase() + match[1].slice(1).toLowerCase();
            // Handle special case: "mixed use" â†’ "Mixed Use"
            if (sectorName.toLowerCase().includes('mixed')) {
              sectorName = 'Mixed Use';
            }
            
            // COLUMN-BASED DISAMBIGUATION: Check if the term exists in multiple columns
            console.log(`[QueryEngine] ğŸ“Š SECTOR TERM: "${sectorName}" - Running column detection...`);
            const allColumnMatches = await this.detectAllMatchingColumns(sectorName, externalDbQuery);
            console.log(`[QueryEngine] ğŸ“Š SECTOR COLUMN MATCHES: ${JSON.stringify(allColumnMatches)}`);
            
            // Filter to columns that actually have matches
            const columnsWithMatches = allColumnMatches.filter(m => m.count > 0);
            
            if (columnsWithMatches.length > 1) {
              // Multiple columns have matches - return disambiguation options
              console.log(`[QueryEngine] ğŸ“Š SECTOR DISAMBIGUATION: "${sectorName}" found in ${columnsWithMatches.length} columns`);
              
              return {
                success: true,
                question: userQuestion,
                function_name: 'disambiguation_required',
                arguments: { searchTerm: sectorName },
                data: [{
                  type: 'disambiguation',
                  entity: sectorName,
                  search_term: sectorName,
                  message: `I found "${sectorName}" under multiple columns. Please select the column you're looking for:`,
                  options: columnsWithMatches.map(m => ({
                    column: m.column,
                    displayName: m.displayName,
                    count: m.count,
                    functionName: m.functionName,
                    paramName: m.paramName,
                    value: sectorName
                  }))
                }],
                row_count: 0,
                message: 'disambiguation_required'
              };
            } else if (columnsWithMatches.length === 1) {
              // Only one column has matches - auto-execute on that column
              const singleMatch = columnsWithMatches[0];
              console.log(`[QueryEngine] ğŸ“Š SECTOR AUTO-EXECUTE: "${sectorName}" found only in ${singleMatch.column} (${singleMatch.count} results)`);
              
              // Use the matched column's parameter
              if (singleMatch.column === 'RequestCategory') {
                breakdownArgs.categories = [sectorName];
                breakdownArgs._explicit_category = true;
              } else if (singleMatch.column === 'ProjectType') {
                breakdownArgs.project_type = sectorName;
                breakdownArgs._project_type_explicit = true;
              } else if (singleMatch.column === 'Title') {
                breakdownArgs.keyword = sectorName;
              } else {
                breakdownArgs[singleMatch.paramName] = sectorName;
              }
              console.log(`[QueryEngine] ğŸ“Š SECTOR OVERRIDE: Extracted sector="${sectorName}" â†’ using ${singleMatch.column} column`);
            } else {
              // No matches found - fall back to Category anyway
              breakdownArgs.categories = [sectorName];
              breakdownArgs._explicit_category = true;
              console.log(`[QueryEngine] ğŸ“Š SECTOR OVERRIDE: No column matches for "${sectorName}", using RequestCategory column`);
            }
          } else if (extractedHints.category) {
            breakdownArgs.categories = [extractedHints.category];
            breakdownArgs._explicit_category = true;
            console.log(`[QueryEngine] ğŸ“Š SECTOR OVERRIDE: Using LLM-extracted category: "${extractedHints.category}"`);
          }
        }
        
        // Extract sector from phrase patterns like "X sector projects assigned to Y division"
        // This handles combo patterns where sector is before "sector projects"
        if ((matchedBreakdown as any).extractSectorFromPhrase) {
          const sectorPhraseMatch = userQuestion.match(/(?:list\s+|show\s+|get\s+|display\s+)?(\w+(?:\s+\w+)*)\s+sector\s+projects?/i);
          if (sectorPhraseMatch && sectorPhraseMatch[1]) {
            // Capitalize properly - handle multi-word sectors like "Mission Critical"
            let sectorName = sectorPhraseMatch[1].split(/\s+/).map(w => 
              w.charAt(0).toUpperCase() + w.slice(1).toLowerCase()
            ).join(' ');
            breakdownArgs.categories = [sectorName];
            breakdownArgs._explicit_category = true;
            console.log(`[QueryEngine] ğŸ“Š SECTOR FROM PHRASE: Extracted sector="${sectorName}" â†’ using RequestCategory column`);
          } else if (extractedHints.category) {
            breakdownArgs.categories = [extractedHints.category];
            breakdownArgs._explicit_category = true;
            console.log(`[QueryEngine] ğŸ“Š SECTOR FROM PHRASE: Using LLM-extracted category: "${extractedHints.category}"`);
          }
        }
        
        // Extract min_win/max_win - PRIORITY: Use LLM-extracted values from extractedHints
        if (extractedHints.min_win) {
          breakdownArgs.min_win = extractedHints.min_win;
          console.log(`[QueryEngine] ğŸ“Š BREAKDOWN: Using LLM-extracted min_win=${breakdownArgs.min_win}`);
        } else {
          // Fallback to regex (requires % sign)
          const minWinMatch = userQuestion.match(/(?:more\s+than|greater\s+than|above|over|at\s+least|>=?)\s*(\d+)\s*(?:%|percent)/i);
          if (minWinMatch) {
            breakdownArgs.min_win = parseInt(minWinMatch[1], 10);
            console.log(`[QueryEngine] ğŸ“Š BREAKDOWN: Extracted min_win=${breakdownArgs.min_win} from query (regex)`);
          }
        }
        
        if (extractedHints.max_win) {
          breakdownArgs.max_win = extractedHints.max_win;
          console.log(`[QueryEngine] ğŸ“Š BREAKDOWN: Using LLM-extracted max_win=${breakdownArgs.max_win}`);
        } else {
          const maxWinMatch = userQuestion.match(/(?:less\s+than|below|under|at\s+most|<=?)\s*(\d+)\s*(?:%|percent)/i);
          if (maxWinMatch) {
            breakdownArgs.max_win = parseInt(maxWinMatch[1], 10);
            console.log(`[QueryEngine] ğŸ“Š BREAKDOWN: Extracted max_win=${breakdownArgs.max_win} from query (regex)`);
          }
        }
        
        // Extract limit for "maximum/most" queries (implies limit=1)
        // NOTE: "top" is excluded from superlative - it means "sorted by highest" not "limit 1"
        // Only apply limit=1 for definite superlatives like "the highest", "the maximum", "the best"
        // EXCEPTION: If user asks for comparison with "second highest", "second best", etc., need at least 2 rows
        const isDefiniteSuperlative = /\b(?:the\s+)?(?:maximum|max|highest|best|largest|lowest|minimum|min|smallest)\b/i.test(userQuestion);
        const isComparisonQuery = /\b(?:compare\s+(?:with|to)|second\s+(?:highest|best|largest|lowest|smallest)|how\s+does\s+it\s+compare|top\s+(?:two|2)|first\s+(?:two|2))\b/i.test(userQuestion);
        const explicitLimitMatch = userQuestion.match(/\b(?:top|first|bottom|last)\s+(\d+)\b/i);
        
        if (explicitLimitMatch) {
          breakdownArgs.limit = parseInt(explicitLimitMatch[1], 10);
          console.log(`[QueryEngine] ğŸ“Š BREAKDOWN: Extracted explicit limit=${breakdownArgs.limit} from query`);
        } else if (isComparisonQuery) {
          // User wants to compare highest with second highest - need at least 2 rows
          breakdownArgs.limit = 2;
          console.log(`[QueryEngine] ğŸ“Š BREAKDOWN: Comparison query detected (e.g., "compare with second highest") - setting limit=2`);
        } else if (isDefiniteSuperlative && !breakdownArgs.limit) {
          breakdownArgs.limit = 1;
          console.log(`[QueryEngine] ğŸ“Š BREAKDOWN: Definite superlative query detected - setting limit=1`);
        }
        // "top" without a number means "sorted by highest", no limit applied
        
        // For frequency-based queries (most used, most common, most frequent), set sort_by to project_count
        const isFrequencyQuery = /\b(?:most\s+)?(?:used|common|frequent|popular|repeated)\b/i.test(userQuestion);
        if (isFrequencyQuery && (matchedBreakdown.fn === 'get_top_titles' || matchedBreakdown.fn === 'get_top_tags')) {
          breakdownArgs.sort_by = 'project_count';
          console.log(`[QueryEngine] ğŸ“Š BREAKDOWN: Frequency query detected - setting sort_by=project_count`);
        }
        
        // Helper to copy all relevant filters from a context
        const copyFilters = (args: Record<string, any> | undefined) => {
          if (!args) return;
          // Core filters
          // Category filter (singular) from disambiguation selection
          if (args.category && !breakdownArgs.category) {
            breakdownArgs.category = args.category;
            if (args._category_already_applied) breakdownArgs._category_already_applied = args._category_already_applied;
            if (args._disambiguation_column) breakdownArgs._disambiguation_column = args._disambiguation_column;
            console.log(`[QueryEngine] ğŸ“Š INHERITED category="${args.category}" from previous context`);
          }
          if (args.project_type && !breakdownArgs.project_type) breakdownArgs.project_type = args.project_type;
          if (args.status && !breakdownArgs.status) breakdownArgs.status = args.status;
          if (args.categories && !breakdownArgs.categories) {
            breakdownArgs.categories = args.categories;
            // CRITICAL: Also preserve _explicit_category flag to ensure correct column (RequestCategory vs ProjectType)
            if (args._explicit_category) {
              breakdownArgs._explicit_category = args._explicit_category;
              console.log(`[QueryEngine] ğŸ“Š INHERITED _explicit_category flag - will filter on RequestCategory`);
            }
          }
          // Inherit state filters from context (these are legitimate filters from previous queries, not extracted from current question)
          if (args.state_code && !breakdownArgs.state_code) breakdownArgs.state_code = args.state_code;
          if (args.states && !breakdownArgs.states) breakdownArgs.states = args.states;
          if (args.company && !breakdownArgs.company) breakdownArgs.company = args.company;
          if (args.client && !breakdownArgs.client) breakdownArgs.client = args.client;
          // Fee filters
          if (args.min_fee && !breakdownArgs.min_fee) breakdownArgs.min_fee = args.min_fee;
          if (args.max_fee && !breakdownArgs.max_fee) breakdownArgs.max_fee = args.max_fee;
          // Date filters
          if (args.start_date && !breakdownArgs.start_date) breakdownArgs.start_date = args.start_date;
          if (args.end_date && !breakdownArgs.end_date) breakdownArgs.end_date = args.end_date;
          // Win rate filters
          if (args.min_win && !breakdownArgs.min_win) breakdownArgs.min_win = args.min_win;
          if (args.max_win && !breakdownArgs.max_win) breakdownArgs.max_win = args.max_win;
          // Contact/POC filters
          if (args.poc && !breakdownArgs.poc) breakdownArgs.poc = args.poc;
          if (args.contact && !breakdownArgs.contact) breakdownArgs.contact = args.contact;
          // Size filter
          if (args.size && !breakdownArgs.size) breakdownArgs.size = args.size;
          // Keyword/description filter
          if (args.keyword && !breakdownArgs.keyword) breakdownArgs.keyword = args.keyword;
          // Tags filter
          if (args.tags && !breakdownArgs.tags) breakdownArgs.tags = args.tags;
        };
        
        // Priority: originalContext (root) first, then previousContext as fallback
        copyFilters(originalContext?.arguments);
        copyFilters(previousContext?.arguments);
        
        // Also merge any newly extracted hints from the current query
        // EXCEPT: Don't inherit limit from LLM hints for title/tag aggregation queries
        // unless it was explicitly extracted from pattern (e.g., "top 5 titles")
        const hasExplicitLimit = breakdownArgs.limit !== undefined;
        const finalBreakdownArgs = mergeExtractedHints(breakdownArgs);
        
        // For title/tag queries, remove LLM-inherited limit if user didn't explicitly specify a number
        if ((matchedBreakdown.fn === 'get_top_titles' || matchedBreakdown.fn === 'get_top_tags') && !hasExplicitLimit) {
          delete finalBreakdownArgs.limit;
          console.log(`[QueryEngine] ğŸ“Š BREAKDOWN: Removed inherited limit for ${matchedBreakdown.fn} - user didn't specify explicit number`);
        }
        
        // For POC aggregation queries, remove the "poc" filter if it's just "POC" (the column name)
        // since we're aggregating BY poc, not filtering BY a specific poc name
        if (matchedBreakdown.fn === 'get_top_pocs') {
          if (finalBreakdownArgs.poc && /^poc$/i.test(finalBreakdownArgs.poc)) {
            delete finalBreakdownArgs.poc;
            console.log(`[QueryEngine] ğŸ“Š BREAKDOWN: Removed "POC" filter for get_top_pocs - aggregating BY poc, not filtering`);
          }
          if (finalBreakdownArgs.contact && /^(contact|point\s*of\s*contact)$/i.test(finalBreakdownArgs.contact)) {
            delete finalBreakdownArgs.contact;
            console.log(`[QueryEngine] ğŸ“Š BREAKDOWN: Removed generic contact filter for get_top_pocs`);
          }
        }
        
        // Convert "Closed" and "Open" status to appropriate status arrays
        if (finalBreakdownArgs.status && typeof finalBreakdownArgs.status === 'string') {
          const statusLower = finalBreakdownArgs.status.toLowerCase();
          if (statusLower === 'closed' || statusLower === 'close') {
            finalBreakdownArgs.status = ['Lost', 'No Go', 'Cancelled', 'Hold'];
            console.log(`[QueryEngine] ğŸ“Š BREAKDOWN: Converted "closed" to ["Lost", "No Go", "Cancelled"]`);
          } else if (statusLower === 'open') {
            finalBreakdownArgs.status = ['Proposal Development', 'Qualified Lead', 'Submitted', 'Won'];
            console.log(`[QueryEngine] ğŸ“Š BREAKDOWN: Converted "open" to ["Proposal Development", "Qualified Lead", "Submitted", "Won", "Lead", "In Progress", "Hold"]`);
          }
        }
        
        // For category breakdown queries, strip "market" if it was extracted from "market category" phrase
        // "market category" is a descriptor (like "segment"), not a category name filter
        if (matchedBreakdown.fn === 'get_category_breakdown' && /\bmarket\s+categor/i.test(userQuestion)) {
          // Remove "market" from category/categories
          if (finalBreakdownArgs.category === 'market' || finalBreakdownArgs.category === 'Market') {
            delete finalBreakdownArgs.category;
            console.log(`[QueryEngine] ğŸ“Š BREAKDOWN: Removed "market" from category - it's a descriptor, not a filter`);
          }
          if (Array.isArray(finalBreakdownArgs.categories)) {
            const original = finalBreakdownArgs.categories.length;
            finalBreakdownArgs.categories = finalBreakdownArgs.categories.filter(
              (c: string) => c.toLowerCase() !== 'market'
            );
            if (finalBreakdownArgs.categories.length === 0) {
              delete finalBreakdownArgs.categories;
            }
            if (original !== (finalBreakdownArgs.categories?.length || 0)) {
              console.log(`[QueryEngine] ğŸ“Š BREAKDOWN: Removed "market" from categories - it's a descriptor, not a filter`);
            }
          }
        }
        
        console.log(`[QueryEngine] ğŸ“Š BREAKDOWN: Carrying forward filters: ${JSON.stringify(finalBreakdownArgs)}`);
        
        classification = {
          function_name: matchedBreakdown.fn,
          arguments: finalBreakdownArgs,
        };
        
        // For size distribution queries, calculate percentiles first
        if (matchedBreakdown.fn === 'get_size_distribution') {
          console.log(`[QueryEngine] ğŸ“Š Calculating dynamic percentiles for size distribution...`);
          await this.sizeCalculator.calculatePercentiles(externalDbQuery, false, TABLE);
          
          // Strip size tier keywords from tags - they are NOT real tags, just size category names
          const SIZE_TIER_KEYWORDS = ['mega', 'large', 'medium', 'small', 'micro'];
          if (finalBreakdownArgs.tags && Array.isArray(finalBreakdownArgs.tags)) {
            const originalTags = finalBreakdownArgs.tags;
            finalBreakdownArgs.tags = finalBreakdownArgs.tags.filter(
              (tag: string) => !SIZE_TIER_KEYWORDS.includes(tag.toLowerCase())
            );
            if (finalBreakdownArgs.tags.length === 0) {
              delete finalBreakdownArgs.tags;
            }
            if (originalTags.length !== (finalBreakdownArgs.tags?.length || 0)) {
              console.log(`[QueryEngine] ğŸ“Š Removed size tier keywords from tags: ${originalTags.join(', ')}`);
            }
          }
        }
        
        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        // CRITICAL FIX: "this year" detection for PRE-CLASSIFIED queries
        // These queries BYPASS preprocessQuery, so we must fix date args here
        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        const thisYearPatternPreClass = /\b(this\s+year|current\s+year|starting\s+this\s+year)\b/i;
        if (thisYearPatternPreClass.test(userQuestion)) {
          const currentYear = new Date().getFullYear();
          console.log(`[DateFix-PreClass] ğŸ“… Detected "this year" in pre-classified query: "${userQuestion}"`);
          console.log(`[DateFix-PreClass]   BEFORE: start_date=${finalBreakdownArgs.start_date}, end_date=${finalBreakdownArgs.end_date}, year=${finalBreakdownArgs.year}`);
          
          // Set year parameter and remove date parameters
          if (!finalBreakdownArgs.year) {
            finalBreakdownArgs.year = currentYear;
            console.log(`[DateFix-PreClass] ğŸ“… Set year=${currentYear}`);
          }
          if (finalBreakdownArgs.start_date) {
            console.log(`[DateFix-PreClass] ğŸ“… Removing start_date=${finalBreakdownArgs.start_date}`);
            delete finalBreakdownArgs.start_date;
          }
          if (finalBreakdownArgs.end_date) {
            console.log(`[DateFix-PreClass] ğŸ“… Removing end_date=${finalBreakdownArgs.end_date}`);
            delete finalBreakdownArgs.end_date;
          }
          
          // Update classification.arguments as well
          classification.arguments = finalBreakdownArgs;
          console.log(`[DateFix-PreClass]   AFTER: year=${finalBreakdownArgs.year}, start_date=${finalBreakdownArgs.start_date}, end_date=${finalBreakdownArgs.end_date}`);
        }
        
        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        // GENERIC GARBAGE CLEANUP: Remove invalid parameter values from ANY column
        // This runs BEFORE routing decisions to ensure clean data
        // IMPORTANT: We must DELETE garbage keys from finalBreakdownArgs, not just copy cleaned values
        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        const ENTITY_PARAMS_TO_CLEAN = [
          'division', 'department', 'client', 'company', 'poc', 'status',
          'category', 'project_type', 'state', 'state_code', 'keyword',
          'sector', 'region', 'office', 'group'
        ];
        const cleanedBreakdownArgs = cleanupGarbageValues(finalBreakdownArgs, userQuestion);
        // Delete keys that were removed by cleanup
        for (const param of ENTITY_PARAMS_TO_CLEAN) {
          if (finalBreakdownArgs[param] !== undefined && cleanedBreakdownArgs[param] === undefined) {
            console.log(`[QueryEngine] ğŸ§¹ Applying garbage cleanup: deleting ${param}="${finalBreakdownArgs[param]}"`);
            delete finalBreakdownArgs[param];
          }
        }
        Object.assign(finalBreakdownArgs, cleanedBreakdownArgs);
        
        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        // GENERIC BREAKDOWN DETECTION: Detect "by <column>" patterns dynamically
        // Instead of hardcoding division/department only, this handles ANY column
        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        const { breakdownColumn, breakdownFunction } = detectBreakdownPattern(userQuestion);
        
        // SKIP breakdown detection if disambiguation is active
        const hasDisambiguationOverride = preAppliedFilters._disambiguation_function || preAppliedFilters._client_already_applied || preAppliedFilters._company_already_applied || preAppliedFilters._poc_already_applied;
        if (breakdownFunction && !hasDisambiguationOverride && !['get_division_breakdown', 'get_department_breakdown', 
            'get_revenue_by_division', 'get_revenue_by_department', 'compare_divisions', 
            'compare_departments'].includes(classification.function_name)) {
          console.log(`[QueryEngine] ğŸ” GENERIC BREAKDOWN: Detected "by ${breakdownColumn}" â†’ routing to ${breakdownFunction}`);
          classification.function_name = breakdownFunction;
          
          // Remove the column value if it was incorrectly extracted as a filter
          // (e.g., "by division" should GROUP BY division, not filter by a specific one)
          if (breakdownColumn && finalBreakdownArgs[breakdownColumn]) {
            console.log(`[QueryEngine] ğŸ§¹ Removing ${breakdownColumn} filter for breakdown query (grouping, not filtering)`);
            delete finalBreakdownArgs[breakdownColumn];
          }
          classification.arguments = finalBreakdownArgs;
        }
        
        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        // COMBO QUERY ROUTING: Filter + Specific Entity â†’ get_projects_by_combined_filters
        // Only triggers when a VALID entity value is present (not garbage, not breakdown request)
        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        const divisionValue = finalBreakdownArgs.division;
        const hasValidDivision = divisionValue && typeof divisionValue === 'string' && divisionValue.length > 0;
        const hasCategory = finalBreakdownArgs.categories && finalBreakdownArgs.categories.length > 0;
        
        // Only route to combined filters if we have a valid division AND category AND not asking for breakdown
        if (hasValidDivision && hasCategory && !breakdownFunction) {
          console.log(`[QueryEngine] ğŸ“Š COMBO QUERY: Detected division="${divisionValue}" + category â†’ routing to get_projects_by_combined_filters`);
          classification.function_name = 'get_projects_by_combined_filters';
          if (!finalBreakdownArgs._explicit_category) {
            finalBreakdownArgs._explicit_category = true;
          }
          classification.arguments = finalBreakdownArgs;
        }
        
        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        // AI-FIRST MODE: Skip early execution/return - let AI classify first
        // Store extracted params and continue to AI classification section
        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        if (!AI_FIRST_MODE && !disambiguationOverride) {
          // LEGACY MODE: Skip LLM classification and go straight to execution
          // Apply hallucination guard BEFORE normalizing to ensure cleaned args are used
          classification.arguments = stripHallucinatedGeography(classification.arguments, userQuestion);
          const normalizedArgs = normalizeClassificationArguments(classification.arguments, userQuestion);
      console.log(`[QueryEngine] ğŸ” DEBUG PRE-EXECUTE: classification.arguments.category="${classification?.arguments?.category}", _category_already_applied=${classification?.arguments?._category_already_applied}`);
          const results = await this.executeQuery(classification.function_name, normalizedArgs, externalDbQuery, userQuestion);
          
          // Calculate summary stats and chart config (like processQuery does)
          const summary = this.calculateSummaryStats(results.data);
          const chartConfig = this.generateChartConfig(results.data, classification.function_name);
          
          return {
            ...results,
            summary,
            chart_config: chartConfig,
            function_name: classification.function_name,
            arguments: normalizedArgs,
          };
        } else {
          // AI-FIRST MODE: Store regex-extracted parameters for later merge with AI classification
          console.log(`[QueryEngine] ğŸ¤– AI-FIRST MODE: Skipping regex classification, will merge params with AI result`);
          console.log(`[QueryEngine] ğŸ¤– Regex suggested fn: ${classification.function_name}`);
          console.log(`[QueryEngine] ğŸ¤– Regex extracted params:`, JSON.stringify(finalBreakdownArgs, null, 2));
          // Store for later use (these will be merged into AI classification)
          extractedHints._regexFunctionHint = classification.function_name;
          Object.assign(extractedHints, finalBreakdownArgs);
          // CRITICAL: Reset classification so we fall through to AI classification
          classification = { function_name: '', arguments: {} };
        }
      }
      
      // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
      // REGION OVERRIDE: Route "west region", "midwest states", etc. to filter by Region column
      // The Region column contains values like 'NA - South', 'NA - West', 'NA - Northeast', etc.
      // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
      // Map user terms to Region column values (database has 'NA - South', 'NA - West', etc.)
      const REGION_COLUMN_MAP: Record<string, string[]> = {
        'west': ['NA - West', 'West'],           // Include legacy 'West' value
        'midwest': ['NA - Midwest', 'Midwest'],  // Include legacy if exists
        'south': ['NA - South', 'South'],        // Include legacy 'South' value
        'northeast': ['NA - Northeast', 'Northeast'],
        'southwest': ['NA - Southwest', 'Southwest'],
        'southeast': ['NA - Southeast', 'Southeast'],
        'northwest': ['NA - Northwest', 'Northwest'],
        'pacific': ['NA - West', 'West'],        // Pacific is part of West
        'east': ['NA - East', 'East', 'NA - Northeast', 'Northeast'],  // East maps to East or Northeast
        'central': ['Central', 'Central Asia'],  // Central region values in DB
      };
      
      // Keep state map as fallback only - prefer Region column
      const REGION_STATE_MAP: Record<string, string[]> = {
        'west': ['California', 'Oregon', 'Washington', 'Nevada', 'Arizona', 'Utah', 'Colorado', 'New Mexico', 'Hawaii', 'Alaska', 'Idaho', 'Montana', 'Wyoming'],
        'midwest': ['Illinois', 'Indiana', 'Iowa', 'Kansas', 'Michigan', 'Minnesota', 'Missouri', 'Nebraska', 'North Dakota', 'Ohio', 'South Dakota', 'Wisconsin'],
        'south': ['Alabama', 'Arkansas', 'Delaware', 'Florida', 'Georgia', 'Kentucky', 'Louisiana', 'Maryland', 'Mississippi', 'North Carolina', 'Oklahoma', 'South Carolina', 'Tennessee', 'Texas', 'Virginia', 'West Virginia', 'District of Columbia'],
        'northeast': ['Connecticut', 'Maine', 'Massachusetts', 'New Hampshire', 'New Jersey', 'New York', 'Pennsylvania', 'Rhode Island', 'Vermont'],
        'southwest': ['Arizona', 'New Mexico', 'Texas', 'Oklahoma'],
        'southeast': ['Florida', 'Georgia', 'Alabama', 'Mississippi', 'Louisiana', 'South Carolina', 'North Carolina', 'Tennessee', 'Kentucky', 'Virginia', 'West Virginia'],
        'northwest': ['Washington', 'Oregon', 'Idaho', 'Montana', 'Wyoming'],
        'pacific': ['California', 'Oregon', 'Washington', 'Hawaii', 'Alaska'],
      };
      
      // Region detection patterns
      const regionPatterns = [
        /\b(?:in|from|for|the)\s+(east(?:ern)?|west(?:ern)?|midwest(?:ern)?|south(?:ern)?|north(?:east(?:ern)?)?|south(?:west|east)(?:ern)?|north(?:west)?(?:ern)?|pacific|central)\s+(?:region|states?|area|coast)?\b/i,
        /\b(east(?:ern)?|west(?:ern)?|midwest(?:ern)?|south(?:ern)?|north(?:east(?:ern)?)?|south(?:west|east)(?:ern)?|north(?:west)?(?:ern)?|pacific|central)\s+(?:region|states?|area|coast)\b/i,
      ];
      
      let regionMatch = null;
      let detectedRegion: string | null = null;
      for (const pattern of regionPatterns) {
        regionMatch = userQuestion.match(pattern);
        if (regionMatch) {
          const rawRegion = regionMatch[1].toLowerCase();
          // Normalize region name (e.g., "western" -> "west", "northeastern" -> "northeast")
          if (rawRegion.startsWith('west')) detectedRegion = 'west';
          else if (rawRegion.startsWith('midwest')) detectedRegion = 'midwest';
          else if (rawRegion.startsWith('south') && rawRegion.includes('east')) detectedRegion = 'southeast';
          else if (rawRegion.startsWith('south') && rawRegion.includes('west')) detectedRegion = 'southwest';
          else if (rawRegion.startsWith('south')) detectedRegion = 'south';
          else if (rawRegion.startsWith('north') && rawRegion.includes('east')) detectedRegion = 'northeast';
          else if (rawRegion.startsWith('north') && rawRegion.includes('west')) detectedRegion = 'northwest';
          else if (rawRegion === 'pacific') detectedRegion = 'pacific';
          else if (rawRegion === 'central') detectedRegion = 'central';
          else if (rawRegion.startsWith('east')) detectedRegion = 'east';
          break;
        }
      }
      
      // Check if query has additional filters beyond just region
      // If so, we should NOT short-circuit and instead let LLM extract all filters, then merge the region
      const hasAdditionalRegionFilters = /\b(?:education|healthcare|transportation|aviation|buildings|water|energy|residential|hospitality|industrial|mission\s*critical|disaster|humanitarian|other|category|categories)\b/i.test(userQuestion) ||
                                          /\b(?:fee|cost|revenue|budget|greater\s+than|less\s+than|above|below|more\s+than|under)\s*\$?\s*[\d,]+/i.test(userQuestion) ||
                                          /\b(?:win\s*%|win\s+rate|success\s+rate)\s*(?:above|below|greater|less|over|under)/i.test(userQuestion) ||
                                          /\b(?:status|company|client|poc|point\s+of\s+contact)\b/i.test(userQuestion) ||
                                          // Add statistical terms - don't short-circuit for complex stats queries
                                          /\b(?:variance|sum|average|mean|median|std\s*dev|standard\s+deviation|distribution|skew|statistics?)\b/i.test(userQuestion);
      
      // EXCLUSION CHECK: If user says "except [region]", "excluding [region]", don't short-circuit
      // because short-circuit always adds inclusion states, not exclusion
      const hasExclusionPattern = /\b(except|excluding|exclude|not\s+in|but\s+not|outside\s+of?)\s+(the\s+)?(west|midwest|south|north|east|pacific|mountain|southeast|southwest|northeast|northwest)/i.test(userQuestion);
      
      console.log(`[QueryEngine] ğŸ” REGION DECISION: detectedRegion=${detectedRegion}, hasAdditionalFilters=${hasAdditionalRegionFilters}, hasExclusionPattern=${hasExclusionPattern}`);
      
      if (detectedRegion && REGION_COLUMN_MAP[detectedRegion] && !hasAdditionalRegionFilters && !hasExclusionPattern) {
        const regionColumnValues = REGION_COLUMN_MAP[detectedRegion];
        console.log(`[QueryEngine] ğŸ—ºï¸ REGION OVERRIDE: Detected "${detectedRegion}" region â†’ filtering by Region column: ${regionColumnValues.join(', ')}`);
        
        // Use get_largest_projects with regions filter (uses Region column directly!)
        // Use mergeExtractedHints to include any other filters extracted from the query
        classification = {
          function_name: 'get_largest_projects',
          arguments: mergeExtractedHints({ 
            regions: regionColumnValues  // Pass array of Region column values - handled by buildAdditionalFilters
          }),
        };
        
        // AI-FIRST MODE: Store region info and continue to AI classification
        if (!AI_FIRST_MODE && !disambiguationOverride) {
          // Skip LLM classification and go straight to execution
          classification.arguments = stripHallucinatedGeography(classification.arguments, userQuestion);
          const normalizedArgs = normalizeClassificationArguments(classification.arguments, userQuestion);
      console.log(`[QueryEngine] ğŸ” DEBUG PRE-EXECUTE: classification.arguments.category="${classification?.arguments?.category}", _category_already_applied=${classification?.arguments?._category_already_applied}`);
          const results = await this.executeQuery(classification.function_name, normalizedArgs, externalDbQuery, userQuestion);
          
          // Calculate summary stats and chart config (like processQuery does)
          const summary = this.calculateSummaryStats(results.data);
          const chartConfig = this.generateChartConfig(results.data, classification.function_name);
          
          return {
            ...results,
            summary,
            chart_config: chartConfig,
            function_name: classification.function_name,
            arguments: normalizedArgs,
          };
        } else {
          console.log(`[QueryEngine] ğŸ¤– AI-FIRST MODE: Storing region values for AI merge`);
          extractedHints.regions = regionColumnValues;
          // CRITICAL: Reset classification so we fall through to AI classification
          classification = { function_name: '', arguments: {} };
        }
      }
      
      // If region was detected but there are additional filters, save region for later merge with LLM results
      // CRITICAL: Do NOT pre-detect region for EXCLUSION queries - those need exclude_states, not states
      let preDetectedRegionValues: string[] | null = null;
      if (detectedRegion && REGION_COLUMN_MAP[detectedRegion] && hasAdditionalRegionFilters && !hasExclusionPattern) {
        preDetectedRegionValues = REGION_COLUMN_MAP[detectedRegion];
        console.log(`[QueryEngine] ğŸ—ºï¸ REGION PRE-DETECT: "${detectedRegion}" region detected with additional filters â†’ will merge after LLM classification`);
      } else if (hasExclusionPattern && detectedRegion) {
        console.log(`[QueryEngine] ğŸš« REGION PRE-DETECT SKIPPED: Exclusion pattern detected for "${detectedRegion}" - will set exclude_regions later`);
      }
      
      // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
      // SIMPLE COUNT BY YEAR OVERRIDE: Route "how many deals/projects started this year/in 2024"
      // queries to get_projects_by_year for accurate, simple counts
      // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
      const yearCountPatterns = [
        // "how many deals started this year", "how many projects this year"
        /\b(?:how\s+many|count|total|number\s+of)\s+(?:deals?|projects?|opportunities?)\s+(?:have\s+)?(?:started|began|begin|starting|beginning|created|opened)\s+(?:in\s+)?this\s+year\b/i,
        // "how many deals started in 2024/2025"
        /\b(?:how\s+many|count|total|number\s+of)\s+(?:deals?|projects?|opportunities?)\s+(?:have\s+)?(?:started|began|begin|starting|beginning|created|opened)\s+(?:in\s+)?(\d{4})\b/i,
        // "how many deals this year"
        /\b(?:how\s+many|count|total|number\s+of)\s+(?:deals?|projects?|opportunities?)\s+(?:in\s+)?this\s+year\b/i,
        // "deals started this year" (implicit count)
        /\b(?:deals?|projects?|opportunities?)\s+(?:that\s+)?(?:have\s+)?(?:started|began|begin|starting)\s+(?:in\s+)?this\s+year\b/i,
      ];
      
      let yearCountMatch = null;
      let countYear = new Date().getFullYear(); // Default to current year
      for (const pattern of yearCountPatterns) {
        yearCountMatch = userQuestion.match(pattern);
        if (yearCountMatch) {
          // Check if a specific year was captured
          if (yearCountMatch[1] && /^\d{4}$/.test(yearCountMatch[1])) {
            countYear = parseInt(yearCountMatch[1], 10);
          }
          break;
        }
      }
      
      // Check if the query has additional filters that should NOT use the simple count override
      // If user asks "projects this year with win rate above 80%", we should NOT use simple override
      const hasAdditionalFilters = /\b(?:win\s*%|win\s+rate|success\s+rate|fee|revenue|budget|status|state|region|company|client|category|tag|size|large|small|mega|micro)\b/i.test(userQuestion);
      
      if (yearCountMatch && !isAiAnalysisFollowUp && !hasFollowUpContext && !hasAdditionalFilters) {
        console.log(`[QueryEngine] ğŸ“… SIMPLE COUNT OVERRIDE: Detected "${userQuestion}" â†’ get_projects_by_year(${countYear})`);
        
        // Use mergeExtractedHints to include any other filters extracted from the query
        classification = {
          function_name: 'get_projects_by_year',
          arguments: mergeExtractedHints({ 
            year: countYear
          }),
        };
        
        // AI-FIRST MODE: Store year info and continue to AI classification
        if (!AI_FIRST_MODE && !disambiguationOverride) {
          // Skip LLM classification and go straight to execution
          classification.arguments = stripHallucinatedGeography(classification.arguments, userQuestion);
          const normalizedArgs = normalizeClassificationArguments(classification.arguments, userQuestion);
      console.log(`[QueryEngine] ğŸ” DEBUG PRE-EXECUTE: classification.arguments.category="${classification?.arguments?.category}", _category_already_applied=${classification?.arguments?._category_already_applied}`);
          const results = await this.executeQuery(classification.function_name, normalizedArgs, externalDbQuery, userQuestion);
          
          // Calculate summary stats and chart config (like processQuery does)
          const summary = this.calculateSummaryStats(results.data);
          const chartConfig = this.generateChartConfig(results.data, classification.function_name);
          
          return {
            ...results,
            summary,
            chart_config: chartConfig,
            function_name: classification.function_name,
            arguments: normalizedArgs,
          };
        } else {
          console.log(`[QueryEngine] ğŸ¤– AI-FIRST MODE: Storing year for AI merge`);
          extractedHints.year = countYear;
          // CRITICAL: Reset classification so we fall through to AI classification
          classification = { function_name: '', arguments: {} };
        }
      }
      
      // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
      // CATEGORY COUNT OVERRIDE: When user asks "how many deals/projects belong to X category"
      // or "how many in the X category", route to get_projects_by_category with the category filter
      // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
      const categoryCountPatterns = [
        // "how many deals belong to the Transportation category"
        /\b(?:how\s+many|count|number\s+of)\s+(?:deals?|projects?|opportunities?)\s+(?:belong|are|fall)\s+(?:to|in|under)\s+(?:the\s+)?["']?([A-Za-z\s\/]+?)["']?\s*(?:category|sector|segment|vertical)?[\s?]*$/i,
        // "how many in the Transportation category"
        /\b(?:how\s+many|count|number\s+of)\s+(?:deals?|projects?|opportunities?)?\s*(?:in|under)\s+(?:the\s+)?["']?([A-Za-z\s\/]+?)["']?\s*(?:category|sector|segment|vertical)[\s?]*$/i,
        // "deals in Transportation category" (count implied)
        /\b(?:deals?|projects?|opportunities?)\s+(?:in|under|belonging\s+to)\s+(?:the\s+)?["']?([A-Za-z\s\/]+?)["']?\s*(?:category|sector|segment|vertical)[\s?]*$/i,
      ];
      
      let categoryCountMatch: RegExpMatchArray | null = null;
      for (const pattern of categoryCountPatterns) {
        categoryCountMatch = userQuestion.match(pattern);
        if (categoryCountMatch) break;
      }
      
      if (categoryCountMatch && !isAiAnalysisFollowUp && !hasFollowUpContext) {
        const extractedCategory = categoryCountMatch[1].trim();
        console.log(`[QueryEngine] ğŸ“Š CATEGORY COUNT OVERRIDE: Detected category count query for "${extractedCategory}"`);
        
        // Validate the category exists in known categories
        const validCategories = [
          'Aviation', 'Buildings', 'Disaster Relief and Recovery', 'Education',
          'Education and Institutions', 'Energy', 'Healthcare', 'Hospitality',
          'Humanitarian and Environmental', 'Industrial', 'Mission Critical',
          'Other', 'Residential', 'Transportation', 'Water / Wastewater'
        ];
        
        // Find best matching category (case-insensitive, partial match)
        let matchedCategory = validCategories.find(c => 
          c.toLowerCase() === extractedCategory.toLowerCase()
        );
        
        if (!matchedCategory) {
          // Try partial match
          matchedCategory = validCategories.find(c => 
            c.toLowerCase().includes(extractedCategory.toLowerCase()) ||
            extractedCategory.toLowerCase().includes(c.toLowerCase())
          );
        }
        
        if (matchedCategory) {
          console.log(`[QueryEngine] âœ“ Matched category: "${matchedCategory}"`);
          
          // Use mergeExtractedHints to include all extracted filters
          classification = {
            function_name: 'get_projects_by_category',
            arguments: mergeExtractedHints({ 
              categories: [matchedCategory],
              _explicit_category: true
            }),
          };
          
          // AI-FIRST MODE: Store category info and continue to AI classification
          if (!AI_FIRST_MODE && !disambiguationOverride) {
            // Skip LLM classification and go straight to execution
            classification.arguments = stripHallucinatedGeography(classification.arguments, userQuestion);
            const normalizedArgs = normalizeClassificationArguments(classification.arguments, userQuestion);
      console.log(`[QueryEngine] ğŸ” DEBUG PRE-EXECUTE: classification.arguments.category="${classification?.arguments?.category}", _category_already_applied=${classification?.arguments?._category_already_applied}`);
            const results = await this.executeQuery(classification.function_name, normalizedArgs, externalDbQuery, userQuestion);
            
            // Calculate summary stats and chart config (like processQuery does)
            const summary = this.calculateSummaryStats(results.data);
            const chartConfig = this.generateChartConfig(results.data, classification.function_name);
            
            return {
              ...results,
              summary,
              chart_config: chartConfig,
              function_name: classification.function_name,
              arguments: normalizedArgs,
            };
          } else {
            console.log(`[QueryEngine] ğŸ¤– AI-FIRST MODE: Storing category for AI merge`);
            extractedHints.categories = [matchedCategory];
            extractedHints._explicit_category = true;
            // CRITICAL: Reset classification so we fall through to AI classification
            classification = { function_name: '', arguments: {} };
          }
        } else {
          console.log(`[QueryEngine] âš ï¸ Category "${extractedCategory}" not found in valid categories, falling through to LLM`);
        }
      }
      
      // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
      // REQUEST CATEGORY EXPLICIT OVERRIDE: When user explicitly says "request category is X",
      // route to get_projects_by_category with the exact category value
      // Also extract any fee filters from the query
      // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
      if (requestCategoryMatch && !isAiAnalysisFollowUp && !hasFollowUpContext) {
        const categoryValue = requestCategoryMatch[1].trim();
        console.log(`[QueryEngine] ğŸ“ REQUEST CATEGORY OVERRIDE: Found explicit "request category is ${categoryValue}"`);
        
        // Build arguments with category using mergeExtractedHints to include all filters
        const args: Record<string, any> = mergeExtractedHints({ 
          categories: [categoryValue],
          _explicit_category: true  // Flag to prevent safety net from moving to project_type
        });
        
        // Also extract fee filter if present (e.g., "revenue exceeds 4M", "fee over 5 million")
        const feePatterns = [
          /(?:revenue|fee|budget|cost|value)\s+(?:exceeds?|over|above|greater\s+than|>)\s+(\$?[\d,.]+)\s*(m|million|k|thousand|b|billion)?/i,
          /(?:revenue|fee|budget|cost|value)\s+(?:is\s+)?(?:at\s+least|minimum|min)\s+(\$?[\d,.]+)\s*(m|million|k|thousand|b|billion)?/i,
          /(?:more\s+than|at\s+least|minimum|over)\s+(\$?[\d,.]+)\s*(m|million|k|thousand|b|billion)?\s+(?:revenue|fee|budget|in\s+fees?)?/i,
        ];
        
        for (const pattern of feePatterns) {
          const feeMatch = userQuestion.match(pattern);
          if (feeMatch) {
            let value = parseFloat(feeMatch[1].replace(/[$,]/g, ''));
            const multiplier = (feeMatch[2] || '').toLowerCase();
            if (multiplier === 'm' || multiplier === 'million') value *= 1000000;
            else if (multiplier === 'k' || multiplier === 'thousand') value *= 1000;
            else if (multiplier === 'b' || multiplier === 'billion') value *= 1000000000;
            args.min_fee = value;
            console.log(`[QueryEngine] ğŸ’° REQUEST CATEGORY OVERRIDE: Extracted min_fee=${value}`);
            break;
          }
        }
        
        classification = {
          function_name: 'get_projects_by_category',
          arguments: args,
        };
        
        // AI-FIRST MODE: Store request category info and continue to AI classification
        if (!AI_FIRST_MODE && !disambiguationOverride) {
          // Skip LLM classification and go straight to execution
          classification.arguments = stripHallucinatedGeography(classification.arguments, userQuestion);
          const normalizedArgs = normalizeClassificationArguments(classification.arguments, userQuestion);
      console.log(`[QueryEngine] ğŸ” DEBUG PRE-EXECUTE: classification.arguments.category="${classification?.arguments?.category}", _category_already_applied=${classification?.arguments?._category_already_applied}`);
          const results = await this.executeQuery(classification.function_name, normalizedArgs, externalDbQuery, userQuestion);
          
          // Calculate summary stats and chart config (like processQuery does)
          const summary = this.calculateSummaryStats(results.data);
          const chartConfig = this.generateChartConfig(results.data, classification.function_name);
          
          return {
            ...results,
            summary,
            chart_config: chartConfig,
            function_name: classification.function_name,
            arguments: normalizedArgs,
          };
        } else {
          console.log(`[QueryEngine] ğŸ¤– AI-FIRST MODE: Storing request category for AI merge`);
          Object.assign(extractedHints, args);
          // CRITICAL: Reset classification so we fall through to AI classification
          classification = { function_name: '', arguments: {} };
        }
      }
      
      // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
      // SERVICE TYPE OVERRIDE: Route "service type X" or "X servicetype" queries
      // to ServiceType column filter using get_projects_by_service_type
      // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
      const serviceTypePatterns = [
        // "Architecture servicetype" or "Architecture service type"
        /\b(\w+)\s+service[-\s]?types?\b/i,
        // "servicetype Architecture" or "service type is Architecture"
        /\bservice[-\s]?types?\s+(?:is|:|=)?\s*(\w+)\b/i,
      ];
      
      let serviceTypeMatch: RegExpMatchArray | null = null;
      for (const pattern of serviceTypePatterns) {
        serviceTypeMatch = userQuestion.match(pattern);
        if (serviceTypeMatch) break;
      }
      
      // Skip SERVICE TYPE OVERRIDE if this is a disambiguation query (has [filter by ...] tag)
      // The disambiguation tag uses "Service Type:" which would incorrectly match pattern 1
      const hasDisambiguationTag = /\[filter by [^:]+:/i.test(userQuestion);
      
      if (serviceTypeMatch && !isAiAnalysisFollowUp && !hasFollowUpContext && !hasDisambiguationTag) {
        const serviceTypeValue = serviceTypeMatch[1].trim();
        console.log(`[QueryEngine] ğŸ·ï¸ SERVICE TYPE OVERRIDE: Found explicit "service type is ${serviceTypeValue}"`);
        
        classification = {
          function_name: 'get_projects_by_service_type',
          arguments: {
            service_type: serviceTypeValue,
          },
        };
        
        // Skip LLM classification and go straight to execution
        classification.arguments = stripHallucinatedGeography(classification.arguments, userQuestion);
        const normalizedArgs = normalizeClassificationArguments(classification.arguments, userQuestion);
      console.log(`[QueryEngine] ğŸ” DEBUG PRE-EXECUTE: classification.arguments.category="${classification?.arguments?.category}", _category_already_applied=${classification?.arguments?._category_already_applied}`);
        const results = await this.executeQuery(classification.function_name, normalizedArgs, externalDbQuery, userQuestion);
        
        // Calculate summary stats and chart config
        const summary = this.calculateSummaryStats(results.data);
        const chartConfig = this.generateChartConfig(results.data, classification.function_name);
        
        return {
          ...results,
          summary,
          chart_config: chartConfig,
          function_name: classification.function_name,
          arguments: normalizedArgs,
        };
      }
      
      // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
      // WIN RATE EXACT MATCH OVERRIDE: Route "100% success rate", "100% win rate" queries
      // to get_projects_by_win_range with exact match (min_win = max_win = 100)
      // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
      const exactWinRatePatterns = [
        // "have a 100% success rate", "with 100% win rate", "100% success rate"
        /\b(?:have|with|has)\s+(?:a\s+)?(100|0)\s*%?\s*(?:win\s*%?|win\s+rate|success\s+rate|probability)/i,
        // "100% win rate", "100% success rate"
        /\b(100|0)\s*%\s*(?:win\s*%?|win\s+rate|success\s+rate|probability)/i,
        // "deals with 100% win"
        /(?:opportunities?|projects?|deals?)\s+(?:with|having|where)\s+(?:a\s+)?(100|0)\s*%?\s*(?:win|success)/i,
      ];
      
      let exactWinMatch = null;
      let exactWinValue = null;
      for (const pattern of exactWinRatePatterns) {
        exactWinMatch = userQuestion.match(pattern);
        if (exactWinMatch) {
          exactWinValue = parseFloat(exactWinMatch[1]);
          break;
        }
      }
      
      if (exactWinValue !== null && !isNaN(exactWinValue) && !isAiAnalysisFollowUp && !hasFollowUpContext) {
        console.log(`[QueryEngine] ğŸ“Š EXACT WIN RATE OVERRIDE: Detected "win rate = ${exactWinValue}%" - routing to get_projects_by_win_range`);
        
        // Use mergeExtractedHints to include any other filters
        classification = {
          function_name: 'get_projects_by_win_range',
          arguments: mergeExtractedHints({ 
            min_win: exactWinValue,
            max_win: exactWinValue  // Exact match
          }),
        };
        
        // Skip LLM classification and go straight to execution
        classification.arguments = stripHallucinatedGeography(classification.arguments, userQuestion);
        const normalizedArgs = normalizeClassificationArguments(classification.arguments, userQuestion);
      console.log(`[QueryEngine] ğŸ” DEBUG PRE-EXECUTE: classification.arguments.category="${classification?.arguments?.category}", _category_already_applied=${classification?.arguments?._category_already_applied}`);
        const results = await this.executeQuery(classification.function_name, normalizedArgs, externalDbQuery, userQuestion);
        
        // Calculate summary stats and chart config (like processQuery does)
        const summary = this.calculateSummaryStats(results.data);
        const chartConfig = this.generateChartConfig(results.data, classification.function_name);
        
        return {
          ...results,
          summary,
          chart_config: chartConfig,
          function_name: classification.function_name,
          arguments: normalizedArgs,
        };
      }
      
      // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
      // WIN RATE HINTS: Pass to LLM for combined filtering
      // Win rate filters are extracted by extractQueryContext() and passed
      // to the LLM as hints, allowing combination with other filters.
      // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
      if (extractedHints.min_win || extractedHints.max_win) {
        console.log(`[QueryEngine] ğŸ“Š Win rate hints passed to LLM: min_win=${extractedHints.min_win}, max_win=${extractedHints.max_win}`);
      }
      
      // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
      // PID LOOKUP DETERMINISTIC OVERRIDE: Route "PID X" queries to direct lookup
      // Handles: "PID 10924", "PID 10924 is handled by which firm", etc.
      // PID is stored in "Title" column as "PID XXXXX"
      // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
      const pidPattern = /\bPID\s*(\d+)\b/i;
      const pidMatch = userQuestion.match(pidPattern);
      
      if (pidMatch && !isAiAnalysisFollowUp && !hasFollowUpContext) {
        const pidValue = pidMatch[1];
        const pidSearchValue = `PID ${pidValue}`;
        console.log(`[QueryEngine] ğŸ” PID OVERRIDE: Detected PID lookup for "${pidSearchValue}" - executing direct query`);
        
        try {
          // PID is stored in "Title" column as "PID XXXXX"
          const pidSql = `SELECT * FROM "${TABLE}" WHERE "Title" = @p1`;
          const pidResults = await externalDbQuery(pidSql, [pidSearchValue]);
          
          if (pidResults.length > 0) {
            console.log(`[QueryEngine] âœ“ PID lookup found ${pidResults.length} result(s)`);
            
            // Calculate summary stats and chart config
            const summary = this.calculateSummaryStats(pidResults);
            const chartConfig = this.generateChartConfig(pidResults, 'get_project_by_pid');
            
            return {
              success: true,
              data: pidResults,
              row_count: pidResults.length,
              summary,
              chart_config: chartConfig,
              function_name: 'get_project_by_pid',
              arguments: { pid: pidValue },
            };
          } else {
            console.log(`[QueryEngine] âš ï¸ PID ${pidValue} not found in database`);
            // Fall through to LLM classification for helpful response
          }
        } catch (pidError) {
          console.error(`[QueryEngine] PID lookup error:`, pidError);
          // Fall through to LLM classification
        }
      }
      
      // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
      // HYBRID APPROACH: Fee patterns were already extracted by extractQueryContext()
      // The LLM now receives min_fee/max_fee as hints - no bypass needed
      // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
      if (extractedHints.min_fee || extractedHints.max_fee) {
        console.log(`[QueryEngine] ğŸ’° Fee hints passed to LLM: min_fee=${extractedHints.min_fee}, max_fee=${extractedHints.max_fee}`);
      }
      
      // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
      // HYBRID APPROACH: Project type hints were extracted by extractQueryContext()
      // The LLM now receives project_type as a hint - no bypass needed
      // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
      if (extractedHints.project_type) {
        console.log(`[QueryEngine] ğŸ—ï¸ Project type hint passed to LLM: ${extractedHints.project_type} (keyword: ${extractedHints._project_type_keyword})`);
      }
      
      // LEGACY CODE REMOVED - Project type override bypass was here
      // Now we let the LLM classify with hints and merge afterward
      const shouldApplyProjectTypeOverride = false; // Disabled - using hybrid approach
      
      console.log(`[QueryEngine] ğŸ” DEBUG BEFORE IF-ELSE: _module_context=${extractedHints._module_context}, modules=${JSON.stringify(extractedHints.modules)}, matchedDescriptionKeyword=${matchedDescriptionKeyword}`);
      // FILE TRACE FOR DEBUGGING
      if (shouldApplyProjectTypeOverride) {
        // This block is now disabled - kept for reference
        const projectTypeValue = extractedHints.project_type;
        console.log(`[QueryEngine] ğŸ—ï¸ PROJECT TYPE OVERRIDE (DISABLED): Would have used "${projectTypeValue}"`);
        
        const extractedArgs: Record<string, any> = { 
          project_type: projectTypeValue,
          _project_type_explicit: true
        };
        
        const hasWinPercentageContext = /\b(?:win\s*%?|win\s+rate|success\s+rate|probability)\b/i.test(questionForKeywords);
        
        if (hasWinPercentageContext) {
          // Extract min_win: "win rate above 50%", "win % greater than 30"
          const minWinPatterns = [
            /\b(?:win\s*%?|win\s+rate|success\s+rate)\s*(?:above|over|greater than|more than|>=?|at least|exceeding)\s*(\d+)\s*%?/i,
            /\b(?:above|over|greater than|more than|>=?|at least|exceeding)\s*(\d+)\s*%?\s*(?:win\s*%?|win\s+rate|success\s+rate)/i,
          ];
          
          for (const pattern of minWinPatterns) {
            const match = questionForKeywords.match(pattern);
            if (match) {
              extractedArgs.min_win = parseInt(match[1], 10);
              console.log(`[QueryEngine] ğŸ“Š PROJECT TYPE: Extracted min_win: ${extractedArgs.min_win}% from "${match[0]}"`);
              break;
            }
          }
          
          // Extract max_win: "win rate below 30%", "win % less than 50"
          const maxWinPatterns = [
            /\b(?:win\s*%?|win\s+rate|success\s+rate)\s*(?:below|under|less than|<|at most)\s*(\d+)\s*%?/i,
            /\b(?:below|under|less than|<|at most)\s*(\d+)\s*%?\s*(?:win\s*%?|win\s+rate|success\s+rate)/i,
          ];
          
          for (const pattern of maxWinPatterns) {
            const match = questionForKeywords.match(pattern);
            if (match) {
              extractedArgs.max_win = parseInt(match[1], 10);
              console.log(`[QueryEngine] ğŸ“Š PROJECT TYPE: Extracted max_win: ${extractedArgs.max_win}% from "${match[0]}"`);
              break;
            }
          }
        }
        
        // Only extract fee filters if there's no win percentage context
        // This prevents "win % less than 30%" from being misinterpreted as fee < $30M
        if (!hasWinPercentageContext) {
          // Parse min_fee: "cost/fee/budget greater than/over/above X", "cost > X", "more than X"
          const minFeePatterns = [
            /(?:cost|fee|budget|revenue|value)\s*(?:greater than|over|above|more than|>|exceeding|exceeds)\s*\$?([\d,]+(?:\.\d+)?)\s*(?:million|m|k|thousand)?/i,
            /(?:greater than|over|above|more than|>|exceeding)\s*\$?([\d,]+(?:\.\d+)?)\s*(?:million|m|k|thousand)?/i,
          ];
          
          for (const pattern of minFeePatterns) {
            const match = questionForKeywords.match(pattern);
            if (match) {
              let value = parseFloat(match[1].replace(/,/g, ''));
              const suffix = match[0].toLowerCase();
              if (suffix.includes('million') || suffix.includes('m')) {
                value *= 1000000;
              } else if (suffix.includes('thousand') || suffix.includes('k')) {
                value *= 1000;
              } else if (value < 10000) {
                // If raw number < 10000 and mentions cost/fee, assume millions (e.g., "2" means 2M)
                // But if it's like 2,000,000 keep as is
                if (value < 100) {
                  value *= 1000000;
                }
              }
              extractedArgs.min_fee = value;
              console.log(`[QueryEngine] ğŸ’° Extracted min_fee: ${value} from "${match[0]}"`);
              break;
            }
          }
          
          // Parse max_fee: "cost/fee/budget less than/under/below X"
          const maxFeePatterns = [
            /(?:cost|fee|budget|revenue|value)\s*(?:less than|under|below|<|at most)\s*\$?([\d,]+(?:\.\d+)?)\s*(?:million|m|k|thousand)?/i,
            /(?:less than|under|below|<|at most)\s*\$?([\d,]+(?:\.\d+)?)\s*(?:million|m|k|thousand)?/i,
          ];
          
          for (const pattern of maxFeePatterns) {
            const match = questionForKeywords.match(pattern);
            if (match) {
              let value = parseFloat(match[1].replace(/,/g, ''));
              const suffix = match[0].toLowerCase();
              if (suffix.includes('million') || suffix.includes('m')) {
                value *= 1000000;
              } else if (suffix.includes('thousand') || suffix.includes('k')) {
                value *= 1000;
              } else if (value < 10000) {
                if (value < 100) {
                  value *= 1000000;
                }
              }
              extractedArgs.max_fee = value;
              console.log(`[QueryEngine] ğŸ’° Extracted max_fee: ${value} from "${match[0]}"`);
              break;
            }
          }
        }
        
        // Parse POC: "handled by X", "contact X", "POC X", "managed by X", "where X is the contact/poc"
        // Improved patterns to match various name formats including "Scott Wallington"
        // Note: Patterns match full names with First Last format (each word starts with capital)
        const pocPatterns = [
          // "handled by Scott Wallington", "managed by John Smith", "assigned to Jane Doe"
          /(?:handled by|managed by|assigned to|by)\s+(?:contact\s+)?([A-Z][a-zA-Z]+(?:\s+[A-Z][a-zA-Z]+)+)/i,
          // "contact John Smith", "poc Jane Doe", "point of contact Mike Jones"
          /(?:contact|poc|point of contact)\s+(?:is\s+)?([A-Z][a-zA-Z]+(?:\s+[A-Z][a-zA-Z]+)+)/i,
          // "where John Smith is the contact"
          /\bwhere\s+([A-Z][a-zA-Z]+(?:\s+[A-Z][a-zA-Z]+)+)\s+is\s+(?:the\s+)?(?:contact|poc|point of contact)\b/i,
          // "with John Smith as the poc"
          /\bwith\s+([A-Z][a-zA-Z]+(?:\s+[A-Z][a-zA-Z]+)+)\s+as\s+(?:the\s+)?(?:contact|poc|point of contact)\b/i,
          // "John Smith is the contact"
          /\b([A-Z][a-zA-Z]+\s+[A-Z][a-zA-Z]+)\s+(?:is|as)\s+(?:the\s+)?(?:contact|poc|point of contact)\b/i,
          // Fallback: look for "handled by" followed by any capitalized words (more lenient)
          /handled\s+by\s+([A-Z][a-zA-Z]+(?:\s+[A-Z][a-zA-Z]+)*)/i,
        ];
        
        for (const pattern of pocPatterns) {
          const match = userQuestion.match(pattern);
          if (match) {
            // Clean up the extracted name - remove any trailing project type keywords
            let pocName = match[1].trim();
            // Remove trailing words that might be part of query context, not the name
            const projectTypeKeywords = ['projects', 'project', 'type', 'with', 'in', 'for', 'from'];
            const words = pocName.split(/\s+/);
            while (words.length > 2 && projectTypeKeywords.includes(words[words.length - 1].toLowerCase())) {
              words.pop();
            }
            pocName = words.join(' ');
            
            extractedArgs.poc = pocName;
            console.log(`[QueryEngine] ğŸ‘¤ Extracted POC: "${extractedArgs.poc}" from "${match[0]}"`);
            break;
          }
        }
        
        // Parse State: "in California", "located in Texas", etc.
        // Database uses full state names, not two-letter codes
        const stateNames = [
          'Alabama', 'Alaska', 'Arizona', 'Arkansas', 'California', 'Colorado', 'Connecticut',
          'Delaware', 'Florida', 'Georgia', 'Hawaii', 'Idaho', 'Illinois', 'Indiana', 'Iowa',
          'Kansas', 'Kentucky', 'Louisiana', 'Maine', 'Maryland', 'Massachusetts', 'Michigan',
          'Minnesota', 'Mississippi', 'Missouri', 'Montana', 'Nebraska', 'Nevada', 'New Hampshire',
          'New Jersey', 'New Mexico', 'New York', 'North Carolina', 'North Dakota', 'Ohio',
          'Oklahoma', 'Oregon', 'Pennsylvania', 'Rhode Island', 'South Carolina', 'South Dakota',
          'Tennessee', 'Texas', 'Utah', 'Vermont', 'Virginia', 'Washington', 'West Virginia',
          'Wisconsin', 'Wyoming'
        ];
        
        for (const stateName of stateNames) {
          const statePattern = new RegExp(`\\b(?:in|located in|from|at)\\s+(?:the\\s+)?${stateName}\\b`, 'i');
          if (statePattern.test(userQuestion)) {
            extractedArgs.state_code = stateName;
            console.log(`[QueryEngine] ğŸ“ Extracted state: "${stateName}" from query`);
            break;
          }
        }
        
        // Parse Status: "in Lead status", "in Qualified Lead status", "leading projects above X", etc.
        const statusPatterns = [
          /\b(?:in|with|at)\s+(?:the\s+)?(?:status\s+)?["']?(Lead|Qualified Lead|Unqualified|Pursue|Won|Lost|No-Go|Closed)["']?\s*(?:status)?/i,
          /\b["']?(Lead|Qualified Lead|Unqualified|Pursue|Won|Lost|No-Go|Closed)["']?\s+status\b/i,
        ];
        
        // Special check for "leading projects" with fee context (e.g., "leading projects above 5 million")
        // Only trigger Lead status if "leading" is followed by project-related words AND fee context
        const leadingProjectsPattern = /\b(leading)\s+(?:projects?|opportunities?|deals?)\s+(?:above|over|greater than|more than|exceeding|with|valued|worth)/i;
        if (leadingProjectsPattern.test(userQuestion)) {
          extractedArgs.status = 'Lead';
          console.log(`[QueryEngine] ğŸ“Š Extracted status: "Lead" from "leading projects" pattern with fee context`);
        } else {
          for (const pattern of statusPatterns) {
            const match = userQuestion.match(pattern);
            if (match) {
              const matchedStatus = match[1].toLowerCase();
              // "Closed" = Lost, No Go, Cancelled, Hold (deals no longer in pipeline)
              // "Open" = Proposal Development, Qualified Lead, Submitted, Won (active pipeline)
              if (matchedStatus === 'closed' || matchedStatus === 'close') {
                extractedArgs.status = ['Lost', 'No Go', 'Cancelled', 'Hold'];
                console.log(`[QueryEngine] ğŸ“Š Extracted status: ["Lost", "No Go", "Cancelled"] from "closed"`);
              } else if (matchedStatus === 'open') {
                extractedArgs.status = ['Proposal Development', 'Qualified Lead', 'Submitted', 'Won'];
                console.log(`[QueryEngine] ğŸ“Š Extracted status: ["Proposal Development", "Qualified Lead", "Submitted", "Won", "Lead", "In Progress", "Hold"] from "open"`);
              } else {
                extractedArgs.status = match[1];
                console.log(`[QueryEngine] ğŸ“Š Extracted status: "${extractedArgs.status}" from "${match[0]}"`);
              }
              break;
            }
          }
        }
        
        // Parse Date: "starting in 2026", "in 2026", "for 2026", "from 2026", etc.
        const yearPatterns = [
          /\b(?:starting|staring|beginning|commencing)\s+(?:in\s+)?(\d{4})\b/i,
          /\b(?:in|for|during)\s+(\d{4})\b/i,
          /\b(?:from)\s+(\d{4})\b/i,
        ];
        
        for (const pattern of yearPatterns) {
          const match = userQuestion.match(pattern);
          if (match) {
            const year = match[1];
            extractedArgs.start_date = `${year}-01-01`;
            extractedArgs.end_date = `${year}-12-31`;
            console.log(`[QueryEngine] ğŸ“… Extracted year: ${year} â†’ start_date=${extractedArgs.start_date}, end_date=${extractedArgs.end_date}`);
            break;
          }
        }
        
        // Use mergeExtractedHints to include all extracted filters
        classification = {
          function_name: 'get_projects_by_project_type',
          arguments: mergeExtractedHints(extractedArgs)
        };
      } else if (matchedDescriptionKeyword && !isAiAnalysisFollowUp && !hasFollowUpContext && !disambiguationOverride) {
        // Route to search_description for description-only keywords
        console.log(`[QueryEngine] ğŸ” DESCRIPTION OVERRIDE: Found "${matchedDescriptionKeyword}" in query â†’ forcing search_description`);
        // Use mergeExtractedHints to include all extracted filters
        classification = {
          function_name: 'search_description',
          arguments: mergeExtractedHints({ keyword: `%${matchedDescriptionKeyword}%` })
        };
      } else if (/\b(group|grouped|aggregate|aggregated|breakdown|break\s*down)\s+(all\s+)?(projects?\s+)?by\s+(start\s+)?year/i.test(userQuestion) ||
                 /\bby\s+(start\s+)?year\b/i.test(userQuestion) ||
                 /\b(yearly|annual)\s+(summary|breakdown|analysis|report)/i.test(userQuestion) ||
                 /\bprojects?\s+by\s+(start\s+)?year/i.test(userQuestion)) {
        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        // YEAR GROUPING OVERRIDE: Route "group by year" to compare_years
        // This is a common pattern that should always use year aggregation
        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        console.log(`[QueryEngine] ğŸ“† YEAR GROUPING OVERRIDE: Query requests grouping by year â†’ forcing compare_years`);
        classification = {
          function_name: 'compare_years',
          arguments: mergeExtractedHints({})
        };
        
        console.log(`[QueryEngine] ğŸ” PRE-MODULE CHECK: _module_context=${extractedHints._module_context}, modules=${JSON.stringify(extractedHints.modules)}, disambiguationOverride=${!!disambiguationOverride}`);

      } else if (extractedHints._module_context && extractedHints.modules && Array.isArray(extractedHints.modules) && extractedHints.modules.length > 0 && !disambiguationOverride) {
        // DEBUG: This should trigger for "list all opportunities module"
        console.log(`[QueryEngine] ğŸš¨ MODULE OVERRIDE TRIGGERED! modules=${JSON.stringify(extractedHints.modules)}`);
        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        // MODULE CONTEXT DETECTED: Determine if user wants LIST or AGGREGATE
        // - LIST: "list opportunities module", "show tracked work module"
        // - AGGREGATE: "breakdown by module", "summarize across modules"
        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        const isAggregationQuery = /\b(group|grouped|aggregate|aggregated|breakdown|break\s*down|summarize|summarized|compare|across|between|total|analysis|report)\b/i.test(userQuestion);
        
        if (isAggregationQuery) {
          console.log(`[QueryEngine] ğŸ“¦ MODULE GROUPING OVERRIDE: Aggregation query detected â†’ forcing get_module_breakdown with modules: ${extractedHints.modules.join(', ')}`);
          classification = {
            function_name: 'get_module_breakdown',
            arguments: mergeExtractedHints({ modules: extractedHints.modules })
          };
        } else {
          // User wants to LIST projects filtered by module
          console.log(`[QueryEngine] ğŸ“‹ MODULE LIST OVERRIDE: List query detected â†’ forcing get_all_projects with modules filter: ${extractedHints.modules.join(', ')}`);
          try {
            const mergedArgs = mergeExtractedHints({ modules: extractedHints.modules });
            classification = {
              function_name: 'get_all_projects',
              arguments: { ...mergedArgs, _MODULE_OVERRIDE_MARKER: 'ACTIVE' }
            };
          } catch (mergeErr: any) {
          }
        }
      } else if (/\b(group|grouped|aggregate|aggregated|breakdown|break\s*down|categorize|categorized)\s+(all\s+)?(projects?\s+|results?\s+)?by\s+status/i.test(userQuestion) ||
                 /\bby\s+status\b/i.test(userQuestion) ||
                 /\bstatus\s+(summary|breakdown|analysis|report)/i.test(userQuestion) ||
                 /\bprojects?\s+by\s+status/i.test(userQuestion)) {
        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        // STATUS GROUPING OVERRIDE: Route "group by status" to get_status_breakdown
        // This is a common pattern that should always use status aggregation
        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        console.log(`[QueryEngine] ğŸ“Š STATUS GROUPING OVERRIDE: Query requests grouping by status â†’ forcing get_status_breakdown`);
        classification = {
          function_name: 'get_status_breakdown',
          arguments: mergeExtractedHints({})
        };
      } else {
        // Use request queue to limit concurrent OpenAI requests
        // This prevents rate limiting when many users query simultaneously
        const queueStats = openaiQueue.getStats();
        if (queueStats.queueLength > 5) {
          console.log(`[QueryEngine] â³ Request queued (${queueStats.queueLength} ahead, ~${openaiQueue.getEstimatedWaitTime()}s wait)`);
        }
        
        console.log(`[QueryEngine] ğŸ” BEFORE LLM: preAppliedFilters._disambiguation_function = "${preAppliedFilters._disambiguation_function}"`);
        
        classification = await openaiQueue.enqueue(() => 
          this.openaiClient.classifyQuery(finalQuestion, functionsToSend)
        );
      }
      // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
      // DISAMBIGUATION GUARD: If user selected a disambiguation option, force the
      // correct function and apply the pre-applied filters immediately.
      // This MUST happen before any ai_fallback guards that might return early.
      // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
      console.log(`[QueryEngine] ğŸ” DISAMBIGUATION GUARD CHECK: _disambiguation_function = "${preAppliedFilters._disambiguation_function}", keys = ${Object.keys(preAppliedFilters).join(', ')}`);
      if (preAppliedFilters._disambiguation_function) {
        console.log(`[QueryEngine] ğŸ¯ DISAMBIGUATION GUARD: LLM returned "${classification.function_name}", forcing to "${preAppliedFilters._disambiguation_function}"`);
        classification.function_name = preAppliedFilters._disambiguation_function;
        
        // CONFLICT CLEANUP: Remove LLM-derived filters that conflict with disambiguation choice
        // When user explicitly chose a column to search, remove conflicting inferred filters
        const disambColumn = preAppliedFilters._disambiguation_column;
        console.log(`[QueryEngine] ğŸ” CONFLICT CLEANUP DEBUG: disambColumn = "${disambColumn}"`);
        const conflictMap: Record<string, string[]> = {
          'Service Type': ['project_type', 'category', 'categories', 'division', 'department'],
          'Client': ['company', 'poc', 'title'],
          'Company': ['client', 'poc', 'title'],
          'Point of Contact': ['client', 'company'],
          'Project Type': ['category', 'categories', 'service_type'],
          'Division': ['department', 'service_type'],
          'Department': ['division', 'service_type'],
          'Project Title': ['client', 'company', 'keyword'],
          'Category': ['project_type', 'service_type'],
          'City': ['state', 'region'],
        };
        
        const conflictingArgs = conflictMap[disambColumn] || [];
        for (const conflictArg of conflictingArgs) {
          if (classification.arguments[conflictArg] && !classification.arguments[`_${conflictArg}_already_applied`]) {
            console.log(`[QueryEngine] ğŸ§¹ DISAMBIGUATION CONFLICT CLEANUP: Removing LLM-derived "${conflictArg}" = "${classification.arguments[conflictArg]}" (conflicts with user's ${disambColumn} choice)`);
            delete classification.arguments[conflictArg];
          }
          // ALSO clear from extractedHints to prevent HINT MERGE from re-adding
          if (extractedHints[conflictArg]) {
            console.log(`[QueryEngine] ğŸ§¹ DISAMBIGUATION CONFLICT CLEANUP: Also removing "${conflictArg}" from extractedHints to prevent re-merge`);
            delete extractedHints[conflictArg];
          }
        }
        
        // Apply all non-underscore filters to classification.arguments
        for (const [key, value] of Object.entries(preAppliedFilters)) {
          if (!key.startsWith('_')) {
            console.log(`[QueryEngine] ğŸ¯ DISAMBIGUATION GUARD: Setting ${key} = "${value}"`);
            classification.arguments[key] = value;
          }
        }
        
        // Also apply the original value for service_type
        if (preAppliedFilters._service_type_original_value) {
          classification.arguments.service_type = preAppliedFilters._service_type_original_value;
          console.log(`[QueryEngine] ğŸ¯ DISAMBIGUATION GUARD: Setting service_type = "${preAppliedFilters._service_type_original_value}"`);
        }
        
        console.log(`[QueryEngine] ğŸ¯ DISAMBIGUATION GUARD: classification.arguments = ${JSON.stringify(classification.arguments)}`);
      }

      // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
      // IMMEDIATE AI CLEANUP: Convert AI-returned categories to project_type
      // This runs BEFORE any hint merging or other processing
      // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
      const PROJECT_TYPE_VALUES_FOR_CLEANUP = new Set(["government", "civic", "airports", "hospitals", "bridges", "transit", "higher education", "k-12", "corrections", "energy", "industrial", "waterfront", "multi-family", "mixed use", "office", "parking", "retail", "sports", "water/wastewater", "transportation", "aviation", "healthcare", "education"]);
      if (classification.arguments.categories && classification.arguments.categories.length > 0) {
        const catValue = String(classification.arguments.categories[0]).toLowerCase();
        if (PROJECT_TYPE_VALUES_FOR_CLEANUP.has(catValue)) {
          // AI returned categories but this should be project_type
          if (!classification.arguments.project_type) {
            classification.arguments.project_type = classification.arguments.categories[0];
            console.log(`[QueryEngine] uD83DuDC99 IMMEDIATE AI CLEANUP: categories["${classification.arguments.categories[0]}"] â†’ project_type="${classification.arguments.project_type}"`);
          }
          delete classification.arguments.categories;
          if (!classification.arguments._category_already_applied) delete classification.arguments.category;
          // CRITICAL: Set _project_type_explicit to prevent normalization from re-creating categories
          classification.arguments._project_type_explicit = true;
          // Also remove _explicit_category flag to prevent normalization SECTOR FIX from re-adding categories
          delete classification.arguments._explicit_category;
          console.log(`[QueryEngine] uD83DuDC99 IMMEDIATE AI CLEANUP: Deleted categories, set _project_type_explicit=true`);
        }
      
      // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
      // ADDITIONAL CLEANUP: When AI returns project_type alone (no categories)
      // Delete extractedHints._explicit_category to prevent SECTOR FIX re-creation
      // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
      if (classification.arguments.project_type && !classification.arguments.categories) {
        const ptValue = String(classification.arguments.project_type).toLowerCase();
        if (PROJECT_TYPE_VALUES_FOR_CLEANUP.has(ptValue) || PROJECT_TYPE_VALUES_FOR_CLEANUP.has(ptValue) ? ptValue : null) {
          classification.arguments._project_type_explicit = true;
          // CRITICAL: Also delete extractedHints._explicit_category to prevent SECTOR FIX
          delete extractedHints._explicit_category;
          delete extractedHints.categories;
          delete extractedHints.category;
          console.log(`[QueryEngine] uD83DuDC99 PROJECT_TYPE-ONLY CLEANUP: Set _project_type_explicit=true, deleted extractedHints category flags`);
        }
      }
      }

      console.log(`[QueryEngine] Question: "${userQuestion}"`);
      console.log(`[QueryEngine] Previous context:`, previousContext ? JSON.stringify(previousContext, null, 2) : "None");
      if (this.ragStore && ragConfidence > 0) {
        console.log(`[QueryEngine] RAG Confidence: ${(ragConfidence * 100).toFixed(1)}%`);
      }
      console.log(`[QueryEngine] Classified as: ${classification.function_name}`);
      console.log(`[QueryEngine] AI extracted params:`, JSON.stringify(classification.arguments, null, 2));
      
      // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
      // HYBRID APPROACH: Merge pre-extracted hints with LLM classification
      // extractedHints takes priority for reliable pattern-matched values
      // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
      const hintsToMerge = ['project_type', 'category', 'min_fee', 'max_fee', 'status', 'poc', 'states', 'state_code', 'company', 'limit', 'min_win', 'max_win', 'start_date', 'end_date', 'division', 'department', 'regions'];
      let mergedAnyHints = false;
      
      for (const key of hintsToMerge) {
        if (extractedHints[key] !== undefined && classification.arguments[key] === undefined) {
          classification.arguments[key] = extractedHints[key];
          console.log(`[QueryEngine] ğŸ”— HINT MERGE: Added ${key}=${JSON.stringify(extractedHints[key])} from regex extraction`);
          mergedAnyHints = true;
        }
      }
      
      // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
      // SPECIAL: Multi-division/department ARRAY merging
      // If regex extracted an array (divisions/departments), it should OVERRIDE
      // the LLM's single-value extraction (which often captures "X and Y" as one string)
      // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
      if (extractedHints.divisions && Array.isArray(extractedHints.divisions) && extractedHints.divisions.length > 0) {
        // Remove LLM's single-value division (e.g., "SCM and Architecture" as one string)
        if (classification.arguments.division) {
          console.log(`[QueryEngine] ğŸ”— MULTI-DIVISION: Replacing LLM's division="${classification.arguments.division}" with regex-extracted divisions=${JSON.stringify(extractedHints.divisions)}`);
          delete classification.arguments.division;
        }
        classification.arguments.divisions = extractedHints.divisions;
        mergedAnyHints = true;
      }
      
      if (extractedHints.departments && Array.isArray(extractedHints.departments) && extractedHints.departments.length > 0) {
        // Remove LLM's single-value department
        if (classification.arguments.department) {
          console.log(`[QueryEngine] ğŸ”— MULTI-DEPARTMENT: Replacing LLM's department="${classification.arguments.department}" with regex-extracted departments=${JSON.stringify(extractedHints.departments)}`);
          delete classification.arguments.department;
        }
        classification.arguments.departments = extractedHints.departments;
        mergedAnyHints = true;
      }
      
      // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
      // SPECIAL: Region column handling - overrides AI-extracted states
      // If regex detected region keywords, use Region column instead of state expansion
      // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
      if (extractedHints.regions && Array.isArray(extractedHints.regions) && extractedHints.regions.length > 0) {
        // Clear any states that AI may have expanded from region keywords
        if (classification.arguments.states && Array.isArray(classification.arguments.states)) {
          console.log(`[QueryEngine] ğŸ—ºï¸ REGION OVERRIDE: Clearing AI-extracted states (${classification.arguments.states.length} states) in favor of Region column: ${extractedHints.regions.join(", ")}`);
          delete classification.arguments.states;
        }
        classification.arguments.regions = extractedHints.regions;
        mergedAnyHints = true;
      }

      // Add explicit flag for project_type if it was extracted
      if (extractedHints.project_type && classification.arguments.project_type) {
        classification.arguments._project_type_explicit = true;
      }
      
      // CRITICAL: Pass through _explicit_category flag to prevent safety net from overriding
      // This ensures "category/sector" keywords use Request Category column, not Project Type
      if (extractedHints._explicit_category && !classification.arguments._project_type_explicit) {
        classification.arguments._explicit_category = true;
        console.log(`[QueryEngine] ğŸ“ Passing _explicit_category flag to use Request Category column`);
      }
      
      if (mergedAnyHints) {
        console.log(`[QueryEngine] ğŸ”— After hint merge:`, JSON.stringify(classification.arguments, null, 2));
      }
      
      // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
      // DISAMBIGUATION PRE-APPLIED FILTERS MERGE (HIGHEST PRIORITY)
      // These values come from user's explicit disambiguation selection
      // They MUST override any LLM-extracted values
      // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
      console.log(`[QueryEngine] ğŸ” MERGE CHECK: preAppliedFilters keys = ${Object.keys(preAppliedFilters).join(', ')}, length = ${Object.keys(preAppliedFilters).length}`);
      console.log(`[QueryEngine] ğŸ” MERGE CHECK: preAppliedFilters full = ${JSON.stringify(preAppliedFilters)}`);
      if (Object.keys(preAppliedFilters).length > 0) {
        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        // DISAMBIGUATION FUNCTION ENFORCEMENT: Force the correct function
        // When user selects a disambiguation option, we MUST use the 
        // corresponding function (e.g., get_projects_by_service_type for Service Type)
        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        if (preAppliedFilters._disambiguation_function) {
          const forcedFunction = preAppliedFilters._disambiguation_function;
          console.log(`[QueryEngine] ğŸ¯ DISAMBIGUATION FUNCTION ENFORCEMENT: Forcing "${classification.function_name}" â†’ "${forcedFunction}"`);
          classification.function_name = forcedFunction;
        }
        
        console.log(`[QueryEngine] ğŸ”’ DISAMBIGUATION MERGE (INSIDE processQuery): Applying user-selected filters`);
        console.log(`[QueryEngine] ğŸ”’ preAppliedFilters = ${JSON.stringify(preAppliedFilters)}`);
        console.log(`[QueryEngine] ğŸ”’ classification.arguments BEFORE = ${JSON.stringify(classification.arguments)}`);
        for (const [key, value] of Object.entries(preAppliedFilters)) {
          console.log(`[MERGE LOOP] Processing key="${key}", value="${value}", startsWithUnderscore=${key.startsWith('_')}`);
          if (!key.startsWith('_')) {
            console.log(`[MERGE LOOP] Setting classification.arguments[${key}] = "${value}" (was: "${classification.arguments[key]}")`);
            classification.arguments[key] = value;
          } else {
            console.log(`[MERGE LOOP] Setting flag classification.arguments[${key}] = "${value}"`);
            classification.arguments[key] = value;
          }
        }
        
        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        // CRITICAL FIX: Override LLM-extracted service_type with user's selection
        // The LLM often misparses "[filter by Service Type: X]" and extracts "by"
        // We must use the original value that the user explicitly selected
        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        if (preAppliedFilters._service_type_original_value) {
          const userSelectedValue = preAppliedFilters._service_type_original_value;
          console.log(`[MERGE FIX] ğŸ”§ Overriding service_type: "${classification.arguments.service_type}" â†’ "${userSelectedValue}"`);
          classification.arguments.service_type = userSelectedValue;
        }
        console.log(`[QueryEngine] ğŸ”’ classification.arguments AFTER = ${JSON.stringify(classification.arguments)}`);
      }

      // POST-MERGE CLEANUP: Delete categories if project_type is set to same value (prevents duplicate filtering)
      if (classification.arguments.project_type && classification.arguments.categories) {
        const catVal = Array.isArray(classification.arguments.categories) ? classification.arguments.categories[0] : classification.arguments.categories;
        const catLower = String(catVal).toLowerCase();
        const ptLower = String(classification.arguments.project_type).toLowerCase();
        if (catLower === ptLower || catLower.includes(ptLower) || ptLower.includes(catLower)) {
          console.log(`[QueryEngine] ğŸ§¹ POST-MERGE CLEANUP: Deleting categories="${catVal}" (same as project_type="${classification.arguments.project_type}")`);
          delete classification.arguments.categories;
          if (!classification.arguments._category_already_applied) delete classification.arguments.category;
          delete classification.arguments._explicit_category;
          classification.arguments._project_type_explicit = true;
        }
      }
      
      // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
      // AI-FIRST MODE: Function name validation using regex hint
      // If regex suggested a different function, log the conflict for debugging
      // In future iterations, we can use this to auto-correct AI misclassifications
      // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
      if (AI_FIRST_MODE && extractedHints._regexFunctionHint) {
        const regexFn = extractedHints._regexFunctionHint;
        const aiFn = classification.function_name;
        
        if (regexFn !== aiFn) {
          console.log(`[QueryEngine] ğŸ¤– AI-FIRST VALIDATION: Regex suggested "${regexFn}" vs AI chose "${aiFn}"`);
          
          // Define high-confidence regex patterns that should override AI
          // These are breakdown patterns that are very specific
          const highConfidenceRegexPatterns = [
            'get_division_breakdown', 'get_department_breakdown',
            'get_revenue_by_division', 'get_revenue_by_department',
            'get_projects_by_category', 'compare_divisions', 'compare_departments',
            'compare_regions', 'compare_states', 'compare_countries', 'get_revenue_by_state'
          ];
          
          // If regex suggested a high-confidence breakdown pattern AND AI chose a listing pattern
          // Override AI's choice (common misclassification case)
          // Note: compare_states is included so compare_regions can override when user asks for "regions" not "states"
          const listingPatterns = ['get_largest_projects', 'get_projects_by_combined_filters', 'get_projects_by_year', 'get_projects_by_state', 'get_projects_by_project_type', 'compare_states'];
          if (highConfidenceRegexPatterns.includes(regexFn) && listingPatterns.includes(aiFn)) {
            console.log(`[QueryEngine] ğŸ¤– AI-FIRST OVERRIDE: Regex pattern "${regexFn}" takes precedence over AI's "${aiFn}"`);
            classification.function_name = regexFn;
          }
        } else {
          console.log(`[QueryEngine] ğŸ¤– AI-FIRST VALIDATION: AI and regex agree on "${aiFn}"`);
        }
        
        // Clean up the hint to avoid it being passed to SQL
        delete extractedHints._regexFunctionHint;
        delete classification.arguments._regexFunctionHint;
      }
      
      // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
      // CRITICAL "THIS YEAR" GUARD: Right after hint merge, convert to year filter
      // If user says "this year", "current year", "starting this year" - use YEAR() filter
      // This must happen AFTER hint merge to catch dates added from extractedHints
      // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
      const currentYearForHintGuard = new Date().getFullYear();
      const thisYearPatternForHint = /\b(this\s+year|current\s+year|starting\s+this\s+year)\b/i;
      if (thisYearPatternForHint.test(userQuestion)) {
        console.log(`[QueryEngine] ğŸ“… THIS YEAR GUARD: Detected "this year" pattern in: "${userQuestion}"`);
        
        // Set year parameter
        if (!classification.arguments.year) {
          classification.arguments.year = currentYearForHintGuard;
          console.log(`[QueryEngine] ğŸ“… THIS YEAR GUARD: Set year=${currentYearForHintGuard}`);
        }
        
        // Remove date range filters - year filter covers the full calendar year
        if (classification.arguments.start_date) {
          console.log(`[QueryEngine] ğŸ“… THIS YEAR GUARD: Removing start_date=${classification.arguments.start_date}`);
          delete classification.arguments.start_date;
        }
        if (classification.arguments.end_date) {
          console.log(`[QueryEngine] ğŸ“… THIS YEAR GUARD: Removing end_date=${classification.arguments.end_date}`);
          delete classification.arguments.end_date;
        }
        classification.arguments._date_already_applied = true;
      }
      
      // CLEANUP: If states array is set from region detection, remove conflicting state_code
      // The states array takes precedence over a single state_code
      if (classification.arguments.states && Array.isArray(classification.arguments.states) && 
          classification.arguments.states.length > 1 && classification.arguments.state_code) {
        console.log(`[QueryEngine] ğŸ”„ REGION CLEANUP: Removing state_code="${classification.arguments.state_code}" (region has ${classification.arguments.states.length} states)`);
        delete classification.arguments.state_code;
        // Switch to combined_filters if using get_projects_by_state (which requires state_code)
        if (classification.function_name === 'get_projects_by_state') {
          classification.function_name = 'get_largest_projects';
          console.log(`[QueryEngine] ğŸ”„ Switched to get_largest_projects for multi-state region`);
        }
      }
      
      // CLEANUP: If regions array is set (Region column approach), remove any states/state_code
      // The regions array takes precedence - we use Region column directly
      if (classification.arguments.regions && Array.isArray(classification.arguments.regions) && classification.arguments.regions.length > 0) {
        if (classification.arguments.states) {
          console.log(`[QueryEngine] ğŸ—ºï¸ REGION COLUMN CLEANUP: Removing ${classification.arguments.states.length} states (using Region column: ${classification.arguments.regions.join(', ')})`);
          delete classification.arguments.states;
        }
        if (classification.arguments.state_code) {
          console.log(`[QueryEngine] ğŸ—ºï¸ REGION COLUMN CLEANUP: Removing state_code="${classification.arguments.state_code}" (using Region column)`);
          delete classification.arguments.state_code;
        }
      }

      // MERGE PRE-DETECTED REGION: If region was detected earlier but we didn't short-circuit
      // because of additional filters, merge the region values now (uses Region column)
      if (preDetectedRegionValues && preDetectedRegionValues.length > 0 && !classification.arguments.regions && !classification.arguments.states && !classification.arguments.state_code) {
        console.log(`[QueryEngine] ğŸ—ºï¸ REGION MERGE: Injecting pre-detected region values: ${preDetectedRegionValues.join(', ')}`);
        classification.arguments.regions = preDetectedRegionValues;
        // Make sure we're using a function that supports regions array
        if (classification.function_name === 'get_projects_by_state') {
          classification.function_name = 'get_largest_projects';
          console.log(`[QueryEngine] ğŸ”„ Switched to get_largest_projects for region filter`);
        }
      }

      // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
      // CRITICAL: Apply disambiguation override BEFORE normalization
      // This ensures the override function and args are in place before
      // normalizeClassificationArguments runs and potentially deletes values
      // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
      // DISAMBIGUATION LOCK FLAG: Tracks if disambiguation override was applied to prevent later rewrites
      let disambiguationLocked = false;
      
      if (disambiguationOverride) {
        console.log(`[QueryEngine] ğŸ¯ APPLYING DISAMBIGUATION OVERRIDE: function="${disambiguationOverride.function}"`);
        classification.function_name = disambiguationOverride.function;
        // Merge override args into classification.arguments (override args take precedence)
        for (const [key, value] of Object.entries(disambiguationOverride.args)) {
          if (value !== undefined) {
            console.log(`[QueryEngine]    Merging ${key} = "${value}" into classification.arguments`);
            classification.arguments[key] = value;
          }
        }
        // Set lock flag to prevent later heuristics from overwriting function_name
        disambiguationLocked = true;
        classification.arguments._disambiguation_locked = true;
        console.log(`[QueryEngine] ğŸ”’ DISAMBIGUATION LOCKED: function="${classification.function_name}" is protected from later rewrites`);
        console.log(`[QueryEngine] ğŸ¯ AFTER OVERRIDE: classification.arguments = ${JSON.stringify(classification.arguments)}`);
      }

      // COLUMN SYNONYM NORMALIZATION: Convert user-friendly column names to actual DB columns
      // e.g., "cost" â†’ "Fee", "win rate" â†’ "ChanceOfSuccess", "customer" â†’ "Client"
      classification.arguments = normalizeClassificationArguments(classification.arguments, userQuestion);
      console.log(`[QueryEngine] ğŸ” DEBUG PRE-EXECUTE: classification.arguments.category="${classification?.arguments?.category}", _category_already_applied=${classification?.arguments?._category_already_applied}`);
      classification.arguments = stripHallucinatedGeography(classification.arguments, userQuestion);

      // REGION EXPANSION: Convert region names to state arrays
      // Handles cases where AI extracts state_code as a region name like "west", "midwest", etc.
      const REGION_TO_STATES: Record<string, string[]> = {
        // West Region (13 states)
        'west': ['Alaska', 'Arizona', 'California', 'Colorado', 'Hawaii', 'Idaho', 'Montana', 'Nevada', 'New Mexico', 'Oregon', 'Utah', 'Washington', 'Wyoming'],
        'western': ['Alaska', 'Arizona', 'California', 'Colorado', 'Hawaii', 'Idaho', 'Montana', 'Nevada', 'New Mexico', 'Oregon', 'Utah', 'Washington', 'Wyoming'],
        'pacific': ['Alaska', 'California', 'Hawaii', 'Oregon', 'Washington'],
        'mountain': ['Arizona', 'Colorado', 'Idaho', 'Montana', 'Nevada', 'New Mexico', 'Utah', 'Wyoming'],
        
        // Midwest Region (12 states)
        'midwest': ['Illinois', 'Indiana', 'Iowa', 'Kansas', 'Michigan', 'Minnesota', 'Missouri', 'Nebraska', 'North Dakota', 'Ohio', 'South Dakota', 'Wisconsin'],
        'midwestern': ['Illinois', 'Indiana', 'Iowa', 'Kansas', 'Michigan', 'Minnesota', 'Missouri', 'Nebraska', 'North Dakota', 'Ohio', 'South Dakota', 'Wisconsin'],
        'great lakes': ['Illinois', 'Indiana', 'Michigan', 'Minnesota', 'Ohio', 'Wisconsin'],
        'plains': ['Iowa', 'Kansas', 'Minnesota', 'Missouri', 'Nebraska', 'North Dakota', 'South Dakota'],
        
        // South Region (16 states)
        'south': ['Alabama', 'Arkansas', 'Delaware', 'Florida', 'Georgia', 'Kentucky', 'Louisiana', 'Maryland', 'Mississippi', 'North Carolina', 'Oklahoma', 'South Carolina', 'Tennessee', 'Texas', 'Virginia', 'West Virginia'],
        'southern': ['Alabama', 'Arkansas', 'Delaware', 'Florida', 'Georgia', 'Kentucky', 'Louisiana', 'Maryland', 'Mississippi', 'North Carolina', 'Oklahoma', 'South Carolina', 'Tennessee', 'Texas', 'Virginia', 'West Virginia'],
        'southeast': ['Alabama', 'Florida', 'Georgia', 'Kentucky', 'Mississippi', 'North Carolina', 'South Carolina', 'Tennessee', 'Virginia', 'West Virginia'],
        'southeastern': ['Alabama', 'Florida', 'Georgia', 'Kentucky', 'Mississippi', 'North Carolina', 'South Carolina', 'Tennessee', 'Virginia', 'West Virginia'],
        'southwest': ['Arizona', 'New Mexico', 'Oklahoma', 'Texas'],
        'southwestern': ['Arizona', 'New Mexico', 'Oklahoma', 'Texas'],
        'gulf': ['Alabama', 'Florida', 'Louisiana', 'Mississippi', 'Texas'],
        'gulf coast': ['Alabama', 'Florida', 'Louisiana', 'Mississippi', 'Texas'],
        
        // Northeast Region (9 states)
        'northeast': ['Connecticut', 'Maine', 'Massachusetts', 'New Hampshire', 'New Jersey', 'New York', 'Pennsylvania', 'Rhode Island', 'Vermont'],
        'northeastern': ['Connecticut', 'Maine', 'Massachusetts', 'New Hampshire', 'New Jersey', 'New York', 'Pennsylvania', 'Rhode Island', 'Vermont'],
        'new england': ['Connecticut', 'Maine', 'Massachusetts', 'New Hampshire', 'Rhode Island', 'Vermont'],
        'mid-atlantic': ['Delaware', 'Maryland', 'New Jersey', 'New York', 'Pennsylvania'],
        'mid atlantic': ['Delaware', 'Maryland', 'New Jersey', 'New York', 'Pennsylvania'],
        'east coast': ['Connecticut', 'Delaware', 'Florida', 'Georgia', 'Maine', 'Maryland', 'Massachusetts', 'New Hampshire', 'New Jersey', 'New York', 'North Carolina', 'Pennsylvania', 'Rhode Island', 'South Carolina', 'Vermont', 'Virginia'],
        'eastern': ['Connecticut', 'Delaware', 'Florida', 'Georgia', 'Maine', 'Maryland', 'Massachusetts', 'New Hampshire', 'New Jersey', 'New York', 'North Carolina', 'Pennsylvania', 'Rhode Island', 'South Carolina', 'Vermont', 'Virginia'],
        'east': ['Connecticut', 'Delaware', 'Florida', 'Georgia', 'Maine', 'Maryland', 'Massachusetts', 'New Hampshire', 'New Jersey', 'New York', 'North Carolina', 'Pennsylvania', 'Rhode Island', 'South Carolina', 'Vermont', 'Virginia'],
        
        // Special regions
        'tristate': ['Connecticut', 'New Jersey', 'New York'],
        'rust belt': ['Illinois', 'Indiana', 'Michigan', 'Ohio', 'Pennsylvania', 'Wisconsin'],
        'sun belt': ['Alabama', 'Arizona', 'California', 'Florida', 'Georgia', 'Louisiana', 'Mississippi', 'Nevada', 'New Mexico', 'North Carolina', 'South Carolina', 'Texas'],
        'north': ['Connecticut', 'Illinois', 'Indiana', 'Iowa', 'Maine', 'Massachusetts', 'Michigan', 'Minnesota', 'New Hampshire', 'New Jersey', 'New York', 'North Dakota', 'Ohio', 'Pennsylvania', 'Rhode Island', 'South Dakota', 'Vermont', 'Wisconsin'],
        'northern': ['Connecticut', 'Illinois', 'Indiana', 'Iowa', 'Maine', 'Massachusetts', 'Michigan', 'Minnesota', 'New Hampshire', 'New Jersey', 'New York', 'North Dakota', 'Ohio', 'Pennsylvania', 'Rhode Island', 'South Dakota', 'Vermont', 'Wisconsin'],
      };
      
      // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
      // DISAMBIGUATION SKIP: If disambiguation is locked via args flag,
      // skip ALL heuristic rewrites that could modify function_name or args
      // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
      const skipHeuristics = classification.arguments._disambiguation_locked === true;
      if (skipHeuristics) {
        console.log(`[QueryEngine] ğŸ”’ DISAMBIGUATION SKIP: Skipping all heuristics because _disambiguation_locked=true`);
        console.log(`[QueryEngine] ğŸ”’ Preserved function: "${classification.function_name}"`);
        console.log(`[QueryEngine] ğŸ”’ Preserved args: ${JSON.stringify(classification.arguments)}`);
      }
      
      // Check if AI extracted a region name as state_code
      // FIX: Use Region column directly instead of expanding to states
      if (!skipHeuristics && classification.arguments.state_code && !classification.arguments.states && !classification.arguments.regions) {
        const stateCodeLower = classification.arguments.state_code.toLowerCase().trim();
        if (REGION_TO_STATES[stateCodeLower]) {
          console.log(`[QueryEngine] ğŸŒ REGION COLUMN MODE: "${classification.arguments.state_code}" â†’ Region column filter (NOT state expansion)`);
          classification.arguments.regions = [classification.arguments.state_code]; // Use Region column instead
          delete classification.arguments.state_code;
          // Switch to combined_filters which supports regions array
          if (classification.function_name === 'get_projects_by_state') {
            console.log(`[QueryEngine] ğŸ”„ Switching from get_projects_by_state to get_projects_by_combined_filters for region`);
            classification.function_name = 'get_projects_by_combined_filters';
          }
        }
      } else if (classification.arguments.regions) {
        // Also clear any redundant states when using Region column
        if (classification.arguments.states && Array.isArray(classification.arguments.states)) {
          console.log(`[QueryEngine] ğŸ—ºï¸ REGION CLEANUP: Clearing ${classification.arguments.states.length} redundant states (using Region column instead)`);
          delete classification.arguments.states;
        }
        console.log(`[QueryEngine] ğŸ—ºï¸ REGION COLUMN MODE: Using Region column filter, skipping state expansion`);
      }
      
      // Also check the question text for region keywords not caught by AI
      const questionLowerCheck = userQuestion.toLowerCase();
      
      // REGION EXCLUSION DETECTION: Check for "except [region]", "excluding [region]", "not in [region]"
      // This must be done BEFORE region detection to set exclude_states flag
      // ALSO: If LLM already extracted states but user said "except", convert to exclude_states
      console.log(`[QueryEngine] ğŸ” EXCLUSION CHECK START: states=${classification.arguments.states?.length || 0}, exclude_states=${classification.arguments.exclude_states?.length || 0}`);
      let detectedExcludeRegion = false;
      for (const [regionKey, regionStates] of Object.entries(REGION_TO_STATES)) {
        // Match patterns like "except west region", "excluding midwest", "not in south", "but not west"
        const excludePattern = new RegExp(`\\b(except|excluding|exclude|not\\s+in|but\\s+not|outside\\s+of?)\\s+(the\\s+)?${regionKey}(\\s+region|\\s+states?|\\s+area)?\\b`, 'i');
        if (excludePattern.test(questionLowerCheck)) {
          console.log(`[QueryEngine] ğŸš« REGION EXCLUSION DETECTED: "${regionKey}" â†’ EXCLUDING ${regionStates.length} states`);
          classification.arguments.exclude_states = regionStates;
          detectedExcludeRegion = true;
          
          // CRITICAL: If LLM incorrectly extracted these as inclusion states, remove them
          if (classification.arguments.states && Array.isArray(classification.arguments.states)) {
            console.log(`[QueryEngine] ğŸ”„ CONVERTING states to exclude_states (LLM incorrectly extracted as inclusion) - DELETING ${classification.arguments.states.length} inclusion states`);
            delete classification.arguments.states;
          }
          if (classification.arguments.state_code) {
            console.log(`[QueryEngine] ğŸ”„ REMOVING state_code (conflict with exclude_states)`);
            delete classification.arguments.state_code;
          }
          
          // Switch to combined_filters which supports exclude_states
          if (classification.function_name === 'get_projects_by_state') {
            console.log(`[QueryEngine] ğŸ”„ Switching from get_projects_by_state to get_fee_distribution_stats for region exclusion`);
            classification.function_name = 'get_fee_distribution_stats';
          }
          break;
        }
      }
      console.log(`[QueryEngine] ğŸ” EXCLUSION CHECK END: detectedExcludeRegion=${detectedExcludeRegion}, states=${classification.arguments.states?.length || 0}, exclude_states=${classification.arguments.exclude_states?.length || 0}`);
      
      // Only detect inclusion regions if we did not detect an exclusion AND not using Region column approach
      if (!detectedExcludeRegion && !classification.arguments.state_code && !classification.arguments.states && !classification.arguments.regions) {
        // Short directional keywords that are commonly part of place names (e.g., "East Orange", "West Point")
        // These require explicit geographic context to avoid false positives
        const shortDirectionalRegions = ['east', 'west', 'north', 'south'];
        
        for (const [regionKey, regionStates] of Object.entries(REGION_TO_STATES)) {
          let regionPattern: RegExp;
          
          if (shortDirectionalRegions.includes(regionKey)) {
            // For short directional keywords: REQUIRE geographic suffix or explicit "in the [region]" context
            // This prevents "East Orange" from matching "east" region
            // Must match: "east region", "east coast", "east states", "in the east", "eastern"
            // Must NOT match: "East Orange", "East Side", "West Point"
            regionPattern = new RegExp(`\\b(in\\s+the\\s+)${regionKey}\\b|\\b${regionKey}(ern|\\s+region|\\s+coast|\\s+states?|\\s+area)\\b`, 'i');
          } else {
            // For compound/multi-word regions like "northeast", "midwest", "gulf coast", etc.
            // These are unambiguous - keep original pattern
            regionPattern = new RegExp(`\\b(in\\s+the\\s+)?${regionKey}(\\s+region|\\s+states?|\\s+area)?\\b`, 'i');
          }
          
          if (regionPattern.test(questionLowerCheck)) {
            // FIX: Use Region column directly instead of expanding to states
            console.log(`[QueryEngine] ğŸŒ REGION DETECTED in question: "${regionKey}" â†’ Region column filter (NOT state expansion)`);
            classification.arguments.regions = [regionKey]; // Use Region column, not states
            // Switch to combined_filters which supports regions array
            if (classification.function_name === 'get_projects_by_state') {
              console.log(`[QueryEngine] ğŸ”„ Switching from get_projects_by_state to get_projects_by_combined_filters for region`);
              classification.function_name = 'get_projects_by_combined_filters';
            }
            break;
          }
        }
      }

      // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
      // SMALLEST/LARGEST N PROJECTS DETECTION (ALL QUERIES)
      // When user asks "smallest 3 projects" or "largest 5 projects"
      // Also handles: "smallest active 3 projects", "largest won 5 projects"
      // route to get_smallest_projects / get_largest_projects
      // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
      // Pattern 1: "smallest 3 active projects" - number comes first
      const smallestLargestPattern = /\b(smallest|lowest|cheapest|least\s+expensive|bottom)\s+(\d+)\s+(project|projects|active|open|submitted|won|records?)/i;
      const topLargestPattern = /\b(largest|biggest|highest|most\s+expensive|top)\s+(\d+)\s+(project|projects|active|open|submitted|won|records?)/i;
      
      // Pattern 2: "smallest active 3 projects" - number comes after status word
      const smallestAltPattern = /\b(smallest|lowest|cheapest|bottom)\s+(active|open|submitted|won|closed|lead|qualified|proposal|in\s+progress|hold)\s+(\d+)\s*(project|projects|records?)?/i;
      const largestAltPattern = /\b(largest|biggest|highest|top)\s+(active|open|submitted|won|closed|lead|qualified|proposal|in\s+progress|hold)\s+(\d+)\s*(project|projects|records?)?/i;
      
      const smallestMatch = smallestLargestPattern.exec(userQuestion);
      const topLargestMatch = topLargestPattern.exec(userQuestion);
      const smallestAltMatch = smallestAltPattern.exec(userQuestion);
      const largestAltMatch = largestAltPattern.exec(userQuestion);
      
      if (smallestMatch) {
        const extractedLimit = parseInt(smallestMatch[2], 10);
        console.log(`[QueryEngine] ğŸ”¢ SMALLEST N DETECTION: "${userQuestion}" â†’ get_smallest_projects with limit=${extractedLimit}`);
        classification.function_name = "get_smallest_projects";
        classification.arguments.limit = extractedLimit;
      } else if (smallestAltMatch) {
        const extractedLimit = parseInt(smallestAltMatch[3], 10);
        console.log(`[QueryEngine] ğŸ”¢ SMALLEST N ALT DETECTION: "${userQuestion}" â†’ get_smallest_projects with limit=${extractedLimit}`);
        classification.function_name = "get_smallest_projects";
        classification.arguments.limit = extractedLimit;
      } else if (topLargestMatch) {
        const extractedLimit = parseInt(topLargestMatch[2], 10);
        console.log(`[QueryEngine] ğŸ”¢ LARGEST N DETECTION: "${userQuestion}" â†’ get_largest_projects with limit=${extractedLimit}`);
        classification.function_name = "get_largest_projects";
        classification.arguments.limit = extractedLimit;
      } else if (largestAltMatch) {
        const extractedLimit = parseInt(largestAltMatch[3], 10);
        console.log(`[QueryEngine] ğŸ”¢ LARGEST N ALT DETECTION: "${userQuestion}" â†’ get_largest_projects with limit=${extractedLimit}`);
        classification.function_name = "get_largest_projects";
        classification.arguments.limit = extractedLimit;
      }
      // BOTTOM X / TOP X FOLLOW-UP CORRECTION
      // When user asks "bottom 3" or "top 5" as a follow-up, they want:
      // - Same query type as previous
      // - Just with different sort direction and limit
      // AI often misclassifies this as a POC ranking query
      // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
      if (previousContext) {
        const followUpLower = userQuestion.toLowerCase();
        
        // Detect "bottom X" or "top X" patterns in follow-up
        const bottomPattern = /\b(bottom|lowest|smallest|last)\s*(\d+)?\s*(projects?|records?|in\s+above|from\s+above|in\s+these|from\s+these|of\s+these)?/i;
        const topPattern = /\b(top|highest|largest|first)\s*(\d+)?\s*(projects?|records?|in\s+above|from\s+above|in\s+these|from\s+these|of\s+these)?/i;
        
        const bottomMatch = bottomPattern.exec(followUpLower);
        const topMatch = topPattern.exec(followUpLower);
        
        // Check if this is a simple "bottom/top X of above" follow-up
        // and AI incorrectly switched to a different function type
        // This includes: POC rankings, quarterly analysis, trend analysis, column selection, etc.
        const isMisclassifiedFunction = classification.function_name.includes('_performers') || 
                                   classification.function_name.includes('_pocs') ||
                                   classification.function_name.includes('_quarters') ||
                                   classification.function_name.includes('_trend') ||
                                   classification.function_name.includes('_ranking') ||
                                   classification.function_name.includes('_columns') ||
                                   classification.function_name === 'get_top_bottom_performers' ||
                                   classification.function_name === 'get_poc_performance_ranking' ||
                                   classification.function_name === 'get_peak_trough_quarters' ||
                                   classification.function_name === 'get_quarterly_trends' ||
                                   classification.function_name === 'get_best_worst_quarters' ||
                                   classification.function_name === 'select_specific_columns';
        
        // List of project-listing functions that support sort_direction
        // These are functions that return project rows and can be sorted/limited
        const projectListingFunctions = [
          'get_largest_projects',
          'get_smallest_projects', 
          'get_largest_in_region',  // Region queries
          'get_largest_by_category', // Category-based largest queries
          'get_projects_by_project_type', // Project type queries
          'get_projects_by_date_range',
          'get_projects_by_fee_range',
          'get_projects_by_combined_filters',
          'get_projects_by_status',
          'get_projects_by_category',
          'get_projects_by_state',
          'get_projects_by_years',
          'get_projects_by_year',
          'get_projects_by_pids',
          'get_projects_by_poc',
          'get_projects_by_client',
          'get_projects_by_company',
        ];
        
        // Also check if previous context has states array (region query)
        const previousHadStatesFilter = previousContext.arguments?.states && 
                                         Array.isArray(previousContext.arguments.states) && 
                                         previousContext.arguments.states.length > 0;
        
        // Check if previous function was a project listing (exact match or contained in list)
        const previousWasProjectListing = projectListingFunctions.includes(previousContext.function_name || '') || 
          previousHadStatesFilter;
        
        if ((bottomMatch || topMatch) && isMisclassifiedFunction && previousWasProjectListing) {
          console.log(`[QueryEngine] âš ï¸ BOTTOM/TOP FOLLOW-UP CORRECTION`);
          console.log(`[QueryEngine]   User asked: "${userQuestion}"`);
          console.log(`[QueryEngine]   AI classified as: ${classification.function_name}`);
          console.log(`[QueryEngine]   Previous was: ${previousContext.function_name}`);
          
          // Extract the limit number
          const match = bottomMatch || topMatch;
          const extractedLimit = match ? parseInt(match[2]) : 3; // Default to 3 if no number
          
          // Use appropriate function based on desired sort order
          // "bottom" = smallest fee values â†’ get_smallest_projects (ORDER BY ASC)
          // "top" = largest fee values â†’ get_largest_projects (ORDER BY DESC)
          classification.function_name = bottomMatch ? 'get_smallest_projects' : 'get_largest_projects';
          classification.arguments = {
            ...previousContext.arguments,  // Preserve all previous filters (states, dates, etc.)
            limit: extractedLimit || 3,
          };
          
          // Remove any POC-specific args that may have been incorrectly added
          delete classification.arguments.poc;
          delete classification.arguments.performance_tier;
          
          console.log(`[QueryEngine]   Corrected to: ${classification.function_name}`);
          console.log(`[QueryEngine]   With args: ${JSON.stringify(classification.arguments)}`);
        }
      }

      // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
      // FOLLOW-UP ENTITY FILTER PRESERVATION
      // When a follow-up query refines results (e.g., "which are open status"),
      // we must preserve entity filters (keyword, project_name, etc.) from the
      // previous query. Otherwise, the follow-up will query ALL records instead
      // of refining the previous entity-scoped results.
      // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
      if (previousContext && previousContext.arguments) {
        // CRITICAL: Direct preservation of entity values from previous context
        // This runs FIRST, before any conditional checks, to ensure values are always preserved
        const prevArgs = previousContext.arguments;
        console.log(`[QueryEngine] ğŸ” CATEGORY_TRACE: Entering DIRECT PRESERVE, prevArgs.category="${prevArgs?.category}", prevArgs._category_already_applied=${prevArgs?._category_already_applied}`);
        if (!classification.arguments) classification.arguments = {};
        
        // Directly copy entity values if they exist in previous context but not in current
        if (prevArgs.client && !classification.arguments.client) {
          classification.arguments.client = prevArgs.client;
          console.log(`[QueryEngine] ğŸ”— DIRECT PRESERVE: client="${prevArgs.client}"`);
        }
        console.log(`[QueryEngine] ğŸ” DIRECT PRESERVE CHECK: prevArgs.company="${prevArgs.company}", classification.arguments.company="${classification.arguments.company}"`);
        if (prevArgs.company && !classification.arguments.company) {
          classification.arguments.company = prevArgs.company;
          console.log(`[QueryEngine] ğŸ”— DIRECT PRESERVE: company="${prevArgs.company}" â†’ classification.arguments.company now = "${classification.arguments.company}"`);
        }
        if (prevArgs.poc && !classification.arguments.poc) {
          classification.arguments.poc = prevArgs.poc;
          console.log(`[QueryEngine] ğŸ”— DIRECT PRESERVE: poc="${prevArgs.poc}"`);
        }
        if (prevArgs.keyword && !classification.arguments.keyword) {
          classification.arguments.keyword = prevArgs.keyword;
          console.log(`[QueryEngine] ğŸ”— DIRECT PRESERVE: keyword="${prevArgs.keyword}"`);
        }
        // CRITICAL: Preserve category from disambiguation selection
        console.log(`[QueryEngine] ğŸ” CAT_CHK: prev="${prevArgs.category}", curr="${classification.arguments?.category}"`); if (prevArgs.category && !classification.arguments.category) {
        classification.arguments._debug_cat_chk = { prev: prevArgs.category, curr: classification.arguments?.category };
          classification.arguments.category = prevArgs.category;
          console.log(`[QueryEngine] ğŸ”— DIRECT PRESERVE: category="${prevArgs.category}"`);
        }
        // Directly copy entity flags
        if (prevArgs._client_already_applied) classification.arguments._client_already_applied = true;
        if (prevArgs._company_already_applied) classification.arguments._company_already_applied = true;
        if (prevArgs._poc_already_applied) classification.arguments._poc_already_applied = true;
        if (prevArgs._keyword_already_applied) classification.arguments._keyword_already_applied = true;
        if (prevArgs._category_already_applied) classification.arguments._category_already_applied = true;
        if (prevArgs._disambiguation_column) classification.arguments._disambiguation_column = prevArgs._disambiguation_column;
        if (prevArgs._disambiguation_locked) classification.arguments._disambiguation_locked = true;
        classification.arguments._debug_after_preserve = classification.arguments.category;
        
        // DEBUG: Log state after DIRECT PRESERVE
        console.log(`[QueryEngine] ğŸ” AFTER DIRECT PRESERVE: classification.arguments.company = "${classification.arguments.company}"`);
      }
      
      // Additional refinement-based entity preservation (original logic)
      if (previousContext && previousContext.arguments) {
        const prevArgs = previousContext.arguments;
        // Ensure classification.arguments exists to avoid null reference
        if (!classification.arguments) {
          classification.arguments = {};
        }
        const currArgs = classification.arguments;
        
        // Entity filters that should be preserved from previous context
        const entityFilters = ['keyword', 'project_name', 'organization', 'client', 'company', 'poc'];
        
        // Refinement functions that typically add filters (not entity queries)
        const refinementFunctions = [
          'get_projects_by_status',
          'get_projects_by_combined_filters',
          'get_projects_by_category',
          'get_projects_by_state',
          'get_projects_by_years',
          'get_projects_by_pids',
        ];
        
        // Check if previous query was an entity-based query (had keyword/entity filter)
        const prevHadEntityFilter = entityFilters.some(f => prevArgs[f] && prevArgs[f] !== '');
        
        // Check if current query is a refinement (status filter, date filter, etc.) without entity filter
        const currHasEntityFilter = entityFilters.some(f => currArgs[f] && currArgs[f] !== '');
        const currIsRefinement = refinementFunctions.includes(classification.function_name) || 
                                  (currArgs.status && currArgs.status.length > 0) ||
                                  (currArgs.states && currArgs.states.length > 0) ||
                                  (currArgs.year !== undefined) ||
                                  (currArgs.start_date !== undefined) ||
                                  (currArgs.end_date !== undefined) ||
                                  (currArgs.categories && currArgs.categories.length > 0) ||
                                  (currArgs.project_type !== undefined) ||
                                  (currArgs.division !== undefined) ||
                                  (currArgs.department !== undefined) ||
                                  (currArgs.min_fee !== undefined) ||
                                  (currArgs.max_fee !== undefined);
        
        // If previous had entity filter and current doesn't, merge it
        if (prevHadEntityFilter && !currHasEntityFilter && currIsRefinement) {
          console.log(`[QueryEngine] ğŸ”— FOLLOW-UP ENTITY PRESERVATION`);
          console.log(`[QueryEngine]   Previous function: ${previousContext.function_name}`);
          console.log(`[QueryEngine]   Current function: ${classification.function_name}`);
          
          // Copy entity filters from previous context
          for (const filter of entityFilters) {
            if (prevArgs[filter] && !currArgs[filter]) {
              console.log(`[QueryEngine]   Preserving ${filter}: "${prevArgs[filter]}"`);
              classification.arguments[filter] = prevArgs[filter];
            }
          }
          
          // Also preserve keyword-related context flags
          if (prevArgs._keyword_already_applied) {
            classification.arguments._keyword_already_applied = true;
          }
          if (prevArgs._keyword_context) {
            classification.arguments._keyword_context = prevArgs._keyword_context;
          }
          
          // CRITICAL: Preserve entity "already applied" flags from previous context
          if (prevArgs._client_already_applied) {
            classification.arguments._client_already_applied = true;
            console.log(`[QueryEngine]   Preserving _client_already_applied flag`);
          }
          if (prevArgs._company_already_applied) {
            classification.arguments._company_already_applied = true;
            console.log(`[QueryEngine]   Preserving _company_already_applied flag`);
          }
          if (prevArgs._poc_already_applied) {
            classification.arguments._poc_already_applied = true;
            console.log(`[QueryEngine]   Preserving _poc_already_applied flag`);
          }
          if (prevArgs._disambiguation_locked) {
            classification.arguments._disambiguation_locked = true;
            console.log(`[QueryEngine]   Preserving _disambiguation_locked flag`);
          }
          
          // CRITICAL: If client/company/poc was preserved, upgrade to entity-based function
          if (classification.arguments.client && classification.arguments._client_already_applied) {
            console.log(`[QueryEngine]   Upgrading to get_projects_by_client (client preserved from previous query)`);
            classification.function_name = 'get_projects_by_client';
          } else if (classification.arguments.company && classification.arguments._company_already_applied) {
            console.log(`[QueryEngine]   Upgrading to get_projects_by_company (company preserved from previous query)`);
            classification.function_name = 'get_projects_by_company';
          } else if (classification.arguments.poc && classification.arguments._poc_already_applied) {
            console.log(`[QueryEngine]   Upgrading to get_projects_by_poc (poc preserved from previous query)`);
            classification.function_name = 'get_projects_by_poc';
          }
          
          // Switch to search_projects_by_keyword to support both entity + refinement filters
          if (classification.function_name === 'get_projects_by_status' && classification.arguments.keyword) {
            console.log(`[QueryEngine]   Upgrading get_projects_by_status â†’ search_projects_by_keyword (with status filter)`);
            classification.function_name = 'search_projects_by_keyword';
          }
          
          console.log(`[QueryEngine]   Merged args: ${JSON.stringify(classification.arguments)}`);
        }
      }


      if (!classification.function_name || classification.function_name === "none") {
        // Check if it's a rate limit error (classification may have error properties from AI client)
        const classificationAny = classification as any;
        
        // FALLBACK: If we have context with result_data, try in-memory filtering
        // This handles follow-up questions like "which ones have budgets over 2 million?"
        // even when OpenAI is rate-limited or classification fails
        const contextWithData = (originalContext?.result_data && originalContext.result_data.length > 0) ? originalContext : 
                               ((previousContext?.result_data && previousContext.result_data.length > 0) ? previousContext : null);
        
        if (contextWithData && contextWithData.result_data) {
          console.log(`[QueryEngine] âš¡ CLASSIFICATION FALLBACK: Trying in-memory filter on ${contextWithData.result_data.length} context results`);
          
          const contextFilterResult = this.applyInMemoryContextFilters(
            userQuestion,
            contextWithData.result_data
          );
          
          if (contextFilterResult.applied) {
            console.log(`[QueryEngine]   âœ“ FALLBACK SUCCESS: Filtered ${contextWithData.result_data.length} â†’ ${contextFilterResult.data.length} results`);
            console.log(`[QueryEngine]   Filters applied: ${contextFilterResult.conditions.join(' AND ')}`);
            
            const summary = this.calculateSummaryStats(contextFilterResult.data);
            const chartConfig = this.generateChartConfig(contextFilterResult.data, 'get_projects_by_context_filter');
            
            const filterDescription = `-- Fallback in-memory filter applied to ${contextWithData.result_data.length} previous results\n-- Filters: ${contextFilterResult.conditions.join(' AND ')}\n-- Results: ${contextFilterResult.data.length} projects`;
            
            return {
              success: true,
              question: userQuestion,
              function_name: 'get_projects_by_context_filter',
              arguments: { 
                filters: contextFilterResult.conditions,
                source_count: contextWithData.result_data.length,
                result_count: contextFilterResult.data.length,
                _fallback_used: true,
              },
              data: contextFilterResult.data,
              row_count: contextFilterResult.data.length,
              summary,
              chart_config: chartConfig,
              message: contextFilterResult.data.length > 0 
                ? `Found ${contextFilterResult.data.length} projects matching: ${contextFilterResult.conditions.join(' AND ')}` 
                : `No projects found matching: ${contextFilterResult.conditions.join(' AND ')} (filtered from ${contextWithData.result_data.length} previous results)`,
              sql_query: filterDescription,
              sql_params: [],
            };
          } else {
            console.log(`[QueryEngine]   âœ— FALLBACK: No applicable in-memory filter found for: "${userQuestion}"`);
          }
        }
        
        if (classificationAny.error === "rate_limit") {
          const retrySeconds = classificationAny.retryAfter || 10;
          return {
            success: false,
            error: "rate_limit",
            message: `Our AI service is currently busy. Please try again in ${retrySeconds} seconds.`,
            data: [],
          };
        }
        
        return {
          success: false,
          error: "cannot_classify",
          message: "I couldn't understand that question. Could you try rephrasing it? For example, try asking about projects by date, status, category, client, or company.",
          data: [],
        };
      }

      // Step 1.4: Deterministic category vs tags routing

      // Convert to get_projects_by_category instead
      const questionLower = userQuestion.toLowerCase().trim();
      // Use word boundary regex to match standalone "tag", "tagged", "tag:" but NOT "heritage", "strategic"
      const tagsKeywordPattern = /\btag(s|ged|:)?\b/;
      const hastagsKeyword = tagsKeywordPattern.test(questionLower);
      const isCommaList = userQuestion.includes(',');
      
      if (!hastagsKeyword && !isCommaList && classification.function_name === 'get_projects_by_combined_filters') {
        const args = classification.arguments;
        
        // If there's a single tag (or tags array with one item) and no other meaningful filters
        if (args.tags && !args.categories) {
          const tagsArray = Array.isArray(args.tags) ? args.tags : [args.tags];
          
          // Check if there are any meaningful filters besides tags
          // Ignore: limit, start_date/end_date (date ranges are OK with category)
          const hasMeaningfulFilters = args.size || args.status || args.client || args.company || 
                                      args.poc || args.state_code || args.min_fee || args.max_fee ||
                                      args.min_win || args.max_win;
          
          if (tagsArray.length === 1 && !hasMeaningfulFilters) {
            // Convert to category-based query
            console.log(`[QueryEngine] âš ï¸ ROUTING CORRECTION: Converting tags to category`);
            console.log(`[QueryEngine]   Reason: Single value "${tagsArray[0]}" without "tag" keyword or commas`);
            console.log(`[QueryEngine]   Original: get_projects_by_combined_filters with tags=${JSON.stringify(tagsArray)}`);
            
            classification.function_name = 'get_projects_by_category';
            classification.arguments = {
              category: tagsArray[0],
              // Preserve date filters if present
              ...(args.start_date && { start_date: args.start_date }),
              ...(args.end_date && { end_date: args.end_date }),
              ...(args.limit && { limit: args.limit }),
            };
            
            console.log(`[QueryEngine]   Corrected: get_projects_by_category with category="${tagsArray[0]}"`);
          }
        }
      }

      // Step 1.4.4: Deterministic "categories" vs "project_type" routing
      // DEFAULT: Use "ProjectType" column (specific types like Higher Education, Hospitals)
      // EXCEPTION: Use "RequestCategory" column when user explicitly says "category" or "sector"
      // This prevents the AI from using "RequestCategory" when user says "type of" or similar
      // "sector" is a synonym for "category" and should NOT trigger project_type mapping
      const hasCategoryKeyword = /\b(categor(?:y|ies)|sectors?)\b/i.test(questionLower);
      const hasExplicitCategoryFlag = classification.arguments._explicit_category === true;
      
      if (!hasCategoryKeyword && !hasExplicitCategoryFlag && classification.arguments.categories) {
        const args = classification.arguments;
        const categoriesArray = Array.isArray(args.categories) ? args.categories : [args.categories];
        
        // If categories is set but project_type is NOT set, move categories to project_type
        if (categoriesArray.length > 0 && !args.project_type && !args.project_types) {
          console.log(`[QueryEngine] âš ï¸ FIELD CORRECTION: "categories" â†’ "project_type"`);
          console.log(`[QueryEngine]   Reason: User said "type" not "category" - default to Project Type column`);
          console.log(`[QueryEngine]   Original: categories=${JSON.stringify(categoriesArray)}`);
          
          if (categoriesArray.length === 1) {
            // Single value â†’ project_type
            args.project_type = categoriesArray[0];
          } else {
            // Multiple values â†’ project_types (array for OR logic)
            args.project_types = categoriesArray;
          }
          
          // Clear categories since we moved to project_type
      
       // Also remove singular form
          
          console.log(`[QueryEngine]   Corrected: project_type="${args.project_type || args.project_types?.join(', ')}"`);
        }
      }

      // Step 1.4.5: Map "completed" and "finished" status to actual database values
      // The database doesn't have "completed" or "finished" status
      if (classification.arguments.status) {
        // Handle both string and array status values
        if (Array.isArray(classification.arguments.status)) {
          // AI extracted multiple status values as array (e.g., ["Proposal Development", "Submitted"])
          // Map each element if needed, expanding "closed" to both Won and Lost
          const expandedStatuses: string[] = [];
          for (const s of classification.arguments.status) {
            const statusLower = s.toLowerCase();
            if (statusLower === 'completed' || statusLower === 'complete') {
              console.log(`[QueryEngine] âš ï¸ STATUS MAPPING: "completed" â†’ "Won"`);
              expandedStatuses.push('Won');
            } else if (statusLower === 'finished' || statusLower === 'done') {
              console.log(`[QueryEngine] âš ï¸ STATUS MAPPING: "${statusLower}" â†’ "Won"`);
              expandedStatuses.push('Won');
            } else if (statusLower === 'closed' || statusLower === 'close') {
              // "Closed" = both Won and Lost (deals no longer in pipeline)
              console.log(`[QueryEngine] âš ï¸ STATUS MAPPING: "closed" â†’ ["Won", "Lost"] (both closed statuses)`);
              expandedStatuses.push('Won', 'Lost');
            } else {
              expandedStatuses.push(s); // Keep original value
            }
          }
          classification.arguments.status = expandedStatuses;
        } else {
          // Single status value as string
          const statusLower = classification.arguments.status.toLowerCase();
          
          if (statusLower === 'completed' || statusLower === 'complete') {
            // "Completed" typically means successfully finished projects
            console.log(`[QueryEngine] âš ï¸ STATUS MAPPING: "completed" â†’ "Won"`);
            classification.arguments.status = 'Won';
          } else if (statusLower === 'finished' || statusLower === 'done') {
            // "Finished" means successfully completed = Won
            console.log(`[QueryEngine] âš ï¸ STATUS MAPPING: "${statusLower}" â†’ "Won"`);
            classification.arguments.status = 'Won';
          } else if (statusLower === 'closed' || statusLower === 'close') {
            // "Closed" = Lost, No Go, Cancelled, Hold (deals no longer in pipeline)
            console.log(`[QueryEngine] âš ï¸ STATUS MAPPING: "closed" â†’ ["Lost", "No Go", "Cancelled"]`);
            classification.arguments.status = ['Lost', 'No Go', 'Cancelled', 'Hold'];
          } else if (statusLower === 'open') {
            // "Open" = Proposal Development, Qualified Lead, Submitted, Won (active pipeline)
            console.log(`[QueryEngine] âš ï¸ STATUS MAPPING: "open" â†’ ["Proposal Development", "Qualified Lead", "Submitted", "Won", "Lead", "In Progress", "Hold"]`);
            classification.arguments.status = ['Proposal Development', 'Qualified Lead', 'Submitted', 'Won'];
          } else if (statusLower === 'likely' || statusLower === 'probable' || statusLower === 'probable to win') {
            // "Likely" means high win percentage, NOT a status
            console.log(`[QueryEngine] âš ï¸ "LIKELY" DETECTION: Converting to high win percentage filter`);
            console.log(`[QueryEngine]   Original: status="${classification.arguments.status}"`);
            
            // Remove the invalid status filter
            delete classification.arguments.status;
            
            // Add high win percentage filter (75%+)
            classification.arguments.min_win = 75;
            
            console.log(`[QueryEngine]   Corrected: Removed status, added min_win=75`);
          }
        }
      }

      // Step 1.4.6: Handle "likely" in reference_status (for pattern matching queries)
      if (classification.arguments.reference_status) {
        const refStatusLower = classification.arguments.reference_status.toLowerCase();
        
        if (refStatusLower === 'likely' || refStatusLower === 'probable' || refStatusLower === 'probable to win') {
          // "Likely" means we want projects with high win probability
          console.log(`[QueryEngine] âš ï¸ "LIKELY" in reference_status: Converting to high win percentage query`);
          console.log(`[QueryEngine]   Original function: ${classification.function_name}`);
          console.log(`[QueryEngine]   Original: reference_status="${classification.arguments.reference_status}"`);
          
          // Change to a simpler query type that supports win percentage filters
          classification.function_name = 'get_projects_by_combined_filters';
          
          // Remove reference_status and add min_win filter
          delete classification.arguments.reference_status;
          classification.arguments.min_win = 75;
          
          // Preserve time reference if present
          if (classification.arguments.time_reference) {
            // Keep it for preprocessing
          }
          
          console.log(`[QueryEngine]   Corrected: Changed to get_projects_by_combined_filters with min_win=75`);
        }
      }

      // Step 1.5: Detect anaphoric references (these/those/above) - forces context retention
      // IMPORTANT: For "which of these" type queries, use originalContext (root results) if available
      // since user is typically referring to the main result set, not intermediate follow-ups
      if (previousContext || originalContext) {
        // Use PHRASE-BASED patterns to avoid false positives with common words like "this"/"that"
        const ANAPHORA_PATTERNS = [
          /\bthese\s+(projects|clients|results|companies|states|records|items)/i,
          /\bthose\s+(projects|clients|results|companies|states|records|items)/i,
          /\b(the\s+)?(above|previous|same)\s+(projects|clients|results|companies|states|records|items)/i,
          /\bfrom\s+(them|these|those|the\s+above|the\s+results|the\s+data)/i,
          /\bin\s+(these|those|the\s+above|the\s+results)/i,
          /\btotal\s+(fee|value|revenue|cost)\s+from\s+(these|those|them)/i,
          /\bwhich\s+of\s+(this|these|those|them)\b/i,
          /\b(of\s+)?(this|these|those)\s+(are|is)\s+(most\s+)?(likely|probable)/i,
          // "Which ones" patterns - common follow-up phrasing
          /\bwhich\s+ones?\b/i,
          /\bhow\s+many\s+(of\s+)?(them|these|those)\b/i,
          /\bshow\s+(me\s+)?(the\s+)?(ones?|those|them)\s+(with|that|where|having)\b/i,
        ];
        
        const questionLower = userQuestion.toLowerCase();
        const matchedPattern = ANAPHORA_PATTERNS.find(pattern => pattern.test(questionLower));
        
        if (matchedPattern) {
          console.log(`[QueryEngine] ğŸ”— ANAPHORA DETECTED: "${userQuestion}"`);
          console.log(`[QueryEngine]   Pattern matched: ${matchedPattern}`);
          
          // IMPORTANT: Use originalContext (root) for PID extraction if available
          // This ensures "which of these" refers to the original result set, not intermediate queries
          const contextForPids = originalContext || previousContext;
          const contextSource = originalContext ? 'originalContext (root)' : 'previousContext';
          console.log(`[QueryEngine]   Using ${contextSource} for PID extraction`);
          
          // Extract PIDs from context results to filter by them
          // PIDs can be in: row.PID, row["Title"] = "PID 1234", or row.project_name
          if (contextForPids?.result_data && contextForPids.result_data.length > 0) {
            const pidsFromContext = contextForPids.result_data
              .map((row: any) => {
                // Direct PID field
                if (row.PID || row.pid) return row.PID || row.pid;
                // Extract from "Title" field (format: "PID 1234")
                const projectName = row["Title"] || row.project_name || row.ProjectName;
                if (projectName && typeof projectName === 'string') {
                  const match = projectName.match(/^PID\s*(\d+)$/i);
                  if (match) return projectName; // Return full "PID 1234" for WHERE clause
                }
                return null;
              })
              .filter((pid: any) => pid);
            
            if (pidsFromContext.length > 0) {
              console.log(`[QueryEngine]   ğŸ“Œ Extracting ${pidsFromContext.length} PIDs from ${contextSource} for filtering`);
              console.log(`[QueryEngine]   PIDs: ${pidsFromContext.slice(0, 5).join(', ')}${pidsFromContext.length > 5 ? '...' : ''}`);
              
              // IN-MEMORY CONTEXT FILTER: Check if question has additional numeric filters
              // If so, filter context data directly instead of querying database
              const contextFilterResult = this.applyInMemoryContextFilters(
                userQuestion,
                contextForPids?.result_data || []
              );
              
              if (contextFilterResult.applied) {
                console.log(`[QueryEngine]   ğŸ¯ IN-MEMORY FILTER APPLIED: ${contextFilterResult.conditions.join(' AND ')}`);
                console.log(`[QueryEngine]   Filtered ${contextForPids?.result_data?.length || 0} â†’ ${contextFilterResult.data.length} results`);
                
                // Return early with filtered results
                const summary = this.calculateSummaryStats(contextFilterResult.data);
                const chartConfig = this.generateChartConfig(contextFilterResult.data, 'get_projects_by_context_filter');
                
                // Create a pseudo-SQL description for the filter
                const filterDescription = `-- In-memory filter applied to ${contextForPids?.result_data?.length || 0} previous results\n-- Filters: ${contextFilterResult.conditions.join(' AND ')}\n-- Results: ${contextFilterResult.data.length} projects`;
                
                return {
                  success: true,
                  question: userQuestion,
                  function_name: 'get_projects_by_context_filter',
                  arguments: { 
                    filters: contextFilterResult.conditions,
                    source_count: contextForPids?.result_data?.length || 0,
                    result_count: contextFilterResult.data.length,
                  },
                  data: contextFilterResult.data,
                  row_count: contextFilterResult.data.length,
                  summary,
                  chart_config: chartConfig,
                  message: contextFilterResult.data.length > 0 
                    ? `Found ${contextFilterResult.data.length} projects matching: ${contextFilterResult.conditions.join(' AND ')}` 
                    : `No projects found matching: ${contextFilterResult.conditions.join(' AND ')} (filtered from ${contextForPids?.result_data?.length || 0} previous results)`,
                  sql_query: filterDescription,
                  sql_params: [],
                };
              }
              
              // No in-memory filter applied - use PID-based query
              classification.arguments.pids = pidsFromContext;
              
              // Force to get_projects_by_pids for direct PID filtering
              classification.function_name = 'get_projects_by_pids';
              console.log(`[QueryEngine]   Switched to get_projects_by_pids for accurate "which of these" query`);
              
              // Detect "bottom X" vs "top X" for sort direction
              // "bottom" = smallest/lowest values â†’ ASC order
              // "top" = largest/highest values â†’ DESC order
              const followUpLower = userQuestion.toLowerCase();
              const bottomKeywords = /\b(bottom|lowest|smallest|cheapest|last|least)\s*(\d+)?/i;
              const topKeywords = /\b(top|highest|largest|biggest|first|most|best)\s*(\d+)?/i;
              
              const bottomMatch = bottomKeywords.exec(followUpLower);
              const topMatch = topKeywords.exec(followUpLower);
              
              if (bottomMatch) {
                classification.arguments.sort_direction = 'ASC';
                console.log(`[QueryEngine]   ğŸ”½ BOTTOM detected - sort_direction=ASC`);
                // Extract limit from pattern if present
                if (bottomMatch[2]) {
                  classification.arguments.limit = parseInt(bottomMatch[2]);
                  console.log(`[QueryEngine]   Extracted limit=${bottomMatch[2]} from "bottom ${bottomMatch[2]}"`);
                }
              } else if (topMatch) {
                classification.arguments.sort_direction = 'DESC';
                console.log(`[QueryEngine]   ğŸ”¼ TOP detected - sort_direction=DESC`);
                // Extract limit from pattern if present
                if (topMatch[2]) {
                  classification.arguments.limit = parseInt(topMatch[2]);
                  console.log(`[QueryEngine]   Extracted limit=${topMatch[2]} from "top ${topMatch[2]}"`);
                }
              }
              
              // Don't carry forward date filters - PID filtering is sufficient
              delete classification.arguments.start_date;
              delete classification.arguments.end_date;
              delete classification.arguments._date_already_applied;
              console.log(`[QueryEngine]   Removed date filters - PID filtering is sufficient`);
            }
          }
          
          // Also preserve limit from context if it had one
          const contextWithLimit = originalContext || previousContext;
          if (contextWithLimit?.arguments?.limit && !classification.arguments.limit) {
            classification.arguments.limit = contextWithLimit.arguments.limit;
            console.log(`[QueryEngine]   ğŸ“Œ Preserved limit=${contextWithLimit.arguments.limit} from context`);
          }
        } else if (previousContext && classification.function_name !== previousContext.function_name) {
          // Original logic for other function changes without anaphora
        }
      }

      // Step 1.5b: Detect override/negation intent - skip context merge if user wants fresh query
      const overrideResult = this.detectOverrideIntent(userQuestion);
      
      // Step 1.5c: Detect if this is a NEW independent query (not a follow-up)
      // IMPORTANT: If originalContext is provided, the frontend explicitly sent this as a follow-up
      // so we should ALWAYS merge context, not detect it as a new query
      const newQueryResult = originalContext 
        ? { isNew: false, reason: 'originalContext provided - treating as follow-up' }
        : this.isNewIndependentQuery(
            userQuestion, 
            classification.function_name, 
            previousContext?.function_name
          );
      
      if (originalContext) {
        console.log(`[QueryEngine] ğŸ“Œ originalContext provided - forcing follow-up merge (skipping new query detection)`);
      }
      
      // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
      // STATE-BASED FOLLOW-UP HANDLING: Use LLM to interpret follow-up operations
      // This ensures 100% accuracy by explicitly determining add/replace/remove operations
      // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
      
      let stateBasedArgs: Record<string, any> | null = null;
      
      // Run state-based follow-up for ALL follow-ups (including overrides)
      // The LLM can correctly handle "only X" as a replace_filter operation
      if (originalContext && !newQueryResult.isNew) {
        console.log(`[QueryEngine] ğŸ¯ STATE-BASED FOLLOW-UP: Using LLM to interpret follow-up operations`);
        console.log(`[QueryEngine]   Override detected: ${overrideResult.isOverride} (${overrideResult.reason || 'none'})`);
        
        try {
          // CRITICAL FIX: Build CUMULATIVE arguments from originalContext + previousContext
          // This ensures all filters (dates, fees, etc.) are preserved across follow-up chains
          const ARRAY_PARAMS = ['states', 'tags', 'categories', 'project_types', 'years', 'exclude_tags', 'divisions', 'departments', 'sectors'];
          const SCALAR_PARAMS = ['min_fee', 'max_fee', 'min_win', 'max_win', 'status', 'state_code', 'organization',
                                 'category', 'company', 'client', 'poc', 'start_date', 'end_date', 
                                 'year', 'project_type', '_explicit_category', '_region', '_project_type_explicit',
                                 'division', 'department', 'sector'];
          
          let cumulativeArgs: Record<string, any> = {};
          
          if (originalContext && previousContext && originalContext !== previousContext) {
            // Merge original + previous: arrays union, scalars latest-wins
            console.log(`[QueryEngine] ğŸ”— STATE CUMULATIVE: Merging originalContext + previousContext`);
            
            // Start with all original args
            cumulativeArgs = { ...originalContext.arguments };
            
            // Merge arrays (union with dedupe)
            for (const key of ARRAY_PARAMS) {
              const origVal = originalContext.arguments[key];
              const prevVal = previousContext.arguments[key];
              if (Array.isArray(origVal) && Array.isArray(prevVal)) {
                cumulativeArgs[key] = Array.from(new Set([...origVal, ...prevVal]));
              } else if (Array.isArray(prevVal)) {
                cumulativeArgs[key] = prevVal;
              }
            }
            
            // Scalars: previous wins (latest value)
            for (const key of SCALAR_PARAMS) {
              const prevVal = previousContext.arguments[key];
              if (prevVal !== null && prevVal !== undefined) {
                cumulativeArgs[key] = prevVal;
              }
            }
            
            console.log(`[QueryEngine]   Original args: ${JSON.stringify(originalContext.arguments)}`);
            console.log(`[QueryEngine]   Previous args: ${JSON.stringify(previousContext.arguments)}`);
            console.log(`[QueryEngine]   Cumulative result: ${JSON.stringify(cumulativeArgs)}`);
            console.log(`[QueryEngine]   ğŸ” STATE YEAR DEBUG: orig.year=${originalContext.arguments?.year}, prev.year=${previousContext.arguments?.year}, cumulative.year=${cumulativeArgs?.year}`);
          } else {
            // Single context - use whichever is available
            const baseContext = previousContext || originalContext;
            cumulativeArgs = { ...baseContext.arguments };
          }
          
          const queryState = createInitialQueryState(
            originalContext.question,
            previousContext?.function_name || originalContext.function_name,
            cumulativeArgs
          );
          
          // Use LLM to interpret the follow-up question and get structured operations
          const operations = await interpretFollowUp(
            this.openaiClient,
            userQuestion,
            queryState
          );
          
          if (operations.length > 0) {
            // Apply operations to get updated state
            const updatedState = applyFollowUpOperations(queryState, operations);
            
            // Convert state back to arguments
            stateBasedArgs = stateToArguments(updatedState);
            
            // Keep the classification's function_name (in case follow-up changes it)
            // but use the state's filters
            console.log(`[QueryEngine] âœ… State-based args:`, JSON.stringify(stateBasedArgs));
          } else {
            console.log(`[QueryEngine] âš ï¸ No operations from LLM, falling back to legacy merge`);
          }
        } catch (error) {
          console.error(`[QueryEngine] âŒ State-based follow-up failed, falling back to legacy:`, error);
        }
      }
      
      // Step 1.6: CUMULATIVE MERGE - combine originalContext + previousContext for accumulating filters
      // Follow-up 1 = Original + Follow-up1
      // Follow-up 2 = Original + Follow-up1 + Follow-up2
      // Follow-up 3 = Original + Follow-up1 + Follow-up2 + Follow-up3
      // BUT skip merge if: override intent detected OR it's a new independent query
      const shouldSkipMerge = overrideResult.isOverride || newQueryResult.isNew;
      
      // TWO-TIER CUMULATIVE MERGE for filter accumulation across follow-ups
      // ARRAY params (states, tags) = UNION with dedupe
      // SCALAR params (company, client) = Latest follow-up OVERRIDES previous
      // Range params (min_fee, max_fee) = Accumulate from original, override if follow-up specifies
      
      const ARRAY_FILTER_PARAMS = new Set([
        'states', 'tags', 'exclude_tags', 'categories', 'exclude_categories', 
        'project_types', 'years', 'divisions', 'departments', 'sectors'
      ]);
      const SCALAR_FILTER_PARAMS = new Set([
        'min_fee', 'max_fee', 'min_win', 'max_win',
        'status', 'state_code',
        'category', 'company', 'client', 'poc',
        'start_date', 'end_date', 'year', 'quarter',
        'project_type',
        '_explicit_category', '_region',
        'division', 'department', 'sector'
      ]);
      
      // Build cumulative context by merging original + previous FILTERS ONLY
      let contextForMerge: { question: string; function_name: string; arguments: Record<string, any>; result_data?: any[] } | undefined;
      
      console.log(`[QueryEngine] ğŸ” CUMULATIVE ENTRY CHECK: originalContext=${!!originalContext}, previousContext=${!!previousContext}, areDifferent=${originalContext !== previousContext}`);
      console.log(`[QueryEngine] ğŸ” CUMULATIVE ENTRY CHECK: shouldSkipMerge=${shouldSkipMerge}, overrideResult.isOverride=${overrideResult.isOverride}, newQueryResult.isNew=${newQueryResult.isNew}`);
      if (originalContext) console.log(`[QueryEngine] ğŸ” originalContext.arguments.year=${originalContext.arguments?.year}`);
      if (previousContext) console.log(`[QueryEngine] ğŸ” previousContext.arguments.year=${previousContext.arguments?.year}`);
      
      if (originalContext && previousContext && originalContext !== previousContext) {
        // CUMULATIVE: Two-tier merge - arrays union, scalars latest-wins
        console.log(`[QueryEngine] ğŸ”— CUMULATIVE MERGE: Combining originalContext + previousContext filters`);
        
        const cumulativeArgs: Record<string, any> = {};
        
        // Step 1: Copy ARRAY params from original, then UNION with previous
        Array.from(ARRAY_FILTER_PARAMS).forEach(key => {
          const origVal = originalContext.arguments[key];
          const prevVal = previousContext.arguments[key];
          if (Array.isArray(origVal) && Array.isArray(prevVal)) {
            cumulativeArgs[key] = Array.from(new Set([...origVal, ...prevVal]));
          } else if (Array.isArray(origVal)) {
            cumulativeArgs[key] = origVal;
          } else if (Array.isArray(prevVal)) {
            cumulativeArgs[key] = prevVal;
          }
        });
        
        // Step 2: For SCALAR params - start with original, then override with previous (latest wins)
        Array.from(SCALAR_FILTER_PARAMS).forEach(key => {
          const origVal = originalContext.arguments[key];
          const prevVal = previousContext.arguments[key];
          if (prevVal !== null && prevVal !== undefined) {
            cumulativeArgs[key] = prevVal; // Latest follow-up wins
          } else if (origVal !== null && origVal !== undefined) {
            cumulativeArgs[key] = origVal; // Fall back to original
          }
        });
        
        contextForMerge = {
          question: previousContext.question,
          function_name: previousContext.function_name,
          arguments: cumulativeArgs,
          result_data: previousContext.result_data
        };
        console.log(`[QueryEngine]   Original filters: ${JSON.stringify(originalContext.arguments)}`);
        console.log(`[QueryEngine]   Previous filters: ${JSON.stringify(previousContext.arguments)}`);
        console.log(`[QueryEngine]   Cumulative result: ${JSON.stringify(cumulativeArgs)}`);
        console.log(`[QueryEngine]   ğŸ” YEAR DEBUG: orig.year=${originalContext.arguments?.year}, prev.year=${previousContext.arguments?.year}, cumulative.year=${cumulativeArgs?.year}`);
      } else {
        // Single context - use whichever is available
        contextForMerge = originalContext || previousContext;
      }
      
      // AGGREGATION FUNCTION PRIORITY: When follow-up asks for aggregation (e.g., "which poc has highest revenue"),
      // use the NEW classification function_name even when merging context filters
      const AGGREGATION_FUNCTIONS = [
        'get_top_pocs', 'get_top_clients', 'get_top_tags', 'get_status_breakdown',
        'get_revenue_by_project_type', 'get_project_type_breakdown', 'compare_companies', 
        'compare_clients', 'get_revenue_by_category', 'get_category_breakdown',
        'get_company_breakdown', 'get_client_breakdown', 'get_poc_breakdown'
      ];
      const LISTING_FUNCTIONS = [
        'get_projects_by_combined_filters', 'get_largest_projects', 'get_smallest_projects',
        'get_projects_by_date_range', 'get_projects_by_year', 'get_projects_by_category',
        'get_projects_by_company', 'get_projects_by_client', 'get_projects_by_pids'
      ];
      
      // Check if new classification is an aggregation function while context was a listing
      const newIsAggregation = AGGREGATION_FUNCTIONS.includes(classification.function_name);
      const contextWasListing = contextForMerge && LISTING_FUNCTIONS.includes(contextForMerge.function_name);
      
      if (newIsAggregation && contextWasListing && !shouldSkipMerge && contextForMerge) {
        console.log(`[QueryEngine] ğŸ¯ AGGREGATION PRIORITY: Follow-up asks for aggregation (${classification.function_name})`);
        console.log(`[QueryEngine]   Context was listing function (${contextForMerge.function_name})`);
        console.log(`[QueryEngine]   Keeping NEW function_name: ${classification.function_name}`);
        console.log(`[QueryEngine]   Merging context FILTERS only (min_fee, status, etc.)`);
        
        // Preserve context filters only (not function-specific args)
        const contextFilters = ['min_fee', 'max_fee', 'min_win', 'max_win', 'status', 'state_code', 'states', 
                                'categories', 'tags', 'company', 'client', 'poc', 'pocs', 'start_date', 'end_date',
                                'project_type', 'project_types', 'year', 'years', 'quarter', 'category',
                                'division', 'divisions', 'department', 'departments', 'sector', 'sectors'];
        for (const filter of contextFilters) {
          if (contextForMerge.arguments[filter] !== undefined && classification.arguments[filter] === undefined) {
            // GUARD: Skip categories re-injection when project_type is explicitly set
            if ((filter === "categories" || filter === "category") && classification.arguments._project_type_explicit) {
              console.log(`[QueryEngine]   26D4 SKIP: Blocking ${filter} merge (project_type already set)`);
              continue;
            }
            classification.arguments[filter] = contextForMerge.arguments[filter];
            console.log(`[QueryEngine]   ğŸ“Œ Inherited filter ${filter}=${JSON.stringify(contextForMerge.arguments[filter])}`);
          }
        }
      } else if (contextForMerge && !shouldSkipMerge) {
        const contextSource = originalContext ? 'ORIGINAL' : 'PREVIOUS';
        console.log(`[QueryEngine] ğŸŒŸ Using ${contextSource} context for smart merge`);
        
        // USE STATE-BASED ARGS IF AVAILABLE (from LLM interpretation)
        // This provides 100% accuracy for follow-up combinations
        if (stateBasedArgs) {
          console.log(`[QueryEngine] âœ… USING STATE-BASED ARGS (LLM-interpreted follow-up)`);
          console.log(`[QueryEngine] ğŸ” YEAR DEBUG: stateBasedArgs.year=${stateBasedArgs?.year}, contextForMerge.arguments.year=${contextForMerge?.arguments?.year}`);
          // Merge state-based args with classification args (state-based takes precedence for filters)
          const sanitizedStateArgs = Object.fromEntries(
            Object.entries(stateBasedArgs).filter(([key, value]) => value !== undefined && value !== null)
          );
          classification.arguments = { ...classification.arguments, ...sanitizedStateArgs };
          
          console.log(`[QueryEngine] ğŸ” CATEGORY_TRACE: After stateBasedArgs spread, category="${classification.arguments?.category}", _category_already_applied=${classification.arguments?._category_already_applied}`);
          // POST-SPREAD CLEANUP: Remove categories re-injected by stateBasedArgs when project_type is explicit
          if (classification.arguments._project_type_explicit && (classification.arguments.categories || classification.arguments.category)) {
            console.log(`[QueryEngine] uD83EuDDF9 POST-SPREAD CLEANUP: Removing re-injected categories (project_type is explicit)`);
            delete classification.arguments.categories;
            if (!classification.arguments._category_already_applied) delete classification.arguments.category;
          }
          
          // SAFEGUARD: Ensure ALL original context filters are preserved (in case LLM missed them)
          const preserveFilters = ['poc', 'pocs', 'company', 'client', 'clients', 'states', 'state_code',
                                   'categories', 'category', 'tags', 'project_type', 'project_types',
                                   'min_fee', 'max_fee', 'min_win', 'max_win', 'status', 'start_date', 'end_date',
                                   'year', 'years', 'division', 'divisions', 'department', 'departments', 'sector', 'sectors'];
          for (const filter of preserveFilters) {
            if (contextForMerge.arguments[filter] !== undefined && classification.arguments[filter] === undefined) {
            // GUARD: Skip categories re-injection when project_type is explicitly set
            if ((filter === "categories" || filter === "category") && classification.arguments._project_type_explicit) {
              console.log(`[QueryEngine]   u26D4 SKIP: Blocking ${filter} merge (project_type already set)`);
              continue;
            }
              classification.arguments[filter] = contextForMerge.arguments[filter];
              console.log(`[QueryEngine]   ğŸ”’ SAFEGUARD: Preserved missing filter ${filter}=${JSON.stringify(contextForMerge.arguments[filter])}`);
            }
          }
          
          // CRITICAL: Reset internal "_already_applied" flags for follow-up queries
          // These flags are set during the ORIGINAL query execution and prevent re-application
          // But for follow-ups with different template functions, we MUST re-apply the filters
          const internalFlags = ['_poc_already_applied', '_status_already_applied', '_company_already_applied',
                                 '_client_already_applied', '_state_already_applied', '_category_already_applied',
                                 '_project_type_already_applied'];
          for (const flag of internalFlags) {
            if (classification.arguments[flag]) {
              delete classification.arguments[flag];
              console.log(`[QueryEngine]   ğŸ”„ Reset internal flag: ${flag} (will re-apply filter)`);
            }
          }
          
          // FOLLOW-UP DEPARTMENT/DIVISION EXTRACTION: When follow-up switches to department/division template,
          // extract the department/division name from the follow-up question if not already present
          if (classification.function_name === 'get_projects_by_department' && !classification.arguments.department) {
            const deptMatch = userQuestion.match(/(?:related\s+to|in|of|for|from|under|assigned\s+to)\s+(?:the\s+)?([\w&\s:\-]+)\s+department/i) ||
                             userQuestion.match(/([\w&\s:\-]+)\s+department\s+projects?/i);
            if (deptMatch && deptMatch[1]) {
              classification.arguments.department = deptMatch[1].trim();
              console.log(`[QueryEngine] ğŸ¢ FOLLOW-UP EXTRACTION: Extracted department="${classification.arguments.department}" from follow-up question`);
            }
          }
          if (classification.function_name === 'get_projects_by_division' && !classification.arguments.division) {
            const divMatch = userQuestion.match(/(?:related\s+to|in|of|for|from|under|assigned\s+to)\s+(?:the\s+)?([\w\s\-:&]+)\s+division/i) ||
                            userQuestion.match(/([\w\s\-:&]+)\s+division\s+projects?/i);
            if (divMatch && divMatch[1]) {
              classification.arguments.division = divMatch[1].trim();
              console.log(`[QueryEngine] ğŸ¢ FOLLOW-UP EXTRACTION: Extracted division="${classification.arguments.division}" from follow-up question`);
            }
          }
          
          // Normalize the merged arguments to ensure SQL clause handlers get expected names
          classification.arguments = normalizeClassificationArguments(classification.arguments, userQuestion);
      console.log(`[QueryEngine] ğŸ” DEBUG PRE-EXECUTE: classification.arguments.category="${classification?.arguments?.category}", _category_already_applied=${classification?.arguments?._category_already_applied}`);
          classification.arguments = stripHallucinatedGeography(classification.arguments, userQuestion);
          console.log(`[QueryEngine] After state-based merge + normalize:`, JSON.stringify(classification.arguments, null, 2));
          console.log(`[QueryEngine] ğŸ” FINAL YEAR CHECK after state-based: classification.arguments.year=${classification.arguments?.year}`);
        } else {
          // Fall back to legacy smartMergeArguments
          classification.arguments = this.smartMergeArguments(
            contextForMerge.arguments,
            classification.arguments,
            contextForMerge.function_name,
            classification.function_name
          );
          console.log(`[QueryEngine] After legacy smart merge:`, JSON.stringify(classification.arguments, null, 2));
        }
        
        // CRITICAL: For follow-up refinements, PRESERVE the original function_name
        // unless the user is explicitly switching to an aggregation function
        // This ensures "show opportunities + win% filter" stays with get_client_expansion_opportunities
        const isNewAggregation = AGGREGATION_FUNCTIONS.includes(classification.function_name);
        const wasOriginalAggregation = originalContext && AGGREGATION_FUNCTIONS.includes(originalContext.function_name);
        const wasOriginalSpecialized = originalContext && [
          'get_client_expansion_opportunities', 'get_high_risk_opportunities',
          'get_portfolio_diversity', 'get_client_concentration', 'get_stalled_deals',
          'get_client_lifetime_value', 'get_top_predicted_wins', 'get_seasonal_analysis'
        ].includes(originalContext.function_name);
        
        // Preserve original function when: it's a specialized/aggregation function and new classification is generic
        if (originalContext && wasOriginalSpecialized && !isNewAggregation) {
          console.log(`[QueryEngine] ğŸ”„ FOLLOW-UP PRESERVATION: Keeping original specialized function`);
          console.log(`[QueryEngine]   Original: ${originalContext.function_name}`);
          console.log(`[QueryEngine]   New (discarded): ${classification.function_name}`);
          classification.function_name = originalContext.function_name;
        }
        
        // EXPLICIT CATEGORY FIX: If user explicitly says "request category" in follow-up,
        // remove any inherited project_type from context - user wants Request Category ONLY
        const explicitCategoryInFollowUp = /\b(request\s+)?categor(y|ies)\b/i.test(userQuestion);
        if (explicitCategoryInFollowUp && (classification.arguments.categories || classification.arguments.category)) {
          if (classification.arguments.project_type || classification.arguments.project_types) {
            console.log(`[QueryEngine] ğŸ“‚ EXPLICIT CATEGORY FIX: User said "category" in follow-up`);
            console.log(`[QueryEngine]   Removing inherited project_type: ${classification.arguments.project_type || classification.arguments.project_types}`);
            delete classification.arguments.project_type;
            delete classification.arguments.project_types;
            delete classification.arguments._project_type_keyword;
            delete classification.arguments._project_type_explicit;
            delete classification.arguments._project_type_already_applied;
          }
          classification.arguments._explicit_category = true;
          console.log(`[QueryEngine]   Set _explicit_category=true to preserve Request Category filter`);
        }
        
        // Resolve entity references using previousContext data (most recent results)
        // but merge arguments from originalContext (base filters)
        const dataForResolution = previousContext?.result_data || originalContext?.result_data;
        if (dataForResolution && dataForResolution.length > 0) {
          classification.arguments = this.resolveEntityReferences(
            classification.arguments,
            dataForResolution,
            userQuestion
          );
          console.log(`[QueryEngine] After entity resolution:`, JSON.stringify(classification.arguments, null, 2));
        }
      } else if (overrideResult.isOverride) {
        console.log(`[QueryEngine] âš¡ OVERRIDE DETECTED: "${overrideResult.reason}" - preserving CUMULATIVE filters only`);
        
        // USE STATE-BASED ARGS IF AVAILABLE (from LLM interpretation)
        // State-based system already correctly handled the override semantics
        if (stateBasedArgs) {
          console.log(`[QueryEngine] âœ… USING STATE-BASED ARGS for override (LLM-interpreted)`);
          const sanitizedStateArgs = Object.fromEntries(
            Object.entries(stateBasedArgs).filter(([key, value]) => value !== undefined && value !== null)
          );
          classification.arguments = { ...classification.arguments, ...sanitizedStateArgs };
          
          // POST-SPREAD CLEANUP: Remove categories re-injected by stateBasedArgs when project_type is explicit
          if (classification.arguments._project_type_explicit && (classification.arguments.categories || classification.arguments.category)) {
            console.log(`[QueryEngine] uD83EuDDF9 POST-SPREAD CLEANUP: Removing re-injected categories (project_type is explicit)`);
            delete classification.arguments.categories;
            if (!classification.arguments._category_already_applied) delete classification.arguments.category;
          }
          classification.arguments = normalizeClassificationArguments(classification.arguments, userQuestion);
      console.log(`[QueryEngine] ğŸ” DEBUG PRE-EXECUTE: classification.arguments.category="${classification?.arguments?.category}", _category_already_applied=${classification?.arguments?._category_already_applied}`);
          classification.arguments = stripHallucinatedGeography(classification.arguments, userQuestion);
          console.log(`[QueryEngine] After state-based override merge + normalize:`, JSON.stringify(classification.arguments, null, 2));
        } else {
          // Fall back to legacy cumulative preservation
          console.log(`[QueryEngine] âš ï¸ No state-based args, using legacy cumulative preservation`);
          
          // CRITICAL FIX: For override, STILL preserve original specialized function
          // "healthcare only" should keep get_client_expansion_opportunities, just add category filter
          const wasOriginalSpecialized = originalContext && [
            'get_client_expansion_opportunities', 'get_high_risk_opportunities',
            'get_portfolio_diversity', 'get_client_concentration', 'get_stalled_deals',
            'get_client_lifetime_value', 'get_top_predicted_wins', 'get_seasonal_analysis',
            'compare_companies', 'compare_categories', 'compare_projects'
          ].includes(originalContext.function_name);
          const isNewAggregation = AGGREGATION_FUNCTIONS.includes(classification.function_name);
          
          if (wasOriginalSpecialized && !isNewAggregation) {
            console.log(`[QueryEngine] ğŸ”„ OVERRIDE + SPECIALIZED: Keeping original function: ${originalContext.function_name}`);
            console.log(`[QueryEngine]   New (discarded): ${classification.function_name}`);
            classification.function_name = originalContext.function_name;
          }
          
          // CRITICAL FIX: Preserve CUMULATIVE parameters even during override
          const cumulativeParams = [
            'min_fee', 'max_fee', 'min_win', 'max_win',
            'start_date', 'end_date', 'year', 'quarter', 'years',
            'status', 'state_name', 'time_reference', 'project_name',
            'state_code', 'states',
          ];
          
          const contexts = [previousContext, originalContext].filter(Boolean);
          
          for (const param of cumulativeParams) {
            if (classification.arguments[param] === undefined) {
              for (const ctx of contexts) {
                if (ctx?.arguments[param] !== undefined) {
                  classification.arguments[param] = ctx.arguments[param];
                  const source = ctx === previousContext ? 'PREVIOUS' : 'ORIGINAL';
                  console.log(`[QueryEngine]   ğŸ“Œ Preserved cumulative filter from ${source}: ${param}=${JSON.stringify(ctx.arguments[param])}`);
                  break;
                }
              }
            }
          }
          
          console.log(`[QueryEngine] After preserving cumulative filters:`, JSON.stringify(classification.arguments, null, 2));
          classification.arguments = normalizeClassificationArguments(classification.arguments, userQuestion);
      console.log(`[QueryEngine] ğŸ” DEBUG PRE-EXECUTE: classification.arguments.category="${classification?.arguments?.category}", _category_already_applied=${classification?.arguments?._category_already_applied}`);
          classification.arguments = stripHallucinatedGeography(classification.arguments, userQuestion);
          console.log(`[QueryEngine] After re-normalization:`, JSON.stringify(classification.arguments, null, 2));
        }
      } else if (newQueryResult.isNew) {
        console.log(`[QueryEngine] ğŸ†• NEW QUERY DETECTED: "${newQueryResult.reason}" - skipping context merge`);
        console.log(`[QueryEngine] Using ONLY new arguments:`, JSON.stringify(classification.arguments, null, 2));
        // Don't merge - treat as fresh query
      }

      // Step 1.7: Post-classification guard - prevent incorrect entity extraction in aggregation queries
      // CRITICAL: When user asks "which company/client" (aggregation), AI should NOT extract specific names
      // Only preserve entities when user explicitly mentions them (proper nouns, "vs", quotes)
      const isAggregationQuery = classification.function_name === 'compare_companies' || 
                                 classification.function_name === 'get_top_clients' ||
                                 classification.function_name === 'compare_clients' ||
                                 classification.function_name === 'get_company_breakdown';
      
      // SPECIAL: get_company_breakdown should never have a company filter
      // "Sort by company" means show ALL companies, not filter by one specific company
      if (classification.function_name === 'get_company_breakdown' && classification.arguments.company) {
        console.log(`[QueryEngine] ğŸš¨ AGGREGATION GUARD: Clearing company filter "${classification.arguments.company}" from get_company_breakdown`);
        console.log(`[QueryEngine]    Reason: get_company_breakdown shows ALL companies, not filters by one`);
        delete classification.arguments.company;
      }
      
      if (isAggregationQuery) {
        const questionLower = userQuestion.toLowerCase();
        
        // Detect aggregation patterns (broader than just keywords)
        // Matches: "which/what/who [entity] has/have most/best/highest/total"
        const aggregationPatterns = [
          /\b(which|what|who)\s+.{0,30}?\s+(has|have|had)\s+(the\s+)?(most|best|highest|total|largest|greatest)/i,
          /\b(top|rank|breakdown|all|aggregate|sum|total|count)\b/i,
          /\b(which|what|who)\s+.{0,30}?\s+(contributes?|performs?|leads?|works?)\s+(most|best)/i,
          /\bby\s+(company|client|companies|clients|opco|firm)\b/i,  // "revenue by company"
        ];
        
        const hasAggregationPattern = aggregationPatterns.some(pattern => pattern.test(userQuestion));
        
        // Detect explicit entity mentions: "vs", "versus", "compare X and Y", quoted names, proper nouns
        const hasExplicitComparison = /\b(vs\.?|versus|compare.{1,50}?(and|,))\b/i.test(userQuestion) && 
                                      (classification.arguments.clients?.length > 1 || 
                                       classification.arguments.companies?.length > 1);
        
        // If it's an aggregation query WITHOUT explicit comparisons, clear incorrectly extracted entities
        if (hasAggregationPattern && !hasExplicitComparison) {
          if (classification.arguments.clients && classification.arguments.clients.length === 1) {
            console.log(`[QueryEngine] ğŸš¨ AGGREGATION GUARD: Clearing incorrectly extracted client "${classification.arguments.clients[0]}"`);
            console.log(`[QueryEngine]    Reason: User asked aggregation question ("${userQuestion}") without naming specific clients`);
            delete classification.arguments.clients;
          }
          if (classification.arguments.companies && classification.arguments.companies.length === 1) {
            console.log(`[QueryEngine] ğŸš¨ AGGREGATION GUARD: Clearing incorrectly extracted company "${classification.arguments.companies[0]}"`);
            console.log(`[QueryEngine]    Reason: User asked aggregation question ("${userQuestion}") without naming specific companies`);
            delete classification.arguments.companies;
          }
        }
      }

      // Step 1.7b: FINAL SAFEGUARD - Extract department/division from question when missing
      // This handles ALL code paths where the template requires department/division but it wasn't extracted
      if (classification.function_name === 'get_projects_by_department' && !classification.arguments.department) {
        const deptMatch = userQuestion.match(/(?:related\s+to|in|of|for|from|under|assigned\s+to)\s+(?:the\s+)?([\w&\s:\-]+)\s+department/i) ||
                         userQuestion.match(/([\w&\s:\-]+)\s+department\s+projects?/i);
        if (deptMatch && deptMatch[1]) {
          classification.arguments.department = deptMatch[1].trim();
          console.log(`[QueryEngine] ğŸ¢ FINAL SAFEGUARD: Extracted department="${classification.arguments.department}" from question`);
        }
      }
      if (classification.function_name === 'get_projects_by_division' && !classification.arguments.division) {
        const divMatch = userQuestion.match(/(?:related\s+to|in|of|for|from|under|assigned\s+to)\s+(?:the\s+)?([\w\s\-:&]+)\s+division/i) ||
                        userQuestion.match(/([\w\s\-:&]+)\s+division\s+projects?/i);
        if (divMatch && divMatch[1]) {
          classification.arguments.division = divMatch[1].trim();
          console.log(`[QueryEngine] ğŸ¢ FINAL SAFEGUARD: Extracted division="${classification.arguments.division}" from question`);
        }
      }

      // Step 1.7c: Year normalization - fix OpenAI's outdated "current year" extraction
      // OpenAI may return 2023 when user asks for "current year" due to training data cutoff
      // Or it may not extract a year at all!
      const currentYear = new Date().getFullYear();
      const questionLowerForYear = userQuestion.toLowerCase();
      
      // Check if user asked for current/this year
      const askedForCurrentYear = /\b(current|this)\s+year\b/i.test(questionLowerForYear) ||
                                   /\b(this|the)\s+current\s+year\b/i.test(questionLowerForYear) ||
                                   /\byear\s+to\s+date\b/i.test(questionLowerForYear) ||
                                   /\bytd\b/i.test(questionLowerForYear);
      
      // Case 1: OpenAI extracted a wrong year
      if (askedForCurrentYear && classification.arguments.year && classification.arguments.year !== currentYear) {
        console.log(`[QueryEngine] ğŸ“… YEAR FIX: User asked for "current year" but OpenAI extracted ${classification.arguments.year}. Correcting to ${currentYear}`);
        classification.arguments.year = currentYear;
      }
      
      // Case 2: OpenAI failed to extract ANY year but user asked for current year
      // This can happen when the AI uses a wrong function or returns empty args
      if (askedForCurrentYear && !classification.arguments.year) {
        console.log(`[QueryEngine] ğŸ“… YEAR FIX: User asked for "current year" but no year extracted. Setting to ${currentYear}`);
        classification.arguments.year = currentYear;
        
        // Also route to get_projects_by_year if function is ai_fallback or wrong function
        if (classification.function_name === 'ai_fallback' || 
            classification.function_name === 'get_projects_by_combined_filters') {
          console.log(`[QueryEngine] ğŸ“… YEAR FIX: Rerouting from ${classification.function_name} to get_projects_by_year`);
          classification.function_name = 'get_projects_by_year';
        }
      }
      
      // Also fix year1/year2 for comparison queries
      if (askedForCurrentYear && classification.arguments.year2 && classification.arguments.year2 !== currentYear) {
        console.log(`[QueryEngine] ğŸ“… YEAR FIX: Correcting year2 from ${classification.arguments.year2} to ${currentYear}`);
        classification.arguments.year2 = currentYear;
      }
      
      // Case 3: Fix start_date/end_date when user says "this year" but LLM extracted wrong year
      // OpenAI may extract start_date="2023-01-01" end_date="2023-12-31" for "this year" due to training cutoff
      if (askedForCurrentYear) {
        const correctStartDate = `${currentYear}-01-01`;
        const correctEndDate = `${currentYear}-12-31`;
        
        // Check if start_date has wrong year
        if (classification.arguments.start_date && typeof classification.arguments.start_date === 'string') {
          const startYear = parseInt(classification.arguments.start_date.substring(0, 4), 10);
          if (startYear && startYear !== currentYear && startYear < currentYear) {
            console.log(`[QueryEngine] ğŸ“… DATE FIX: Correcting start_date from ${classification.arguments.start_date} to ${correctStartDate}`);
            classification.arguments.start_date = correctStartDate;
          }
        }
        
        // Check if end_date has wrong year
        if (classification.arguments.end_date && typeof classification.arguments.end_date === 'string') {
          const endYear = parseInt(classification.arguments.end_date.substring(0, 4), 10);
          if (endYear && endYear !== currentYear && endYear < currentYear) {
            console.log(`[QueryEngine] ğŸ“… DATE FIX: Correcting end_date from ${classification.arguments.end_date} to ${correctEndDate}`);
            classification.arguments.end_date = correctEndDate;
          }
        }
      }
      
      // Case 4: User asked for "last year" / "previous year" - calculate and set correct year AND dates
      const askedForLastYear = /\b(last|previous|prior)\s+year\b/i.test(questionLowerForYear);
      if (askedForLastYear) {
        const lastYear = currentYear - 1;
        console.log(`[QueryEngine] ğŸ“… YEAR FIX: User asked for "last year" - setting year to ${lastYear}`);
        classification.arguments.year = lastYear;
        
        // Also fix start_date/end_date if LLM extracted wrong year dates
        const correctStartDate = `${lastYear}-01-01`;
        const correctEndDate = `${lastYear}-12-31`;
        
        // Check if start_date has wrong year (not matching last year)
        if (classification.arguments.start_date && typeof classification.arguments.start_date === 'string') {
          const startYear = parseInt(classification.arguments.start_date.substring(0, 4), 10);
          if (startYear && startYear !== lastYear) {
            console.log(`[QueryEngine] ğŸ“… DATE FIX (last year): Correcting start_date from ${classification.arguments.start_date} to ${correctStartDate}`);
            classification.arguments.start_date = correctStartDate;
          }
        }
        
        // Check if end_date has wrong year
        if (classification.arguments.end_date && typeof classification.arguments.end_date === 'string') {
          const endYear = parseInt(classification.arguments.end_date.substring(0, 4), 10);
          if (endYear && endYear !== lastYear) {
            console.log(`[QueryEngine] ğŸ“… DATE FIX (last year): Correcting end_date from ${classification.arguments.end_date} to ${correctEndDate}`);
            classification.arguments.end_date = correctEndDate;
          }
        }
        
        // Remove conflicting time_reference that might have been merged
        if (classification.arguments.time_reference) {
          console.log(`[QueryEngine] ğŸ“… YEAR FIX: Removing conflicting time_reference: "${classification.arguments.time_reference}"`);
          delete classification.arguments.time_reference;
        }
        
        // Route to get_projects_by_year if needed
        if (classification.function_name === 'ai_fallback' || 
            classification.function_name === 'get_projects_by_combined_filters') {
          console.log(`[QueryEngine] ğŸ“… YEAR FIX: Rerouting from ${classification.function_name} to get_projects_by_year`);
          classification.function_name = 'get_projects_by_year';
        }
      }

      // Step 1.7d: QUARTER EXTRACTION - Extract quarter from patterns like "for quarter 4", "only Q4", "Q4 only"
      // This is especially useful for follow-up queries asking for specific quarter data
      if (!classification.arguments.quarter) {
        const quarterPatterns = [
          /\b(?:for|only|just|show)\s*(?:quarter|q)\s*(\d)\b/i,    // "for quarter 4", "only Q4", "just Q1"
          /\b(?:quarter|q)\s*(\d)\s*(?:only|data|revenue)\b/i,     // "quarter 4 only", "Q4 data", "Q4 revenue"
          /\bq(\d)\s+(?:of\s+)?\d{4}\b/i,                          // "Q4 2026" without year extraction
          /\bquarter\s*(\d)\s*(?:of\s+)?(?:\d{4})?\b/i,            // "quarter 4 2026", "quarter 4"
          /\bq(\d)\b/i,                                             // Plain "Q4" anywhere in the question
          /\b(?:first|1st)\s+quarter\b/i,                          // "first quarter"
          /\b(?:second|2nd)\s+quarter\b/i,                         // "second quarter"
          /\b(?:third|3rd)\s+quarter\b/i,                          // "third quarter"
          /\b(?:fourth|4th)\s+quarter\b/i,                         // "fourth quarter"
        ];
        
        for (const pattern of quarterPatterns) {
          const match = userQuestion.match(pattern);
          if (match) {
            let quarterNum: number | null = null;
            
            // Check for ordinal quarter words
            if (/first|1st/i.test(pattern.source)) quarterNum = 1;
            else if (/second|2nd/i.test(pattern.source)) quarterNum = 2;
            else if (/third|3rd/i.test(pattern.source)) quarterNum = 3;
            else if (/fourth|4th/i.test(pattern.source)) quarterNum = 4;
            else if (match[1]) quarterNum = parseInt(match[1], 10);
            
            if (quarterNum && quarterNum >= 1 && quarterNum <= 4) {
              classification.arguments.quarter = quarterNum;
              console.log(`[QueryEngine] ğŸ“… QUARTER EXTRACT: Detected quarter ${quarterNum} from pattern: "${match[0]}"`);
              break;
            }
          }
        }
      }

      // Step 1.7d-2: REVENUE + QUARTER ROUTING GUARD
      // If user asks for revenue/fee with quarter and AI misclassified to ai_fallback, route to get_revenue_by_month
      const isRevenueQuery = /\b(revenue|fee|total\s+fee|total\s+revenue)\b/i.test(userQuestion);
      const hasQuarter = classification.arguments.quarter !== undefined;
      
      if (isRevenueQuery && hasQuarter && classification.function_name === 'ai_fallback') {
        console.log(`[QueryEngine] ğŸ“Š REVENUE+QUARTER GUARD: Rerouting ai_fallback â†’ get_revenue_by_month`);
        classification.function_name = 'get_revenue_by_month';
        
        // Also extract year from the question if not already set
        if (!classification.arguments.year) {
          const yearMatch = userQuestion.match(/\b(20\d{2})\b/);
          if (yearMatch) {
            classification.arguments.year = parseInt(yearMatch[1], 10);
            console.log(`[QueryEngine] ğŸ“Š REVENUE+QUARTER GUARD: Extracted year=${classification.arguments.year}`);
          } else {
            // Default to current year if no year specified
            classification.arguments.year = new Date().getFullYear();
            console.log(`[QueryEngine] ğŸ“Š REVENUE+QUARTER GUARD: Defaulting to current year=${classification.arguments.year}`);
          }
        }
        
        // Clear date range filters since we're using year + quarter
        delete classification.arguments.start_date;
        delete classification.arguments.end_date;
        delete classification.arguments.project_type; // Remove misextracted project_type
      }

      // Step 1.7d-3: MONTHLY BREAKDOWN ROUTING GUARD
      // If user asks "which month", "by month", "monthly breakdown" and it's misclassified to ai_fallback
      // route to get_revenue_by_month with preserved filters
      const isMonthlyQuery = /\b(which\s+month|by\s+month|monthly|each\s+month|per\s+month|month\s+by\s+month)\b/i.test(userQuestion);
      
      if (isMonthlyQuery && classification.function_name === 'ai_fallback') {
        console.log(`[QueryEngine] ğŸ“… MONTHLY BREAKDOWN GUARD: Rerouting ai_fallback â†’ get_revenue_by_month`);
        classification.function_name = 'get_revenue_by_month';
        
        // Extract year or default to current year
        if (!classification.arguments.year) {
          const yearMatch = userQuestion.match(/\b(20\d{2})\b/);
          if (yearMatch) {
            classification.arguments.year = parseInt(yearMatch[1], 10);
          } else {
            classification.arguments.year = new Date().getFullYear();
          }
          console.log(`[QueryEngine] ğŸ“… MONTHLY BREAKDOWN GUARD: Using year=${classification.arguments.year}`);
        }
        
        // Clear conflicting date range if year is set
        if (classification.arguments.year) {
          delete classification.arguments.start_date;
          delete classification.arguments.end_date;
        }
      }

      // Step 1.7d-4: AVERAGE REVENUE/FEE ROUTING GUARD
      // If user asks "average revenue", "average fee", "avg fee per project" with a sector/category filter
      // and AI misclassified to ai_fallback or ai_data_analysis, route to compare_categories (which includes avg_project_value)
      // Pattern matches: "average revenue", "average fee", "avg fee", "average revenue per project", "avg project fee"
      const isAverageQuery = /\b(average|avg|mean)\s+(revenue|fee|project\s+(fee|value|size)|revenue\s+per\s+project|fee\s+per\s+project)\b/i.test(userQuestion);
      const hasSectorOrCategory = classification.arguments.category || 
                                   classification.arguments.categories ||
                                   classification.arguments.project_type ||
                                   /\b(sector|category|industry)\b/i.test(userQuestion);
      
      if (isAverageQuery && hasSectorOrCategory) {
        console.log(`[QueryEngine] ğŸ“Š AVERAGE GUARD CHECK: isAverageQuery=${isAverageQuery}, hasSectorOrCategory=${hasSectorOrCategory}, function_name=${classification.function_name}`);
      }
      
      if (isAverageQuery && hasSectorOrCategory && (classification.function_name === 'ai_fallback' || classification.function_name === 'ai_data_analysis')) {
        // Determine if it's a specific category or a breakdown
        const sectorMatch = userQuestion.match(/\b(?:in\s+(?:the\s+)?)?(\w+)\s+(?:sector|category|industry)\b/i);
        
        // First, collect all possible category values
        let categoryValue: string | null = null;
        
        // Priority 1: Extract from sector/category pattern in question
        if (sectorMatch && sectorMatch[1]) {
          const extracted = sectorMatch[1].trim();
          if (extracted && !/^(the|a|an)$/i.test(extracted)) {
            categoryValue = extracted;
            console.log(`[QueryEngine] ğŸ“Š AVERAGE+SECTOR GUARD: Extracted sector "${categoryValue}" from pattern`);
          }
        }
        
        // Priority 2: Use project_type if no extraction from text
        if (!categoryValue && classification.arguments.project_type) {
          categoryValue = classification.arguments.project_type;
          console.log(`[QueryEngine] ğŸ“Š AVERAGE+SECTOR GUARD: Using project_type "${categoryValue}"`);
        }
        
        // Priority 3: Use category if set
        if (!categoryValue && classification.arguments.category) {
          categoryValue = classification.arguments.category;
          console.log(`[QueryEngine] ğŸ“Š AVERAGE+SECTOR GUARD: Using category "${categoryValue}"`);
        }
        
        if (categoryValue) {
          console.log(`[QueryEngine] ğŸ“Š AVERAGE+SECTOR GUARD: Rerouting ai_fallback â†’ compare_categories with categories=["${categoryValue}"]`);
          classification.function_name = 'compare_categories';
          classification.arguments.categories = [categoryValue];
          classification.arguments._average_guard_applied = true;
          // CRITICAL: Set flags to prevent buildAdditionalFilters from converting categoriesâ†’project_type
          classification.arguments._explicit_category = true;
          classification.arguments._category_already_applied = true;
          
          // Clean up to avoid conflicts
          delete classification.arguments.project_type;
          if (!classification.arguments._category_already_applied) delete classification.arguments.category;
        } else {
          // Generic average fee query - use project type breakdown
          console.log(`[QueryEngine] ğŸ“Š AVERAGE GUARD: Rerouting ai_fallback â†’ get_project_type_breakdown`);
          classification.function_name = 'get_project_type_breakdown';
        }
      }

      // Step 1.7d-5: STATE QUERY ROUTING GUARD
      // If user asks for "projects in [state]" and AI misclassified to ai_fallback,
      // but we have state_code or states in arguments, route to get_projects_by_state
      const hasStateFilter = classification.arguments.state_code || 
                             (classification.arguments.states && classification.arguments.states.length > 0);
      const isStateQuery = /\b(?:projects?|opportunities?|deals?)\s+(?:in|from|for)\s+/i.test(userQuestion) ||
                           /\bin\s+(texas|california|new york|florida|illinois|ohio|georgia|pennsylvania|michigan|north carolina|washington|arizona|massachusetts|colorado|virginia|tennessee|maryland|minnesota|wisconsin|missouri|indiana|new jersey|oregon|nevada|connecticut|utah|iowa|arkansas|oklahoma|kentucky|louisiana|alabama|south carolina|kansas|new mexico|nebraska|mississippi|west virginia|idaho|hawaii|maine|new hampshire|rhode island|montana|delaware|south dakota|north dakota|alaska|vermont|wyoming)\b/i.test(userQuestion);
      
      if (hasStateFilter && classification.function_name === 'ai_fallback' && isStateQuery) {
        console.log(`[QueryEngine] ğŸ—ºï¸ STATE QUERY GUARD: Rerouting ai_fallback â†’ get_projects_by_state (state_code=${classification.arguments.state_code})`);
        classification.function_name = 'get_projects_by_state';
      }

      // Step 1.7d-6: REGION QUERY ROUTING GUARD
      // If user asks for "projects in [region]" and AI misclassified to ai_fallback,
      // but we have regions array in arguments, route to get_largest_projects
      const hasRegionsFilter = classification.arguments.regions && 
                               Array.isArray(classification.arguments.regions) && 
                               classification.arguments.regions.length > 0;
      const isRegionQuery = /\b(?:west|midwest|south|north|east|pacific|mountain|southeast|southwest|northeast|northwest)\s*(?:region|coast)?\b/i.test(userQuestion);
      console.log(`[QueryEngine] ğŸ” REGION GUARD DEBUG: hasRegionsFilter=${hasRegionsFilter}, isRegionQuery=${isRegionQuery}, function_name=${classification.function_name}, regions=${JSON.stringify(classification.arguments.regions)}`);
      
      if (hasRegionsFilter && classification.function_name === 'ai_fallback' && isRegionQuery) {
        console.log(`[QueryEngine] ğŸ—ºï¸ REGION QUERY GUARD: Rerouting ai_fallback â†’ get_largest_projects (regions=${classification.arguments.regions.join(', ')})`);
        classification.function_name = 'get_largest_projects';
      }

      // ORGANIZATION QUERY GUARD: Catch patterns like "show projects for Google", "list microsoft projects"
      // When AI misclassifies to ai_fallback, extract company name and route to get_projects_by_combined_filters
      console.log(`[QueryEngine] ğŸ” ORG GUARD DEBUG: function_name=${classification.function_name}, userQuestion="${userQuestion.substring(0, 50)}"`);
      const orgPatternMatch = userQuestion.match(/(?:show|list|find|get|display|what|which)\s+(?:all\s+)?(?:projects?|opportunities?|deals?|work)?\s*(?:for|with|from|by|of|at|related\s+to|belonging\s+to|associated\s+with)?\s*([A-Z][a-zA-Z0-9\-\_\&\s]{1,30}?)(?:\s+(?:projects?|client|company|organization|work|opportunities?|deals?))?$/i);
      const simpleOrgMatch = userQuestion.match(/^([A-Z][a-zA-Z0-9\-\_\&\s]{1,25})\s+(?:projects?|client|opportunities?|deals?)$/i);
      
      if (classification.function_name === 'ai_fallback' && (orgPatternMatch || simpleOrgMatch)) {
        const extractedOrg = (orgPatternMatch ? orgPatternMatch[1] : simpleOrgMatch ? simpleOrgMatch[1] : '').trim();
        // Filter out common non-organization words
        const excludeWords = ['all', 'the', 'my', 'our', 'your', 'their', 'some', 'any', 'recent', 'latest', 'new', 'old', 'current', 'previous', 'last', 'first', 'top', 'best', 'largest', 'smallest', 'submitted', 'won', 'lost', 'pending'];
        if (extractedOrg && extractedOrg.length >= 2 && !excludeWords.includes(extractedOrg.toLowerCase())) {
          console.log(`[QueryEngine] ğŸ¢ ORGANIZATION QUERY GUARD: Rerouting ai_fallback â†’ get_projects_by_combined_filters (organization="${extractedOrg}")`);
          classification.function_name = 'get_projects_by_combined_filters';
          classification.arguments.organization = extractedOrg;
        }
      }

      // TITLE QUERY GUARD: Detect explicit title searches and ensure title filter is applied
      // Patterns: "projects of title X", "under title X", "titled X", "title X", "project name X"
      // Reroute to get_projects_by_combined_filters if title not already extracted
      const titlePatterns = [
        /(?:projects?\s+)?(?:of|under|with|for)\s+title\s+[""\'']?(.+?)[""\'']?\s*$/i,
        /(?:projects?\s+)?titled\s+[""\'']?(.+?)[""\'']?\s*$/i,
        /title\s+(?:is\s+)?[""\'']?(.+?)[""\'']?\s*$/i,
        /(?:find|show|get|list|provide|display)\s+(?:the\s+)?(?:projects?\s+)?(?:named|called|titled)\s+[""\'']?(.+?)[""\'']?\s*$/i,
        /project\s+(?:name|title)\s+[""\'']?(.+?)[""\'']?\s*$/i,
        /[""\'']([^""\'']+ )[""\'']\s+project/i,
      ];
      
      const hasExplicitTitleMention = /\btitle\b|\btitled\b|\bnamed\b|\bcalled\b/i.test(userQuestion);
      const noTitleExtracted = !classification.arguments.title;
      
      // Also detect "provide/show/list projects [SPECIFIC PROJECT NAME]" pattern
      // If the text after "projects" is long and specific (4+ words), it's likely a project name
      const projectNameMatch = userQuestion.match(/(?:provide|show|list|get|find|display)\s+(?:the\s+)?projects?\s+(.{20,})/i);
      const hasLongProjectName = projectNameMatch && projectNameMatch[1] && 
        !projectNameMatch[1].match(/^(?:from|in|for|by|with|under|of|where|that|which|starting|ending|before|after|since|during|last|next|this|all|any|every|most|top|bottom)\b/i);
      
      console.log(`[QueryEngine] ğŸ” TITLE GUARD DEBUG: hasExplicitTitleMention=${hasExplicitTitleMention}, hasLongProjectName=${hasLongProjectName}, noTitleExtracted=${noTitleExtracted}, projectNameMatch=${projectNameMatch ? projectNameMatch[1] : 'none'}`);
      if ((hasExplicitTitleMention || hasLongProjectName) && noTitleExtracted) {
        // If it's a long project name pattern, use that directly
        if (hasLongProjectName && !hasExplicitTitleMention) {
          const specificProjectName = projectNameMatch[1].trim();
          console.log(`[QueryEngine] ğŸ·ï¸ TITLE QUERY GUARD: Detected specific project name pattern: "${specificProjectName}"`);
          
          // Ask user which column to search
          const allMatches = await this.detectAllMatchingColumns(specificProjectName, externalDbQuery);
          console.log(`[QueryEngine] ğŸ“Š Column matches for "${specificProjectName}":`, JSON.stringify(allMatches));
          
          // AUTO-EXECUTE: If exactly 1 column matches, execute directly
          if (allMatches.length === 1) {
            const singleMatch = allMatches[0];
            console.log(`[QueryEngine] âœ… TITLE AUTO-EXECUTE: Only 1 column matches ("${singleMatch.displayName}"), executing directly`);
            
            const filterValue = singleMatch.column === 'Title' ? specificProjectName : `%${specificProjectName}%`;
            const regexExtractedParams2 = this.extractQueryContext(userQuestion);
            const autoArgs: Record<string, any> = {
              [singleMatch.paramName]: filterValue,
              _auto_disambiguated: true,
              _disambiguation_column: singleMatch.displayName,
              // Merge extracted parameters (min_fee, max_fee, status, etc.)
              ...(regexExtractedParams2.min_fee && { min_fee: regexExtractedParams2.min_fee }),
              ...(regexExtractedParams2.max_fee && { max_fee: regexExtractedParams2.max_fee }),
              ...(regexExtractedParams2.status && { status: regexExtractedParams2.status }),
              ...(regexExtractedParams2.start_date && { start_date: regexExtractedParams2.start_date }),
              ...(regexExtractedParams2.end_date && { end_date: regexExtractedParams2.end_date }),
            };
            
            const normalizedArgs = normalizeClassificationArguments(autoArgs, userQuestion);
            const autoResults = await this.executeQuery(singleMatch.functionName, normalizedArgs, externalDbQuery, userQuestion);
            
            if (autoResults.success && autoResults.data && autoResults.data.length > 0) {
              const chartConfig = this.generateChartConfig(autoResults.data, singleMatch.functionName);
              const summary = this.calculateSummaryStats(autoResults.data);
              
              return {
                success: true,
                question: userQuestion,
                function_name: singleMatch.functionName,
                arguments: normalizedArgs,
                data: autoResults.data,
                row_count: autoResults.data.length,
                summary,
                chart_config: chartConfig,
                message: `Found ${autoResults.data.length} results`,
                sql_query: autoResults.sql_query,
                sql_params: autoResults.sql_params
              };
            }
          }
          
          // Multiple columns - show disambiguation
          if (allMatches.length > 1) {
            return {
              success: true,
              question: userQuestion,
              function_name: 'disambiguation_required',
              arguments: { title: specificProjectName },
              data: [{
                type: 'disambiguation',
                entity: specificProjectName,
                columns: allMatches,
                message: `I found "${specificProjectName}" in multiple places. Which column would you like to search?`
              }],
              row_count: 0,
              summary: {},
              chart_config: null,
              message: 'disambiguation_required'
            };
          }
        }
        let extractedTitle: string | null = null;
        
        for (const pattern of titlePatterns) {
          const match = userQuestion.match(pattern);
          if (match && match[1]) {
            extractedTitle = match[1].trim();
            break;
          }
        }
        
        // If no pattern matched, try to extract everything after "title" keyword
        if (!extractedTitle) {
          const fallbackMatch = userQuestion.match(/(?:title|titled|named|called)\s+(.+)/i);
          if (fallbackMatch && fallbackMatch[1]) {
            extractedTitle = fallbackMatch[1].trim()
              .replace(/^\s*[""\'']+ |[""\'']+\s*$/g, '')  // Remove quotes
              .replace(/\s+project[s]?\s*$/i, '')       // Remove trailing "projects"
              .trim();
          }
        }
        
        if (extractedTitle && extractedTitle.length >= 3) {
          console.log(`[QueryEngine] ğŸ·ï¸ TITLE QUERY GUARD: Detected title search, extracted title="${extractedTitle}"`);
          
          // Reroute to get_projects_by_combined_filters if not already using it
          if (classification.function_name !== 'get_projects_by_combined_filters' &&
              classification.function_name !== 'get_project_by_id') {
            console.log(`[QueryEngine] ğŸ·ï¸ TITLE QUERY GUARD: Rerouting ${classification.function_name} â†’ get_projects_by_combined_filters`);
            classification.function_name = 'get_projects_by_combined_filters';
          }
          
          // Set the title argument
          classification.arguments.title = extractedTitle;
          console.log(`[QueryEngine] ğŸ·ï¸ TITLE QUERY GUARD: Set args.title="${extractedTitle}"`);
        }
      }

      // This prevents the CATEGORY+FILTER GUARD from incorrectly routing to get_projects_by_category
      const PROJECT_TYPE_KEYWORDS: Record<string, string> = {
        'government': 'Government', 'governmental': 'Government', 'gov': 'Government', 'govt': 'Government',
        'civic': 'Civic', 'city hall': 'Civic', 'courthouse': 'Civic',
        'airport': 'Airports', 'airports': 'Airports', 'aviation': 'Airports',
        'hospital': 'Hospitals', 'hospitals': 'Hospitals',
        'bridge': 'Bridges', 'bridges': 'Bridges',
    'road': 'Road/Highway', 'roads': 'Road/Highway', 'highway': 'Road/Highway', 'highways': 'Road/Highway', 'road/highway': 'Road/Highway', 'transportation': 'Transportation',
        'transit': 'Transit', 'rail': 'Transit',
        'higher education': 'Higher Education', 'university': 'Higher Education',
        'k-12': 'K-12', 'school': 'K-12', 'schools': 'K-12',
        'corrections': 'Corrections', 'prison': 'Corrections',
        'energy': 'Energy', 'solar': 'Energy: Renewable',
        'industrial': 'Industrial', 'warehouse': 'Industrial',
        'waterfront': 'Waterfront', 'port': 'Waterfront',
        'multi-family': 'Multi-Family', 'multifamily': 'Multi-Family',
        'mixed use': 'Mixed Use', 'mixed-use': 'Mixed Use',
        'office': 'Office', 'parking': 'Parking', 'retail': 'Retail',
        'sports': 'Sports', 'stadium': 'Sports',
        'water': 'Water/Wastewater', 'wastewater': 'Water/Wastewater',
      };
      
      console.log(`[QueryEngine] ğŸ” PROJECT TYPE GUARD CHECK: categories=${JSON.stringify(classification.arguments.categories)}, project_type=${classification.arguments.project_type}`);
      if (classification.arguments.categories && classification.arguments.categories.length > 0 && !classification.arguments.project_type) {
        const catValue = classification.arguments.categories[0];
        const catLower = String(catValue).toLowerCase();
        const projectTypeValue = PROJECT_TYPE_KEYWORDS[catLower];
        
        if (projectTypeValue) {
          console.log(`[QueryEngine] ğŸ”§ PROJECT TYPE GUARD: Converting category "${catValue}" â†’ project_type="${projectTypeValue}"`);
          classification.arguments.project_type = projectTypeValue;
          classification.arguments._guard_converted_to_project_type = true;
          delete classification.arguments.categories;
          if (!classification.arguments._category_already_applied) delete classification.arguments.category;
          delete classification.arguments._explicit_category;
        }
      }
      // FINAL CLEANUP: Delete categories when both categories and project_type are set with same value
      if (classification.arguments.project_type && classification.arguments.categories && classification.arguments.categories.length > 0) {
        const catVal = String(classification.arguments.categories[0]).toLowerCase();
        const ptVal = String(classification.arguments.project_type).toLowerCase();
        if (catVal === ptVal || catVal.includes(ptVal) || ptVal.includes(catVal)) {
          console.log(`[QueryEngine] uD83EuDDF9 FINAL CLEANUP: Removing duplicate categories="${classification.arguments.categories[0]}" (same as project_type="${classification.arguments.project_type}")`);
          delete classification.arguments.categories;
          if (!classification.arguments._category_already_applied) delete classification.arguments.category;
          delete classification.arguments._explicit_category;
          classification.arguments._project_type_explicit = true;
        }
      }

      console.log(`[GUARD DEBUG] Before guards: function_name=${classification.function_name}, project_type=${classification.arguments.project_type}, categories=${JSON.stringify(classification.arguments.categories)}, division=${classification.arguments.division}`);

      // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
      // SECTOR EXTRACTION FALLBACK: Extract category from question text when AI returns ai_fallback
      // This handles cases like "building projects" where AI didn't extract the category
      // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
      if (classification.function_name === "ai_fallback" && !classification.arguments.categories) {
        console.log(`[SECTOR FALLBACK] Checking: function="${classification.function_name}", categories=${JSON.stringify(classification.arguments.categories)}, question="${userQuestion}"`);
        const sectorTermMap: Record<string, string> = {
          'education': 'Education', 'healthcare': 'Healthcare', 'transportation': 'Transportation',
          'aviation': 'Aviation', 'commercial': 'Commercial', 'corporate': 'Corporate',
          'civic': 'Civic', 'entertainment': 'Entertainment', 'energy': 'Energy',
          'corrections': 'Corrections', 'cultural': 'Cultural', 'industrial': 'Industrial',
          'mixed use': 'Mixed Use', 'multifamily': 'Multifamily', 'residential': 'Residential',
          'sports': 'Sports', 'waterfront': 'Waterfront', 'hospitality': 'Hospitality',
          'water': 'Water', 'building': 'Buildings', 'buildings': 'Buildings',
          'mission critical': 'Mission Critical', 'disaster': 'Disaster Recovery',
          'humanitarian': 'Humanitarian', 'other': 'Other'
        };
        const sectorPattern = /\b(education|healthcare|transportation|aviation|commercial|corporate|civic|entertainment|energy|corrections|cultural|industrial|mixed\s*use|multifamily|residential|sports|waterfront|hospitality|water|building|buildings|mission\s*critical|disaster|humanitarian|other)\s+(?:sector\s+)?projects?/i;
        const sectorMatch = userQuestion.match(sectorPattern);
        if (sectorMatch) {
          const extractedTerm = sectorMatch[1].toLowerCase().replace(/\s+/g, ' ');
          const categoryValue = sectorTermMap[extractedTerm] || extractedTerm.charAt(0).toUpperCase() + extractedTerm.slice(1);
          console.log(`[QueryEngine] ğŸ“ SECTOR EXTRACTION FALLBACK: Extracted category="${categoryValue}" from ai_fallback`);
          classification.arguments.categories = [categoryValue];
          classification.arguments.category = categoryValue;
        }
      }

      const hasCategoryFilter = classification.arguments.categories && classification.arguments.categories.length > 0;
      const hasDivisionFilter = classification.arguments.division || 
                                (classification.arguments.divisions && classification.arguments.divisions.length > 0);
      
      if (classification.function_name === 'ai_fallback' && hasCategoryFilter) {
        console.log(`[QueryEngine] ğŸ“ CATEGORY+FILTER GUARD: Rerouting ai_fallback â†’ get_projects_by_category`);
        console.log(`[QueryEngine]    categories=${JSON.stringify(classification.arguments.categories)}, division=${classification.arguments.division}`);
        classification.function_name = 'get_projects_by_category';
        classification.arguments._explicit_category = true;
        classification.arguments._category_already_applied = true;
      }
      // Also route ai_fallback with just division to get_projects_by_division
      else if (classification.function_name === 'ai_fallback' && classification.arguments.project_type && hasDivisionFilter) {
        // PROJECT_TYPE + DIVISION: Route to combined_filters which supports both
        console.log(`[QueryEngine] ğŸ›ï¸ PROJECT_TYPE+DIVISION GUARD: Rerouting ai_fallback â†’ get_projects_by_combined_filters`);
        console.log(`[QueryEngine]    project_type=${classification.arguments.project_type}, division=${classification.arguments.division}`);
        classification.function_name = 'get_projects_by_combined_filters';
      } else if (classification.function_name === 'ai_fallback' && hasDivisionFilter && !hasCategoryFilter) {
        classification.function_name = 'get_projects_by_division';
      } else if (classification.function_name === 'ai_fallback' && classification.arguments.project_type && !hasDivisionFilter) {
        // PROJECT_TYPE ONLY: Route to get_projects_by_project_type
        console.log(`[QueryEngine] ğŸ—ï¸ PROJECT_TYPE GUARD: Rerouting ai_fallback â†’ get_projects_by_project_type`);
        console.log(`[QueryEngine]    project_type=${classification.arguments.project_type}`);
        classification.function_name = 'get_projects_by_project_type';
      }

      // Step 1.7e: BREAKDOWN OVERRIDE - If query contains "by division" or "by department" anywhere,
      // force breakdown function. This catches all variations like "show by division", "by the division doing the work", etc.
      // Only override if current function is NOT already a breakdown/aggregation function
      const questionLowerForBreakdown = userQuestion.toLowerCase();
      const breakdownFunctions = [
        'get_division_breakdown', 'get_department_breakdown', 
        'get_revenue_by_division', 'get_revenue_by_department',
        'compare_divisions', 'compare_departments',
        'get_division_fee_trend', 'get_department_fee_trend'
      ];
      const isAlreadyBreakdownFunction = breakdownFunctions.includes(classification.function_name);
      
      // Simple keyword check: "by division" or "by department" anywhere in query
      const hasByDivision = /\bby\s+(?:the\s+)?division\b/i.test(questionLowerForBreakdown);
      const hasByDepartment = /\bby\s+(?:the\s+)?department\b/i.test(questionLowerForBreakdown);
      
      if (hasByDivision && !isAlreadyBreakdownFunction) {
        console.log(`[QueryEngine] ğŸ¢ BREAKDOWN OVERRIDE: Query contains "by division" - switching from ${classification.function_name} to get_division_breakdown`);
        console.log(`[QueryEngine]    Preserving filters: ${JSON.stringify(classification.arguments)}`);
        classification.function_name = 'get_division_breakdown';
      } else if (hasByDepartment && !isAlreadyBreakdownFunction) {
        console.log(`[QueryEngine] ğŸ¢ BREAKDOWN OVERRIDE: Query contains "by department" - switching from ${classification.function_name} to get_department_breakdown`);
        console.log(`[QueryEngine]    Preserving filters: ${JSON.stringify(classification.arguments)}`);
        classification.function_name = 'get_department_breakdown';
      }

      // Step 1.8: Status extraction helper - ensure status is extracted from adjective patterns
      // CRITICAL: Patterns like "submitted projects", "won projects", "active projects" must extract status
      if (!classification.arguments.status) {
        const statusPatterns: Array<{pattern: RegExp, status: string | string[]}> = [
          // Allow optional words between status and "projects" like "submitted Healthcare projects"
          { pattern: /\b(submitted|submit)\s+(?:\w+\s+)*?(projects?|items?|records?)\b/i, status: 'Submitted' },
          { pattern: /\b(won|winning|successful|awarded)\s+(?:\w+\s+)*?(projects?|items?|records?)\b/i, status: 'Won' },
          { pattern: /\b(lost|losing|unsuccessful)\s+(?:\w+\s+)*?(projects?|items?|records?)\b/i, status: 'Lost' }, // Note: "Lost" may not exist in database
          { pattern: /\b(lead|leads)\s+(?:\w+\s+)*?(projects?|items?|records?)\b/i, status: 'Lead' },
          { pattern: /\b(active|in\s+progress|ongoing)\s+(?:\w+\s+)*?(projects?|items?|records?)\b/i, status: 'In Progress' },
          { pattern: /\b(proposal|developing)\s+(?:\w+\s+)*?(projects?|items?|records?)\b/i, status: 'Proposal Development' },
          { pattern: /\b(qualified|qualified\s+lead)\s+(?:\w+\s+)*?(projects?|items?|records?)\b/i, status: 'Qualified Lead' },
          // "closed" = both Won and Lost (deals no longer in pipeline)
          // Allow words between "closed" and "projects" like "closed Healthcare sector projects"
          { pattern: /\b(closed)\s+(?:\w+\s+)*?(projects?|items?|records?|deals?|opportunities?)\b/i, status: ['Lost', 'No Go', 'Cancelled'] },
          { pattern: /\b(open)\s+(?:\w+\s+)*?(projects?|items?|records?|deals?|opportunities?)\b/i, status: ['Proposal Development', 'Qualified Lead', 'Submitted', 'Won', 'Lead', 'In Progress', 'Hold'] },
          { pattern: /\bprojects?\s+(which are|that are|with)\s+(submitted|won|lost|lead|active)\b/i, status: 'auto-detect' }, // Will extract from group
        ];

        for (const {pattern, status} of statusPatterns) {
          const match = pattern.exec(userQuestion);
          if (match) {
            // Handle array status (e.g., "closed" = ["Won", "Lost"])
            if (Array.isArray(status)) {
              classification.arguments.status = status;
              console.log(`[QueryEngine] ğŸ“Š STATUS HELPER: Extracted status=${JSON.stringify(status)} (multiple) from pattern: "${match[0]}"`);
            } else {
              const extractedStatus = status === 'auto-detect' 
                ? match[2] // Use the captured status keyword
                : status;
              
              classification.arguments.status = this.normalizeStatus(extractedStatus);
              console.log(`[QueryEngine] ğŸ“Š STATUS HELPER: Extracted status="${classification.arguments.status}" from pattern: "${match[0]}"`);
            }
            break;
          }
        }
      }

      // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
      // Step 1.9: DIVISION STATE FIX - Fix AI incorrectly splitting division names with state codes
      // When user says "LFDH NY division", AI might extract division="LFDH" and state_code="New York"
      // We need to detect and fix this by combining them back into the full division name
      // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
      const stateCodeToAbbrev: Record<string, string> = {
        'new york': 'NY', 'california': 'CA', 'texas': 'TX', 'florida': 'FL',
        'illinois': 'IL', 'pennsylvania': 'PA', 'ohio': 'OH', 'georgia': 'GA',
        'north carolina': 'NC', 'michigan': 'MI', 'new jersey': 'NJ', 'virginia': 'VA',
        'washington': 'WA', 'arizona': 'AZ', 'massachusetts': 'MA', 'tennessee': 'TN',
        'indiana': 'IN', 'missouri': 'MO', 'maryland': 'MD', 'wisconsin': 'WI',
        'colorado': 'CO', 'minnesota': 'MN', 'south carolina': 'SC', 'alabama': 'AL',
        'louisiana': 'LA', 'kentucky': 'KY', 'oregon': 'OR', 'oklahoma': 'OK',
        'connecticut': 'CT', 'utah': 'UT', 'iowa': 'IA', 'nevada': 'NV',
        'arkansas': 'AR', 'mississippi': 'MS', 'kansas': 'KS', 'new mexico': 'NM',
        'nebraska': 'NE', 'west virginia': 'WV', 'idaho': 'ID', 'hawaii': 'HI',
        'new hampshire': 'NH', 'maine': 'ME', 'montana': 'MT', 'rhode island': 'RI',
        'delaware': 'DE', 'south dakota': 'SD', 'north dakota': 'ND', 'alaska': 'AK',
        'vermont': 'VT', 'wyoming': 'WY'
      };
      
      // Check if query mentions a division with a state abbreviation pattern
      // Patterns: "LFDH NY division", "assigned to LFDH NY", "under LFDH NY division"
      const divisionWithStatePattern = /\b(\w+)\s+(NY|CA|TX|FL|IL|PA|OH|GA|NC|MI|NJ|VA|WA|AZ|MA|TN|IN|MO|MD|WI|CO|MN|SC|AL|LA|KY|OR|OK|CT|UT|IA|NV|AR|MS|KS|NM|NE|WV|ID|HI|NH|ME|MT|RI|DE|SD|ND|AK|VT|WY)\s+division\b/i;
      const divisionMatch = userQuestion.match(divisionWithStatePattern);
      
      if (divisionMatch) {
        const baseDivision = divisionMatch[1]; // e.g., "LFDH"
        const stateAbbrev = divisionMatch[2].toUpperCase(); // e.g., "NY"
        const fullDivisionName = `${baseDivision} ${stateAbbrev}`; // e.g., "LFDH NY"
        
        // Check if AI incorrectly split this
        const aiDivision = classification.arguments.division || (classification.arguments.divisions && classification.arguments.divisions[0]);
        const aiStateCode = classification.arguments.state_code;
        const aiStates = classification.arguments.states;
        
        // Get the state name corresponding to the abbreviation
        const stateNameFromAbbrev = Object.entries(stateCodeToAbbrev).find(([name, abbr]) => abbr === stateAbbrev)?.[0];
        
        // If AI set state that matches the abbreviation in the division name, it's an error
        const stateMatchesAbbrev = (aiStateCode && aiStateCode.toLowerCase() === stateNameFromAbbrev) ||
                                   (aiStates && aiStates.some((s: string) => s.toLowerCase() === stateNameFromAbbrev));
        
        // Case 1: AI split "LFDH NY" into division="LFDH" + state="New York"
        if (stateMatchesAbbrev && aiDivision && aiDivision.toLowerCase() === baseDivision.toLowerCase()) {
          console.log(`[QueryEngine] ğŸ”§ DIVISION STATE FIX: AI incorrectly split "${fullDivisionName}" into division="${aiDivision}" + state="${aiStateCode || aiStates}"`);
          console.log(`[QueryEngine]    Fixing: division="${fullDivisionName}", removing state filter`);
          
          // Fix the division name
          classification.arguments.division = fullDivisionName;
          if (classification.arguments.divisions) {
            classification.arguments.divisions = [fullDivisionName];
          }
          
          // Remove the incorrectly added state filter
          delete classification.arguments.state_code;
          delete classification.arguments.states;
        }
        // Case 2: AI extracted just the state abbreviation as division (e.g., division="NY" when it should be "LFDH NY")
        else if (aiDivision && aiDivision.toUpperCase() === stateAbbrev) {
          console.log(`[QueryEngine] ğŸ”§ DIVISION STATE FIX: AI extracted only state abbrev as division="${aiDivision}" instead of "${fullDivisionName}"`);
          console.log(`[QueryEngine]    Fixing: division="${fullDivisionName}"`);
          
          classification.arguments.division = fullDivisionName;
          if (classification.arguments.divisions) {
            classification.arguments.divisions = [fullDivisionName];
          }
          
          // Remove any incorrectly added state filter
          delete classification.arguments.state_code;
          delete classification.arguments.states;
        }
        // Case 3: AI didn't extract division at all - add it from the pattern match
        else if (!aiDivision) {
          console.log(`[QueryEngine] ğŸ”§ DIVISION STATE FIX: AI missed division entirely, extracting "${fullDivisionName}" from query`);
          classification.arguments.division = fullDivisionName;
          classification.arguments.divisions = [fullDivisionName];
          
          // Remove any incorrectly added state filter from the abbreviation
          if (stateMatchesAbbrev) {
            delete classification.arguments.state_code;
            delete classification.arguments.states;
          }
        }
      }

      // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
      // SAFETY NET: Extract ALL filters the LLM might have missed
      // Scans the original query for common patterns and adds them to args
      // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
      
      // FEE SAFETY NET: Extract min_fee/max_fee if LLM missed them
      // IMPORTANT: Patterns require either $ sign OR million/m/b suffix to avoid matching win rate percentages
      if (!classification.arguments.min_fee) {
        const minFeePatterns = [
          // "fee above $50M", "budget greater than 100 million" - requires fee/budget keyword
          /\b(?:fees?|price|cost|revenue|value|budget)\s+(?:exceed(?:s|ing)?|greater\s+than|above|over|more\s+than|>=?|at\s+least)\s*\$?([\d,]+(?:\.\d+)?)\s*(million|m|k|thousand|b|billion)?/i,
          // "above $50M" - requires $ sign
          /\b(?:exceed(?:s|ing)?|greater\s+than|above|over|more\s+than|>=?|at\s+least)\s*\$([\d,]+(?:\.\d+)?)\s*(million|m|k|thousand|b|billion)?/i,
          // "above 100 million" - requires million/m/b/billion suffix
          /\b(?:exceed(?:s|ing)?|greater\s+than|above|over|more\s+than|>=?|at\s+least)\s*([\d,]+(?:\.\d+)?)\s*(million|m|billion|b)\s*(?:fee|price|cost)?/i,
        ];
        for (const pattern of minFeePatterns) {
          const match = userQuestion.match(pattern);
          if (match) {
            let value = parseFloat(match[1].replace(/,/g, ''));
            const suffix = (match[2] || '').toLowerCase();
            if (suffix === 'billion' || suffix === 'b') value *= 1000000000;
            else if (suffix === 'million' || suffix === 'm') value *= 1000000;
            else if (suffix === 'thousand' || suffix === 'k') value *= 1000;
            else if (value < 1000) value *= 1000000; // Assume millions for small numbers
            classification.arguments.min_fee = value;
            console.log(`[QueryEngine] ğŸ’° FEE SAFETY NET: Extracted min_fee=${value} from "${match[0]}"`);
            break;
          }
        }
      }
      
      if (!classification.arguments.max_fee) {
        const maxFeePatterns = [
          /\b(?:fees?|price|cost|revenue|value|budget)\s+(?:below|under|less\s+than|<|at\s+most)\s*\$?([\d,]+(?:\.\d+)?)\s*(million|m|k|thousand|b|billion)?/i,
          /\b(?:below|under|less\s+than|<|at\s+most)\s*\$?([\d,]+(?:\.\d+)?)\s*(million|m|k|thousand|b|billion)?\s*(?:fee|price|cost)?/i,
        ];
        for (const pattern of maxFeePatterns) {
          const match = userQuestion.match(pattern);
          if (match) {
            let value = parseFloat(match[1].replace(/,/g, ''));
            const suffix = (match[2] || '').toLowerCase();
            if (suffix === 'billion' || suffix === 'b') value *= 1000000000;
            else if (suffix === 'million' || suffix === 'm') value *= 1000000;
            else if (suffix === 'thousand' || suffix === 'k') value *= 1000;
            else if (value < 1000) value *= 1000000;
            classification.arguments.max_fee = value;
            console.log(`[QueryEngine] ğŸ’° FEE SAFETY NET: Extracted max_fee=${value} from "${match[0]}"`);
            break;
          }
        }
      }
      
      // WIN RATE SAFETY NET: Extract min_win/max_win if LLM missed them
      if (!classification.arguments.min_win) {
        const minWinPatterns = [
          /\b(?:win\s*%?|win\s+rate|success\s+rate)\s+(?:above|over|greater\s+than|more\s+than|>=?|at\s+least|exceeding)\s*(\d+)\s*%?/i,
          /\b(?:above|over|greater\s+than|more\s+than|>=?|at\s+least)\s*(\d+)\s*%?\s*(?:win\s*%?|win\s+rate|success\s+rate)/i,
        ];
        for (const pattern of minWinPatterns) {
          const match = userQuestion.match(pattern);
          if (match) {
            classification.arguments.min_win = parseInt(match[1], 10);
            console.log(`[QueryEngine] ğŸ“Š WIN SAFETY NET: Extracted min_win=${classification.arguments.min_win}% from "${match[0]}"`);
            break;
          }
        }
      }
      
      if (!classification.arguments.max_win) {
        const maxWinPatterns = [
          /\b(?:win\s*%?|win\s+rate|success\s+rate)\s+(?:below|under|less\s+than|<|at\s+most)\s*(\d+)\s*%?/i,
          /\b(?:below|under|less\s+than|<|at\s+most)\s*(\d+)\s*%?\s*(?:win\s*%?|win\s+rate|success\s+rate)/i,
        ];
        for (const pattern of maxWinPatterns) {
          const match = userQuestion.match(pattern);
          if (match) {
            classification.arguments.max_win = parseInt(match[1], 10);
            console.log(`[QueryEngine] ğŸ“Š WIN SAFETY NET: Extracted max_win=${classification.arguments.max_win}% from "${match[0]}"`);
            break;
          }
        }
      }
      
      // COMPANY SAFETY NET: Extract company if LLM missed it
      if (!classification.arguments.company) {
        const companyPatterns = [
          /\b(?:handled\s+by|associated\s+with|by|from|for)\s+(Company\s+[A-Za-z]+)\b/i,
          /\b(Company\s+[A-Za-z]+)\b/i,
        ];
        for (const pattern of companyPatterns) {
          const match = userQuestion.match(pattern);
          if (match && match[1]) {
            classification.arguments.company = match[1].trim();
            console.log(`[QueryEngine] ğŸ¢ COMPANY SAFETY NET: Extracted company="${classification.arguments.company}" from "${match[0]}"`);
            break;
          }
        }
      }

      // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
      // LLM VALIDATION: Verify extracted filters with LLM confirmation
      // If safety net added filters, confirm with LLM they are correct
      // SKIP for follow-ups with state-based args - those filters came from 
      // previous queries in the chain, not the current question
      // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
      const safetyNetFilters: string[] = [];
      if (classification.arguments.min_fee) safetyNetFilters.push(`min_fee=${classification.arguments.min_fee}`);
      if (classification.arguments.max_fee) safetyNetFilters.push(`max_fee=${classification.arguments.max_fee}`);
      if (classification.arguments.min_win) safetyNetFilters.push(`min_win=${classification.arguments.min_win}%`);
      if (classification.arguments.max_win) safetyNetFilters.push(`max_win=${classification.arguments.max_win}%`);
      
      // Only run validation if safety net added NEW filters that LLM didn't have
      // IMPORTANT: Skip validation for state-based follow-ups - the filters (min_fee, etc.) 
      // came from PREVIOUS queries in the chain, not the current question, so LLM would 
      // incorrectly "correct" them based on the current question alone
      if (safetyNetFilters.length > 0 && stateBasedArgs) {
        console.log(`[QueryEngine] â­ï¸ SKIPPING LLM VALIDATION: State-based follow-up (filters preserved from chain: ${safetyNetFilters.join(', ')})`);
      } else if (safetyNetFilters.length > 0 && !stateBasedArgs) {
        console.log(`[QueryEngine] ğŸ” LLM VALIDATION: Confirming filters: ${safetyNetFilters.join(', ')}`);
        
        try {
          const validationPrompt = `You are a filter validation assistant. Given this user query and extracted filters, confirm if they are correct.

User Query: "${userQuestion}"

Extracted Filters:
${JSON.stringify(classification.arguments, null, 2)}

Rules:
1. If min_fee is present, verify the number matches what the user asked (2M = 2000000, 5M = 5000000, etc.)
2. If min_win/max_win is present, verify the percentage matches
3. Return ONLY a JSON object with corrected values, or empty {} if all correct

Example responses:
- If filters are correct: {}
- If min_fee should be 5000000 not 2000000: {"min_fee": 5000000}
- If win rate should be 60 not 50: {"min_win": 60}

Response (JSON only):`;

          const validationResponse = await this.openaiClient.chat(
            [{ role: 'user', content: validationPrompt }],
            { model: 'gpt-5.1', max_completion_tokens: 200 }
          );

          const responseText = validationResponse?.trim() || '{}';
          
          // Extract JSON from response
          const jsonMatch = responseText.match(/\{[\s\S]*\}/);
          if (jsonMatch) {
            const corrections = JSON.parse(jsonMatch[0]);
            if (Object.keys(corrections).length > 0) {
              // IMPORTANT: Only apply corrections for filters that ALREADY exist
              // Don't let LLM add new filters that weren't in the original classification
              // CRITICAL: Never apply date/year corrections - LLM training data is outdated
              // We already handle "this year" â†’ current year in our code above
              const dateRelatedKeys = ['year', 'year1', 'year2', 'start_date', 'end_date'];
              const validCorrections: Record<string, any> = {};
              for (const [key, value] of Object.entries(corrections)) {
                // Skip date-related corrections - our code handles these correctly
                if (dateRelatedKeys.includes(key)) {
                  console.log(`[QueryEngine] âš ï¸ LLM VALIDATION: Ignoring date correction "${key}=${value}" - handled by date normalization`);
                  continue;
                }
                if (classification.arguments[key] !== undefined) {
                  validCorrections[key] = value;
                } else {
                  console.log(`[QueryEngine] âš ï¸ LLM VALIDATION: Ignoring new filter "${key}" - not in original classification`);
                }
              }
              
              if (Object.keys(validCorrections).length > 0) {
                console.log(`[QueryEngine] âœï¸ LLM VALIDATION: Applying corrections:`, validCorrections);
                Object.assign(classification.arguments, validCorrections);
              } else {
                console.log(`[QueryEngine] âœ… LLM VALIDATION: All filters confirmed correct`);
              }
            } else {
              console.log(`[QueryEngine] âœ… LLM VALIDATION: All filters confirmed correct`);
            }
          }
        } catch (validationError) {
          // If validation fails, continue with original filters
          console.log(`[QueryEngine] âš ï¸ LLM VALIDATION: Skipped due to error, using extracted filters`);
        }
      }

      // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
      // DISAMBIGUATION RESTORATION GUARD: If disambiguation was locked but heuristics
      // overwrote the function_name, restore it before preprocessing
      // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
      if (disambiguationLocked && disambiguationOverride) {
        if (classification.function_name !== disambiguationOverride.function) {
          console.log(`[QueryEngine] ğŸ”„ DISAMBIGUATION RESTORATION: function was "${classification.function_name}", restoring to "${disambiguationOverride.function}"`);
          classification.function_name = disambiguationOverride.function;
        }
        // Also restore any args that were deleted
        for (const [key, value] of Object.entries(disambiguationOverride.args)) {
          if (value !== undefined && !key.startsWith('_') && classification.arguments[key] !== value) {
            console.log(`[QueryEngine] ğŸ”„ DISAMBIGUATION RESTORATION: ${key} was "${classification.arguments[key]}", restoring to "${value}"`);
            classification.arguments[key] = value;
          }
          // Always ensure flags are preserved
          if (key.startsWith('_') && value === true) {
            classification.arguments[key] = true;
          }
        }
      }

      // DEBUG: Log state right before preprocessQuery
      console.log(`[QueryEngine] ğŸ” PRE-PREPROCESS: classification.arguments.company = "${classification.arguments?.company}", _company_already_applied = ${classification.arguments?._company_already_applied}`);
      
      // Step 2: Preprocess to handle ALL calculations (dates, numbers, limits)
      const processedClassification = await this.preprocessQuery(
        userQuestion,
        classification,
        externalDbQuery,
        previousContext,
        preAppliedFilters
      );

      let functionName = processedClassification.function_name;
      const args = processedClassification.arguments;
      
      // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
      // POST-PREPROCESS CATEGORY LOCK: Extract category from question text for ai_fallback
      // This runs AFTER all merges so the values persist to execution
      // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
      if (functionName === 'ai_fallback' && !args.categories && !args.category) {
        const sectorTerms: Record<string, string> = {
          'education': 'Education', 'healthcare': 'Healthcare', 'transportation': 'Transportation',
          'aviation': 'Aviation', 'commercial': 'Commercial', 'corporate': 'Corporate',
          'civic': 'Civic', 'entertainment': 'Entertainment', 'energy': 'Energy',
          'corrections': 'Corrections', 'cultural': 'Cultural', 'industrial': 'Industrial',
          'mixed use': 'Mixed Use', 'multifamily': 'Multifamily', 'residential': 'Residential',
          'sports': 'Sports', 'waterfront': 'Waterfront', 'hospitality': 'Hospitality',
          'water': 'Water', 'building': 'Buildings', 'buildings': 'Buildings',
          'mission critical': 'Mission Critical', 'disaster': 'Disaster Recovery',
          'humanitarian': 'Humanitarian', 'other': 'Other'
        };
        const sectorRx = /(education|healthcare|transportation|aviation|commercial|corporate|civic|entertainment|energy|corrections|cultural|industrial|mixed\s*use|multifamily|residential|sports|waterfront|hospitality|water|building|buildings|mission\s*critical|disaster|humanitarian|other)\s+(?:sector\s+)?projects?/i;
        const sectorMatch = userQuestion.match(sectorRx);
        if (sectorMatch) {
          const term = sectorMatch[1].toLowerCase().replace(/\s+/g, ' ');
          const catValue = sectorTerms[term] || term.charAt(0).toUpperCase() + term.slice(1);
          console.log(`[QueryEngine] ğŸ—ï¸ POST-PREPROCESS CATEGORY LOCK: Extracted category="${catValue}" from ai_fallback`);
          args.categories = [catValue];
          args.category = catValue;
          args._category_already_applied = true;
          functionName = 'get_projects_by_category';
        }
      } else if ((args.categories?.length || args.category) && !args._category_already_applied) {
        args.category = Array.isArray(args.categories) ? args.categories[0] : args.category;
        args.categories = Array.isArray(args.categories) ? args.categories : [args.category];
        args._category_already_applied = true;
        if (functionName === 'ai_fallback') {
          functionName = 'get_projects_by_category';
        }
        console.log(`[QueryEngine] ğŸ—ï¸ POST-PREPROCESS CATEGORY LOCK: functionName=${functionName}, category="${args.category}"`);
      }
      
      // DEBUG: Log args right after preprocessQuery
      console.log(`[QueryEngine] ğŸ” POST-PREPROCESS args: company="${args.company}", keyword="${args.keyword}", _company_already_applied=${args._company_already_applied}`);
      args._debug_post_preprocess = { company: args.company, keyword: args.keyword, category: args.category, _company_already_applied: args._company_already_applied };

      // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
      // HEAD CHEF: Unified entity resolution (replaces scattered logic)
      // Only run if no entity is already locked AND no disambiguation pre-applied
      // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
      const hasLockedEntity = args._client_already_applied || args._company_already_applied || args._poc_already_applied || args._title_already_applied;
      const hasPreAppliedDisambiguation = Object.keys(preAppliedFilters).some(k => !k.startsWith('_'));
      
      if (!hasLockedEntity && !hasPreAppliedDisambiguation && !args._head_chef_done) {
        console.log(`[QueryEngine] ğŸ§‘â€ğŸ³ Calling HEAD CHEF for unified entity resolution`);
        
        const headChefResult = await this.resolveEntityUnified(
          userQuestion,
          { ...args, _function_name: functionName },
          previousContext,
          externalDbQuery
        );
        
        console.log(`[QueryEngine] ğŸ§‘â€ğŸ³ HEAD CHEF result: entity=${headChefResult.entity?.column || 'none'}, locked=${headChefResult.locked}, disambiguation=${!!headChefResult.disambiguation}`);
        
        // If head chef needs disambiguation, return it
        if (headChefResult.disambiguation && headChefResult.disambiguation.length > 1) {
          const entityValue = args.company || args.client || args.poc || args.keyword;
          const queryRefNumber = `Q${Date.now().toString(36).toUpperCase()}${Math.random().toString(36).substring(2, 6).toUpperCase()}`;
          
          console.log(`[QueryEngine] ğŸ§‘â€ğŸ³ HEAD CHEF returning disambiguation options`);
          return {
            success: true,
            question: userQuestion,
            function_name: 'disambiguation_required',
            arguments: args,
            data: [{
              type: 'disambiguation',
              queryRefNumber,
              value: entityValue,
              options: headChefResult.disambiguation.map(m => ({
                column: m.column,
                displayName: m.displayName,
                count: m.count,
                  value: entityValue,
                paramName: (m as any).paramName,
                functionName: (m as any).functionName
              }))
            }],
            row_count: 0,
            message: 'disambiguation_required'
          };
        }
        
        // If head chef resolved the entity, apply it
        if (headChefResult.locked && headChefResult.entity) {
          console.log(`[QueryEngine] ğŸ§‘â€ğŸ³ HEAD CHEF locked entity: ${headChefResult.entity.column} = "${headChefResult.entity.value}"`);
          
          // Clear all entity params first
          delete args.company;
          delete args.client;
          delete args.poc;
          delete args.keyword;
          delete args.organization;
          
          // Use the args from HeadChef which already has the correct array/string format
          // Copy over ALL args from headChefResult.allArgs to preserve array formats for geographic columns
          for (const key of Object.keys(headChefResult.allArgs)) {
            if (!key.startsWith('_') || key.endsWith('_already_applied')) {
              args[key] = headChefResult.allArgs[key];
            }
          }
          // Ensure the flag is set
          args[`_${headChefResult.entity.paramName}_already_applied`] = true;
          functionName = headChefResult.functionName;
          
          // Apply status if resolved
          if (headChefResult.status && headChefResult.status.length > 0) {
            args.status = headChefResult.status;
          }
          
          // Mark head chef as done to skip scattered logic
          args._head_chef_done = true;
          args._smart_detection_done = true;
        }
      }
      
      // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
      // FILTER PRESERVATION: For follow-up queries, preserve status/dates from previous
      // This runs when head chef is SKIPPED (entity already locked)
      // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
      if (previousContext?.arguments && !args._head_chef_done) {
        const prev = previousContext.arguments;
        
        // OPEN STATUS EXPANSION: If question contains "open", expand to all open statuses
        const questionLower = userQuestion.toLowerCase();
        if (questionLower.includes('open') && (!args.status || (Array.isArray(args.status) && args.status.every(s => s === 'In Progress')))) {
          args.status = ['Proposal Development', 'Qualified Lead', 'Submitted', 'Won', 'Lead', 'In Progress', 'Hold'];
          console.log(`[QueryEngine] ğŸ”„ FILTER PRESERVATION: Expanded "open" to all open statuses`);
        }
        
        // Preserve status if current query doesn't override it
        if (prev.status && (!args.status || (Array.isArray(args.status) && args.status.length === 0))) {
          args.status = prev.status;
          console.log(`[QueryEngine] ğŸ”„ FILTER PRESERVATION: status = ${JSON.stringify(prev.status)}`);
        }
        
        // Preserve year/dates if current query doesn't override
        if (prev.year && !args.year && !args.start_date) {
          args.year = prev.year;
          console.log(`[QueryEngine] ğŸ”„ FILTER PRESERVATION: year = ${prev.year}`);
        }
        if (prev.start_date && !args.start_date) {
          args.start_date = prev.start_date;
          console.log(`[QueryEngine] ğŸ”„ FILTER PRESERVATION: start_date = ${prev.start_date}`);
        }
        if (prev.end_date && !args.end_date) {
          args.end_date = prev.end_date;
          console.log(`[QueryEngine] ğŸ”„ FILTER PRESERVATION: end_date = ${prev.end_date}`);
        }
        
        // Preserve category/categories for project type queries
        if (prev.category && !args.category) {
          args.category = prev.category;
          console.log(`[QueryEngine] ğŸ”„ FILTER PRESERVATION: category = ${prev.category}`);
        }
        if (prev.categories && (!args.categories || (Array.isArray(args.categories) && args.categories.length === 0))) {
          args.categories = prev.categories;
          console.log(`[QueryEngine] ğŸ”„ FILTER PRESERVATION: categories = ${JSON.stringify(prev.categories)}`);
        }
        
        // Preserve project_type for follow-up queries
        if (prev.project_type && !args.project_type) {
          args.project_type = prev.project_type;
          args._project_type_already_applied = true;
          console.log(`[QueryEngine] ğŸ”„ FILTER PRESERVATION: project_type = ${prev.project_type}`);
        }
        if (prev._project_type_already_applied && !args._project_type_already_applied) {
          args._project_type_already_applied = true;
        }
      }

      // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
      // EARLY MERGE: Apply disambiguation pre-filters BEFORE any guards run
      // This ensures title filter is set before organization routing guards
      // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
      console.log(`[QueryEngine] ğŸ”’ ENFORCEMENT CHECK: preAppliedFilters = ${JSON.stringify(preAppliedFilters)}`);
      // DEBUG: Store preAppliedFilters state in args for debugging
      args._debug_preAppliedFilters_keys = Object.keys(preAppliedFilters);
      args._debug_preAppliedFilters_service_type = preAppliedFilters.service_type;
      args._debug_preAppliedFilters_original_value = preAppliedFilters._service_type_original_value;
      if (Object.keys(preAppliedFilters).length > 0) {
        console.log(`[QueryEngine] ğŸ¯ EARLY MERGE: Applying disambiguation filters BEFORE guards`);
        console.log(`[QueryEngine] ğŸ¯ EARLY MERGE: preAppliedFilters = ${JSON.stringify(preAppliedFilters)}`);
        console.log(`[QueryEngine] ğŸ¯ EARLY MERGE: args BEFORE = ${JSON.stringify(args)}`);
        for (const [key, value] of Object.entries(preAppliedFilters)) {
          if (!key.startsWith('_')) {
            console.log(`[QueryEngine]    Setting ${key} = "${value}" from disambiguation (was: ${args[key]})`);
            args[key] = value;
            // Clear conflicting entity fields when user explicitly selects one
            // This prevents LLM-extracted organization from causing re-disambiguation
            const entityConflictMap: Record<string, string[]> = {
              'title': ['organization', 'client', 'company', 'keyword'],
              'client': ['organization'],
              'company': ['organization'],
              'poc': ['organization'],
              'keyword': ['organization'],
            };
            const conflictingFields = entityConflictMap[key] || [];
            for (const conflictField of conflictingFields) {
              if (args[conflictField]) {
                console.log(`[QueryEngine]    Clearing conflicting ${conflictField}: "${args[conflictField]}"`);
                delete args[conflictField];
                delete args[`_${conflictField}_override`];
                // Also set the already_applied flag to prevent re-disambiguation
                args[`_${conflictField === 'organization' ? 'org' : conflictField}_already_applied`] = true;
              }
            }
          } else {
            // Copy internal flags
            args[key] = value;
            
          }
        }
        // Force the function based on pre-applied column filter
        if (preAppliedFilters.title) {
          functionName = 'get_projects_by_combined_filters';
          args._smart_detection_done = true;
        }
        if (preAppliedFilters.client && preAppliedFilters._client_already_applied) {
          functionName = 'get_projects_by_client';
          args._smart_detection_done = true;
          console.log(`[EARLY MERGE] ğŸ¯ Function set to get_projects_by_client due to pre-applied client filter`);
        }
        if (preAppliedFilters.company && preAppliedFilters._company_already_applied) {
          functionName = 'get_projects_by_company';  // Use proper company function, not combined_filters
          args._smart_detection_done = true;
          console.log(`[EARLY MERGE] ğŸ¯ Function set to get_projects_by_company due to pre-applied company filter`);
        }
        if (preAppliedFilters.poc && preAppliedFilters._poc_already_applied) {
          functionName = 'get_projects_by_poc';
          args._smart_detection_done = true;
          console.log(`[EARLY MERGE] ğŸ¯ Function set to get_projects_by_poc due to pre-applied poc filter`);
        }
        if (preAppliedFilters.keyword && preAppliedFilters._keyword_already_applied) {
          functionName = 'search_projects_by_keyword';
          args._smart_detection_done = true;
          console.log(`[EARLY MERGE] ğŸ¯ Function set to search_projects_by_keyword due to pre-applied keyword filter`);
        }
        
        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        // CRITICAL FIX (EARLY MERGE): Override service_type with user's selection
        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        if (preAppliedFilters._service_type_original_value) {
          console.log(`[EARLY MERGE FIX] ğŸ”§ Overriding args.service_type: "${args.service_type}" â†’ "${preAppliedFilters._service_type_original_value}"`);
          args.service_type = preAppliedFilters._service_type_original_value;
        }
      }

      // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
      // DISAMBIGUATION ENFORCEMENT GUARD
      // After LLM classification, restore pre-applied filters that were overwritten
      // The LLM may extract incorrect values (e.g., "by" from "[filter by ...]")
      // This guard ensures user's disambiguation selection is always respected
      // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
      console.log(`[QueryEngine] ğŸ”’ ENFORCEMENT CHECK: preAppliedFilters = ${JSON.stringify(preAppliedFilters)}`);
      if (Object.keys(preAppliedFilters).length > 0) {
        for (const [key, value] of Object.entries(preAppliedFilters)) {
          if (!key.startsWith('_')) {
            const alreadyAppliedFlag = `_${key}_already_applied`;
            if (preAppliedFilters[alreadyAppliedFlag] && args[key] !== value) {
              console.log(`[QueryEngine] ğŸ”’ DISAMBIGUATION ENFORCEMENT: Restoring ${key} = "${value}" (was: "${args[key]}")`);
              args[key] = value;
            }
          }
        }
      }

      // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
      // POST-PREPROCESS STATUS OPEN/CLOSED GUARD
      // Detects when user says "open"/"closed" but LLM returned a single status
      // Expands to all open/closed statuses as user intended
      // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
      const OPEN_KEYWORDS = /\b(?:which\s+are\s+open|that\s+are\s+open|are\s+open|open\s+projects?|open\s+opportunities?|active\s+projects?|ongoing\s+projects?|current\s+projects?|currently\s+open|still\s+open)\b/i;
      const CLOSED_KEYWORDS = /\b(?:which\s+are\s+closed|that\s+are\s+closed|are\s+closed|closed\s+projects?|completed\s+projects?|finished\s+projects?|currently\s+closed)\b/i;
      
      const ALL_OPEN_STATUSES = ["Proposal Development", "Qualified Lead", "Submitted", "Won", "Lead", "In Progress", "Hold"];
      const ALL_CLOSED_STATUSES = ["Lost", "No Go", "Cancelled"];
      
      if (args.status && typeof args.status === 'string') {
        const statusLower = args.status.toLowerCase();
        const isOpenKeywordInQuestion = OPEN_KEYWORDS.test(userQuestion);
        const isClosedKeywordInQuestion = CLOSED_KEYWORDS.test(userQuestion);
        
        // Check if status is ONE of the open statuses but user said "open" (wants all)
        const openStatusValues = ALL_OPEN_STATUSES.map(s => s.toLowerCase());
        const closedStatusValues = ALL_CLOSED_STATUSES.map(s => s.toLowerCase());
        
        if (isOpenKeywordInQuestion && openStatusValues.includes(statusLower)) {
          console.log(`[QueryEngine] ğŸ”“ STATUS OPEN GUARD: User said "open" but LLM returned "${args.status}"`);
          console.log(`[QueryEngine]    Expanding to ALL open statuses: ${ALL_OPEN_STATUSES.join(', ')}`);
          args.status = ALL_OPEN_STATUSES;
        } else if (isClosedKeywordInQuestion && closedStatusValues.includes(statusLower)) {
          console.log(`[QueryEngine] ğŸ”’ STATUS CLOSED GUARD: User said "closed" but LLM returned "${args.status}"`);
          console.log(`[QueryEngine]    Expanding to ALL closed statuses: ${ALL_CLOSED_STATUSES.join(', ')}`);
          args.status = ALL_CLOSED_STATUSES;
        }
      }

      // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
      // FOLLOW-UP FUNCTION PRESERVATION GUARD
      // When originalContext is provided, PRESERVE the original function_name
      // instead of letting LLM reclassify to a different function
      // This ensures follow-ups stay with the original template (e.g., get_projects_by_combined_filters)
      // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
      if (originalContext && originalContext.function_name) {
        const origFn = originalContext.function_name;
        // Only preserve if it's a filter-based function (not breakdown/aggregation functions)
        const preservableFunctions = [
          'get_projects_by_combined_filters', 
          'get_largest_projects',
          'get_projects_by_category',
          'get_projects_by_service_type',
          'get_projects_by_state',
          'get_projects_by_project_type',
          'get_projects_by_department',
          'get_projects_by_division'
        ];
        
        if (preservableFunctions.includes(origFn) && functionName !== origFn) {
          console.log(`[QueryEngine] ğŸ”’ FOLLOW-UP FUNCTION GUARD: Preserving original function`);
          console.log(`[QueryEngine]    LLM wanted: ${functionName} â†’ Forcing: ${origFn}`);
          functionName = origFn;
        }
      }

      // Step 2.5: GENERIC BREAKDOWN OVERRIDE (Final check before execution)

      // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
      // POST-PREPROCESS REGION GUARD: Ensure region queries route correctly
      // This runs AFTER preprocessQuery to prevent downstream overrides
      // If regions filter exists and function is still ai_fallback, force to get_largest_projects
      // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
      if (args.regions && Array.isArray(args.regions) && args.regions.length > 0) {
        const isRegionQueryPost = /\b(?:west|midwest|south|north|east|pacific|mountain|southeast|southwest|northeast|northwest)\s*(?:region|coast)?\b/i.test(userQuestion);
        console.log(`[QueryEngine] POST-PREPROCESS GUARD CHECK: functionName=${functionName}, regions=${JSON.stringify(args.regions)}, isRegionQueryPost=${isRegionQueryPost}`);
        
        if (functionName === 'ai_fallback' && isRegionQueryPost) {
          console.log(`[QueryEngine] ğŸ—ºï¸ POST-PREPROCESS REGION GUARD: Forcing ai_fallback â†’ get_largest_projects (regions=${args.regions.join(', ')})`); 
          functionName = 'get_largest_projects';
        } else if (functionName === 'ai_fallback') {
          console.log(`[QueryEngine] ğŸ—ºï¸ POST-PREPROCESS REGION FALLBACK: Forcing ai_fallback â†’ get_largest_projects (regions=${args.regions.join(', ')})`); 
          functionName = 'get_largest_projects';
        }
      }
      
      // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
      // GENERALIZED DISAMBIGUATION CHECK (EARLY - before any handler)
      // When AI sets ANY singular entity filter (city, client, company, poc, etc.)
      // Check if that entity could match multiple columns and offer disambiguation
      // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
      
      // DEBUG: Log args state before alreadyDisambiguated check
      console.log(`[QueryEngine] ğŸ” PRE-DISAMBIG-CHECK: args._company_already_applied=${args._company_already_applied}, args.company="${args.company}", args.keyword="${args.keyword}"`);
      
      // EARLY SKIP GUARD: If user already selected a column via disambiguation,
      // skip this check entirely to avoid re-triggering disambiguation
      const alreadyDisambiguated = args._disambiguation_column || 
                                   args._client_already_applied || 
                                   args._company_already_applied || 
                                   args._poc_already_applied || 
                                   args._keyword_already_applied ||
                                   args._title_already_applied ||
                                   args._city_already_applied ||
                                   args._division_already_applied ||
                                   args._department_already_applied ||
                                   args._org_already_applied ||
                                   args._service_type_already_applied ||
                                   args._smart_detection_done;
      
      // SKIP ENTIRE GENERALIZED DISAMBIGUATION when already disambiguated
      if (!alreadyDisambiguated) {
      
      const entityParamMappings: Array<{ paramName: string; displayName: string; alreadyAppliedFlag: string }> = [
        { paramName: 'title', displayName: 'Project Title', alreadyAppliedFlag: '_title_already_applied' },
        { paramName: 'keyword', displayName: 'Project Title/Keyword', alreadyAppliedFlag: '_keyword_already_applied' },
        { paramName: 'city', displayName: 'City', alreadyAppliedFlag: '_city_already_applied' },
        { paramName: 'client', displayName: 'Client', alreadyAppliedFlag: '_client_already_applied' },
        { paramName: 'company', displayName: 'Company', alreadyAppliedFlag: '_company_already_applied' },
        { paramName: 'poc', displayName: 'Point of Contact', alreadyAppliedFlag: '_poc_already_applied' },
        { paramName: 'division', displayName: 'Division', alreadyAppliedFlag: '_division_already_applied' },
        { paramName: 'department', displayName: 'Department', alreadyAppliedFlag: '_department_already_applied' },
        { paramName: 'organization', displayName: 'Organization', alreadyAppliedFlag: '_org_already_applied' },
      ];
      
      // Find if any singular entity is set (excluding already-verified ones)
      let activeEntity: { paramName: string; value: string; displayName: string } | null = null;
      for (const mapping of entityParamMappings) {
        const value = args[mapping.paramName];
        if (value && typeof value === 'string' && !args._smart_detection_done && !args[mapping.alreadyAppliedFlag]) {
          activeEntity = { paramName: mapping.paramName, value, displayName: mapping.displayName };
          break;
        }
      }
      
      console.log(`[QueryEngine] ğŸ” GENERALIZED CHECK: args keys = ${JSON.stringify(Object.keys(args).filter(k => !k.startsWith('_')))} activeEntity=${JSON.stringify(activeEntity)}`);
      if (activeEntity) {
        console.log(`[QueryEngine] ğŸ¤” GENERALIZED DISAMBIGUATION: ${activeEntity.paramName}="${activeEntity.value}" checking all columns...`);
        
        // Run detectAllMatchingColumns to find all columns with matches
        const allMatches = await this.detectAllMatchingColumns(activeEntity.value, externalDbQuery);
        console.log(`[QueryEngine] ğŸ“Š All column matches for "${activeEntity.value}":`, JSON.stringify(allMatches));
        
        if (allMatches.length > 1) {
          // Multiple columns have matches - ALWAYS ask user which column they want
          // Only auto-select if one column has 10x more matches (overwhelming difference)
          const topMatch = allMatches[0];
          const secondMatch = allMatches[1];
          
          // Only auto-select if top match has 10x or more count (overwhelming difference)
          if (topMatch.count >= secondMatch.count * 10) {
            console.log(`[QueryEngine] âœ… GENERALIZED AUTO-SELECT (10x threshold): ${topMatch.column} (${topMatch.count}) >> ${secondMatch.column} (${secondMatch.count})`);
            // Clear the original param and set the correct one
            delete args[activeEntity.paramName];
            args[topMatch.paramName] = activeEntity.value;
            args._smart_detection_done = true;
            
            // Update function name and flags based on matched column
            if (topMatch.paramName === 'keyword' || topMatch.paramName === 'title') {
              functionName = 'search_projects_by_keyword';
              args.keyword = activeEntity.value;
              args._keyword_already_applied = true;
              args._title_already_applied = true;
            } else if (topMatch.paramName === 'client') {
              functionName = 'get_projects_by_client';
              args._client_already_applied = true;
            } else if (topMatch.paramName === 'company') {
              functionName = 'get_projects_by_combined_filters';
              args._company_already_applied = true;
            } else if (topMatch.paramName === 'poc') {
              functionName = 'get_projects_by_poc';
              args._poc_already_applied = true;
            } else if (topMatch.paramName === 'city') {
              functionName = 'get_projects_by_city';
              args._city_already_applied = true;
            } else if (topMatch.paramName === 'division') {
              functionName = 'get_projects_by_division';
              args._division_already_applied = true;
            } else if (topMatch.paramName === 'department') {
              functionName = 'get_projects_by_department';
              args._department_already_applied = true;
            }
          } else {
            // ASK USER - multiple columns have matches, let them choose
            console.log(`[QueryEngine] ğŸ”€ ASKING USER: Multiple columns match "${activeEntity.value}" - showing options`);
            return {
              success: true,
              question: userQuestion,
              function_name: 'disambiguation_required',
              arguments: args,
              data: [{
                type: 'disambiguation',
                entity: activeEntity.value,
                columns: allMatches,
                message: `I found "${activeEntity.value}" in multiple places. Which column would you like to search?`
              }],
              row_count: 0,
              summary: {},
              chart_config: null,
              message: 'disambiguation_required'
            };
          }
        } else if (allMatches.length === 1) {
          // Only one column matches - auto-select it
          const match = allMatches[0];
          console.log(`[QueryEngine] âœ… GENERALIZED SINGLE MATCH: ${match.column} for "${activeEntity.value}"`);
          // Clear the original param and set the correct one
          delete args[activeEntity.paramName];
          args[match.paramName] = activeEntity.value;
          args._smart_detection_done = true;
          
          // Update function name based on matched column
          if (match.paramName === 'client') {
            functionName = 'get_projects_by_client';
            args._client_already_applied = true;
          } else if (match.paramName === 'company') {
            functionName = 'get_projects_by_combined_filters';
            args._company_already_applied = true;
          } else if (match.paramName === 'poc') {
            functionName = 'get_projects_by_poc';
            args._poc_already_applied = true;
          } else if (match.paramName === 'city') {
            functionName = 'get_projects_by_city';
            args._city_already_applied = true;
          } else if (match.paramName === 'division') {
            functionName = 'get_projects_by_division';
            args._division_already_applied = true;
          } else if (match.paramName === 'department') {
            functionName = 'get_projects_by_department';
            args._department_already_applied = true;
          } else if (match.paramName === 'keyword' || match.paramName === 'title') {
            // Route to keyword search for title matches
            functionName = 'search_projects_by_keyword';
            args.keyword = activeEntity.value;
            args._keyword_already_applied = true;
            args._title_already_applied = true;
            console.log(`[QueryEngine] ğŸ¯ GENERALIZED SINGLE MATCH â†’ search_projects_by_keyword with keyword="${activeEntity.value}"`);
          }
        } else if (allMatches.length === 0) {
          // No matches in any column - offer disambiguation anyway to help user
          console.log(`[QueryEngine] âš ï¸ NO MATCHES FOUND for "${activeEntity.value}" in any column`);
          // Let it continue to normal flow - might find partial matches elsewhere
        }
      }
      } // End of if (!alreadyDisambiguated) skip guard

      // PROJECT TYPE GUARD: Convert search_description to get_projects_by_project_type
      // when query contains explicit project type names like "Road/Highway"
      // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
      if (functionName === "search_description" || (functionName === "get_projects_by_project_type" && args.project_type === "Transportation")) {
        // Match "road highway", "highway road", OR just "highway" or "road" alone when asking for projects
        const roadHighwayMatch = /\b(?:road[\s\/]*highway|highway[\s\/]*road)\b/i.test(userQuestion);
        const singleHighwayMatch = /\b(?:highway|highways)\s+(?:projects?|work|deals?)\b/i.test(userQuestion);
        const singleRoadMatch = /\b(?:road|roads)\s+(?:projects?|work|deals?)\b/i.test(userQuestion);
        
        if (roadHighwayMatch || singleHighwayMatch || singleRoadMatch) {
          console.log(`[QueryEngine] ğŸ›£ï¸ ROAD/HIGHWAY GUARD: Query mentions highway/road â†’ forcing get_projects_by_project_type with project_type="Road/Highway"`);
          functionName = "get_projects_by_project_type";
          args.project_type = "Road/Highway";
          args._project_type_explicit = true;
          delete args.keyword;
        }
      }
      
      // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
      // PROJECT-TYPE + STATE COMBO GUARD: When both project_type and states are set,
      // reroute to get_projects_by_combined_filters for proper multi-clause SQL
      // E.g., "Highway projects in California" needs both ProjectType AND State filters
      // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
      if (args.project_type && functionName === "get_projects_by_project_type") {
        const hasStates = args.states && Array.isArray(args.states) && args.states.length > 0;
        const hasStateCode = args.state_code && typeof args.state_code === 'string';
        if (hasStates || hasStateCode) {
          console.log(`[QueryEngine] ğŸ”€ PROJECT-TYPE+STATE COMBO: Rerouting from ${functionName} to get_projects_by_combined_filters (project_type="${args.project_type}", states=${JSON.stringify(args.states || args.state_code)})`);
          functionName = "get_projects_by_combined_filters";
        }
      }


      // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
      // POST-PREPROCESS ORGANIZATION GUARD: Ensure organization queries route correctly
      // This runs AFTER preprocessQuery because the pre-preprocess guard's changes get lost
      // If organization pattern matches and function is ai_fallback, force to get_projects_by_combined_filters
      // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
      const orgPatternMatchPost = userQuestion.match(/(?:show|list|find|get|display|what|which)\s+(?:all\s+)?(?:projects?|opportunities?|deals?|work)?\s*(?:for|with|from|by|of|at|related\s+to|belonging\s+to|associated\s+with)?\s*([A-Z][a-zA-Z0-9\-\_\&\s]{1,30}?)(?:\s+(?:projects?|client|company|organization|work|opportunities?|deals?))?$/i);
      const simpleOrgMatchPost = userQuestion.match(/^([A-Z][a-zA-Z0-9\-\_\&\s]{1,25})\s+(?:projects?|client|opportunities?|deals?)$/i);
      
      console.log(`[QueryEngine] ğŸ” POST-PREPROCESS GUARD DEBUG: functionName=${functionName}, orgPatternMatchPost=${!!orgPatternMatchPost}, simpleOrgMatchPost=${!!simpleOrgMatchPost}`);
      if (functionName === 'ai_fallback' && (orgPatternMatchPost || simpleOrgMatchPost)) {
        const extractedOrgPost = (orgPatternMatchPost ? orgPatternMatchPost[1] : simpleOrgMatchPost ? simpleOrgMatchPost[1] : '').trim();
        const excludeWordsPost = ['all', 'the', 'my', 'our', 'your', 'their', 'some', 'any', 'recent', 'latest', 'new', 'old', 'current', 'previous', 'last', 'first', 'top', 'best', 'largest', 'smallest', 'submitted', 'won', 'lost', 'pending'];
        if (extractedOrgPost && extractedOrgPost.length >= 2 && !excludeWordsPost.includes(extractedOrgPost.toLowerCase())) {
          // SMART COLUMN DETECTION: Check which column has the most matches for this term
          const columnMatch = await this.detectBestMatchingColumn(extractedOrgPost, externalDbQuery);
          if (columnMatch && columnMatch.count > 0) {
            console.log(`[QueryEngine] ğŸ¯ SMART COLUMN DETECTED: "${extractedOrgPost}" â†’ ${columnMatch.column} (${columnMatch.count} matches)`);
            functionName = columnMatch.functionName;
            args[columnMatch.paramName] = extractedOrgPost;
            // Mark as already applied to prevent double-filtering
            if (columnMatch.paramName === 'poc') {
              args._poc_already_applied = true;
            } else if (columnMatch.paramName === 'company') {
              args._company_already_applied = true;
            }
          } else {
            // Fallback to 4-column organization search
            console.log(`[QueryEngine] ğŸ¢ POST-PREPROCESS ORGANIZATION GUARD: Forcing ai_fallback â†’ get_projects_by_combined_filters (organization="${extractedOrgPost}")`);
            functionName = 'get_projects_by_combined_filters';
            args.organization = extractedOrgPost;
            // Clear client/company to ensure 4-column organization filter runs
            // GUARD: Don't delete org-indicator clients OR disambiguation-selected clients
            if (!args._org_indicator_client && !args._client_already_applied) {
              delete args.client;
            }
            // GUARD: Don't delete company if disambiguation-selected
            if (!args._company_already_applied) {
              delete args.company;
            }
            args._organization_override = true;
          }
        }
      }
      // convert company to organization for 4-column search
      // GUARD: Skip conversion if company was disambiguation-selected
      if (functionName === 'get_projects_by_combined_filters' && args.company && (!args.organization || args.organization === args.company) && !args._company_already_applied) {
        console.log(`[QueryEngine] ğŸ¢ COMPANYâ†’ORGANIZATION CONVERSION: Setting organization="${args.company}" from company`);
        args.organization = args.company;
        // GUARD: Don't delete org-indicator clients OR disambiguation-selected clients
        if (!args._org_indicator_client && !args._client_already_applied) {
          delete args.client;
        }
        // GUARD: Don't delete company if disambiguation-selected (redundant but explicit)
        if (!args._company_already_applied) {
          delete args.company;
        }
        args._organization_override = true;
      }
      
      // DEBUG: Check conditions before ORGANIZATION-FROM-REGION GUARD
      const guardCond1 = functionName === 'get_projects_by_client';
      const guardCond2 = !!args.region;
      const guardCond3 = !args.client;
      const guardCond4 = !args.organization;
      console.log(`[QueryEngine] ORG-REGION GUARD CHECK: fn=${functionName}(${guardCond1}), region=${args.region}(${guardCond2}), noClient=${guardCond3}, noOrg=${guardCond4}, ALL=${guardCond1 && guardCond2 && guardCond3 && guardCond4}`);
      args._guard_debug = { guardCond1, guardCond2, guardCond3, guardCond4, fnAtCheck: functionName };
      
      // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
      // DEFENSIVE CLIENT PRESERVATION: Save original client value for restoration
      // This guards against complex multi-stage deletion bugs
      // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
      if (args.client && typeof args.client === 'string') {
        args._preserved_client = args.client;
        console.log(`[QueryEngine] ğŸ“¦ PRESERVED CLIENT: Saved client="${args.client}" for later restoration`);
      }
      
      // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
      // MULTI-WORD REGION GUARD: Preserve multi-word regions like "Central Asia"
      // before they get truncated to single words
      // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
      const multiWordRegions = [
        { pattern: /\bcentral\s+asia\b/i, value: 'Central Asia' },
        { pattern: /\bsouth\s*east\s+asia\b/i, value: 'Southeast Asia' },
        { pattern: /\bmiddle\s+east\b/i, value: 'Middle East' },
        { pattern: /\bnorth\s+america\b/i, value: 'NA - Northeast' },
        { pattern: /\bsouth\s+america\b/i, value: 'South America' }
      ];
      
      for (const mwRegion of multiWordRegions) {
        if (mwRegion.pattern.test(userQuestion)) {
          // Check if this multi-word region was truncated
          if (args.region && typeof args.region === 'string') {
            const truncatedParts = ['asia', 'east', 'america'];
            if (truncatedParts.some(p => args.region.toLowerCase() === p)) {
              console.log(`[QueryEngine] ğŸŒ MULTI-WORD REGION GUARD: Restoring "${args.region}" â†’ "${mwRegion.value}"`);
              args.region = mwRegion.value;
              args.regions = [mwRegion.value];
            }
          }
          // Also set if not set
          if (!args.region && !args.regions) {
            console.log(`[QueryEngine] ğŸŒ MULTI-WORD REGION GUARD: Setting region="${mwRegion.value}"`);
            args.region = mwRegion.value;
            args.regions = [mwRegion.value];
          }
          break;
        }
      }

      // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
      // REGION-ONLY ROUTING GUARD: When search_projects_by_keyword has only region filter,
      // route to get_largest_projects which handles region filtering correctly
      // E.g., "Central Asia projects" should list projects, not search keywords
      if (functionName === 'search_projects_by_keyword' && (args.region || (args.regions && args.regions.length > 0))) {
        if (!args.keyword || args._keyword_already_applied) {
          console.log(`[QueryEngine] ğŸ”„ REGION-ONLY ROUTING: search_projects_by_keyword with region but no keyword â†’ get_largest_projects`);
          functionName = 'get_largest_projects';
          // Ensure regions array is set for the function
          if (args.region && (!args.regions || args.regions.length === 0)) {
            args.regions = [args.region];
          }
        }
      }

      // GEO-TOKEN CLIENT GUARD: When a geographic term is routed to division/region
      // but matches a client name prefix, search client instead
      // E.g., "Abu Dhabi projects" â†’ search Client for "Abu Dhabi" (not Division/Region)
      // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
      // GEO-TOKEN CLIENT GUARD: Route geographic terms to client search if they match client names
      // Checks both division and region routing functions
      if (functionName === 'get_projects_by_division' && args.division && !args.client) {
        const geoTerm = args.division;
        console.log(`[GEO-CLIENT] Checking division "${geoTerm}" against Client column`);
        try {
          const sql = `SELECT COUNT(*) as cnt FROM "${TABLE}" WHERE "Client" LIKE @p1`;
          const result = await externalDbQuery(sql, [`%${geoTerm}%`]);
          const cnt = result[0]?.cnt || 0;
          console.log(`[GEO-CLIENT] Client matches for "${geoTerm}": ${cnt}`);
          if (cnt > 0) {
            console.log(`[GEO-CLIENT] âœ… Routing to get_projects_by_client with client="${geoTerm}"`);
            functionName = 'get_projects_by_client';
            args.client = geoTerm;
            delete args.division;
          }
        } catch (e) {
          console.log(`[GEO-CLIENT] Error:`, e);
        }
      }

      // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
      // ORGANIZATION-FROM-REGION GUARD: Fix cases like "Abu Dhabi Airports Company projects"
      // where LLM extracts region="Abu Dhabi" but misses the full organization name
      // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
      if ((functionName === 'get_projects_by_client' || functionName === 'get_projects_by_company') && args.region && !args.client && !args.organization) {
        // Check if user question contains organization indicators
        const orgIndicators = /\b(company|corporation|corp|inc|llc|ltd|group|authority|agency|district|foundation|hospital|airports|university|college|school|transit|metro|mta|port)\b/i;
        if (orgIndicators.test(userQuestion)) {
          // Try to extract full organization name from query
          const orgMatch = userQuestion.match(/(?:show|list|display|get|find)?\s*(.+?(?:company|corporation|corp|inc|llc|ltd|group|authority|agency|district|foundation|hospital|airports|university|college|school|transit|metro|mta|port)[^,]*?)\s*(?:projects?|open|won|closed|this|last|from|in\s+\d|$)/i);
          if (orgMatch && orgMatch[1]) {
            const extractedOrg = orgMatch[1].trim().replace(/^(show|list|display|get|find|for|of)\s+/i, '').trim();
            if (extractedOrg.length > 3) {
              console.log(`[QueryEngine] ğŸ¢ ORGANIZATION-FROM-REGION GUARD: Extracted "${extractedOrg}" from query (region was "${args.region}")`);
              functionName = 'get_projects_by_combined_filters';
              args.organization = extractedOrg;
              delete args.region;
              args._organization_override = true;
              args._smart_detection_done = false;
              args._org_region_guard_fired = true;  // Marker to verify guard fired
            }
          }
        }
      }
      
      // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
      // COMPARE_REGIONS REDIRECT GUARD: Fix cases like "West region projects"
      // User wants project list, not region comparison metrics
      // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
      if (functionName === 'compare_regions' && args.regions && Array.isArray(args.regions)) {
        const wantsProjectList = /\b(?:projects?|show|list|display|all)\b/i.test(userQuestion) &&
                                 !/\b(?:compare|comparison|breakdown|by\s+region|group|aggregate|statistics?|analysis)\b/i.test(userQuestion);
        if (wantsProjectList) {
          console.log(`[QueryEngine] ğŸ”„ COMPARE_REGIONS REDIRECT: User wants project list, not comparison. Redirecting to get_largest_projects`);
          functionName = 'get_largest_projects';
        }
      }
      
      // GUARD: Run smart column detection for get_projects_by_category when company parameter is set
      // This catches cases like "DFW Airport (Dallas, TX) projects" where LLM routes to category but should be client
      // GUARD: Skip if company already applied from disambiguation
      if ((functionName === 'get_projects_by_category' || functionName === 'get_projects_by_project_type' || functionName === 'get_projects_by_status') && args.company && !args._smart_detection_done && !args._company_already_applied) {
        const companyTerm = args.company;
        console.log(`[QueryEngine] ğŸ” CATEGORY-COMPANY GUARD: Checking smart column detection for company="${companyTerm}"`);
        const columnMatch = await this.detectBestMatchingColumn(companyTerm, externalDbQuery);
        if (columnMatch && columnMatch.count > 0) {
          console.log(`[QueryEngine] ğŸ¯ SMART COLUMN DETECTED FOR CATEGORY: "${companyTerm}" â†’ ${columnMatch.column} (${columnMatch.count} matches)`);
          functionName = columnMatch.functionName;
          delete args.company;
          args[columnMatch.paramName] = companyTerm;
          args._smart_detection_done = true;
          if (columnMatch.paramName === 'client') {
            args._client_already_applied = true;
          } else if (columnMatch.paramName === 'poc') {
            args._poc_already_applied = true;
          }
        }
      }

      
      // GUARD: Extract entity name from user query when LLM routes to project_type without client/org filter
      // This handles "DFW Airport (Dallas, TX) projects" â†’ project_type="Airports" without client filter
      if ((functionName === 'get_projects_by_project_type' || functionName === 'get_projects_by_category' || functionName === 'get_projects_by_status') &&
          args.project_type && !args.company && !args.client && !args.organization &&
          !args._entity_extraction_done) {
        // Extract potential entity names from the user question
        const ptVal = Array.isArray(args.project_type) ? args.project_type[0] : args.project_type;
        const projectTypeKeywords: Record<string, string[]> = {
          'Airports': ['airport', 'airports', 'aviation'],
          'Hospitals': ['hospital', 'hospitals', 'medical', 'health'],
          'Transit': ['transit', 'transportation', 'railway'],
          'Transportation': ['airport', 'transit', 'port', 'transportation']
        };
        const relevantKeywords = projectTypeKeywords[ptVal] || [];
        // Look for patterns like "X Airport", "X Hospital" in the user question
        const entityPatterns = relevantKeywords.map(kw => new RegExp(`([A-Z][A-Za-z0-9\\s]+\\s+${kw})`, 'i'));
        let extractedEntity: string | null = null;
        for (const pattern of entityPatterns) {
          const match = userQuestion.match(pattern);
          if (match && match[1]) {
            extractedEntity = match[1].trim();
            break;
          }
        }
        if (extractedEntity) {
          console.log(`[QueryEngine] ğŸ” ENTITY-FROM-PROJECTTYPE GUARD: Extracted entity "${extractedEntity}" from query`);
          const columnMatch = await this.detectBestMatchingColumn(extractedEntity, externalDbQuery);
          if (columnMatch && columnMatch.count > 0 && columnMatch.column !== 'ProjectType') {
            console.log(`[QueryEngine] ğŸ¯ ENTITY DETECTED: "${extractedEntity}" â†’ ${columnMatch.column} (${columnMatch.count} matches)`);
            args[columnMatch.paramName] = extractedEntity;
            delete args.project_type;
            delete args._project_type_explicit;
            args._entity_extraction_done = true;
            if (columnMatch.paramName === 'client') {
              args._client_already_applied = true;
            }
            
            // INLINE CATEGORY CLEANUP: Remove categories that match entity keywords
            // This runs immediately after entity extraction, before normalization guards
            if (args.categories && Array.isArray(args.categories)) {
              const entityLower = extractedEntity.toLowerCase();
              const categoryKeywordMap: Record<string, string[]> = {
                'Transportation': ['airport', 'airports', 'aviation', 'transit', 'railway', 'airline', 'port'],
                'Healthcare': ['hospital', 'hospitals', 'medical', 'health', 'clinic'],
                'Education': ['school', 'schools', 'university', 'college', 'academy'],
                'Government': ['government', 'civic', 'municipal', 'federal', 'state']
              };
              const filteredCategories = args.categories.filter((cat: string) => {
                const keywords = categoryKeywordMap[cat] || [];
                const hasKeyword = keywords.some(kw => entityLower.includes(kw));
                if (hasKeyword) {
                  console.log(`[EntityExtraction] ğŸ§¹ Removing category="${cat}" - keyword found in entity "${extractedEntity}"`);
                  return false;
                }
                return true;
              });
              if (filteredCategories.length === 0) {
            
       // Also remove singular form
              } else if (filteredCategories.length !== args.categories.length) {
                args.categories = filteredCategories;
              }
            }

            // Convert to combined filters if needed
            if (functionName === 'get_projects_by_project_type') {
              functionName = columnMatch.functionName;
            }
          }
        }
      }

      // GUARD: Convert get_projects_by_company to use 4-column organization search
      // This ensures company queries search across Client, Company, ProjectType, and PointOfContact
      // Also handle when LLM sets keyword instead of company
      const companyTerm = args.company || (functionName === 'get_projects_by_company' ? args.keyword : null);
      // DISAMBIGUATION GUARD: Skip company conversion if disambiguation is locked
      if (functionName === 'get_projects_by_company' && companyTerm && !args._smart_detection_done && !args._disambiguation_locked && !args._company_already_applied) {
        console.log(`[QueryEngine] ğŸ¢ CONVERTING get_projects_by_company to get_projects_by_combined_filters with organization="${companyTerm}"`);
        functionName = 'get_projects_by_combined_filters';
        args.organization = companyTerm;
        delete args.company;
        delete args.keyword;  // Clear keyword since we're using it as organization
        args._organization_override = true;
      }
      
      // EARLY CLIENT PROTECTION: Mark client as preserved (but don't set _client_already_applied yet)
      // This allows the organization fallback to still run while preserving the client for restoration
      if (args.client && typeof args.client === "string" && !args._client_preserved) {
        args._client_preserved = true;
        console.log(`[QueryEngine] ğŸ” EARLY CLIENT PROTECTION: Marked client="${args.client}" as preserved (not setting _client_already_applied)`);
      }
      // GUARD: Convert get_projects_by_client to use 4-column organization search
      // This ensures client queries search across Client, Company, ProjectType, and PointOfContact
      // SKIP if title is already applied from disambiguation (user explicitly chose Project Title column)
      const hasTitleFromDisambiguation = preAppliedFilters && preAppliedFilters.title;
      if (functionName === 'get_projects_by_client' && (args.client || args.organization) && !args._smart_detection_done && !args._client_already_applied && !args._title_already_applied && !hasTitleFromDisambiguation) {
        const entityValue = args.client || args.organization;
        console.log(`[QueryEngine] ğŸ¢ CONVERTING get_projects_by_client to get_projects_by_combined_filters with organization="${entityValue}"`);
        functionName = 'get_projects_by_combined_filters';
        args.organization = entityValue;
        delete args.client;
        args._organization_override = true;
      }
      
      
      // SMART COLUMN DETECTION FOR ORGANIZATION: Before using 4-column filter, check if term matches a specific column
      // This handles cases where LLM sets organization directly - we still want to route to the best-matching column
      // SKIP if title is already applied from disambiguation (user explicitly chose Project Title column)
      const hasTitleFromDisambiguation2 = preAppliedFilters && preAppliedFilters.title;
      if (functionName === 'get_projects_by_combined_filters' && args.organization && !args._smart_detection_done && !args._title_already_applied && !hasTitleFromDisambiguation2) {
        const orgTerm = args.organization;
        
        // USE ALL MATCHING COLUMNS - show disambiguation when term matches multiple columns
        const allColumnMatches = await this.detectAllMatchingColumns(orgTerm, externalDbQuery);
        console.log(`[QueryEngine] ğŸ” ORGANIZATION ALL COLUMNS CHECK: "${orgTerm}" found in ${allColumnMatches.length} columns`, allColumnMatches.map(m => `${m.column}:${m.count}`).join(', '));
        
        // Filter to columns with matches
        const matchingColumns = allColumnMatches.filter(m => m.count > 0);
        
        // If multiple columns have matches, show disambiguation
        if (matchingColumns.length > 1) {
          console.log(`[QueryEngine] ğŸ”€ ORGANIZATION DISAMBIGUATION: "${orgTerm}" matches ${matchingColumns.length} columns - showing options`);
          return {
            function_name: functionName,
            arguments: args,
            row_count: 0,
            message: `"${orgTerm}" was found in multiple columns. Please select which column to search:`,
            data: [{
              type: 'disambiguation',
              searchTerm: orgTerm,
              columns: matchingColumns.map(m => ({
                column: m.column,
                displayName: m.displayName || m.column,
                count: m.count,
                  value: orgTerm,
                paramName: m.paramName,
                functionName: m.functionName
              }))
            }],
            _disambiguation_pending: true
          };
        }
        
        // If exactly one column has matches, auto-execute with that column
        let columnMatch = matchingColumns.length === 1 ? matchingColumns[0] : null;
        
        // FULL NAME FALLBACK: If short org term finds no matches, try extracting a longer project name from the question
        if (!columnMatch || columnMatch.count === 0) {
          console.log(`[QueryEngine] ğŸ” FULL NAME FALLBACK: No matches for org "${orgTerm}", trying full name from question`);
          // Extract everything after common query prefixes up to common suffixes
          const fullNameMatch = userQuestion.match(/(?:list|show|get|find|provide|display)\s+(?:all\s+)?(?:the\s+)?projects?\s+(.+?)(?:\s+which|\s+that|\s+from|\s+in|\s+with|\s+are|$)/i);
          if (fullNameMatch && fullNameMatch[1] && fullNameMatch[1].length > orgTerm.length) {
            const fullName = fullNameMatch[1].trim();
            console.log(`[QueryEngine] ğŸ” FULL NAME FALLBACK: Trying full name "${fullName}"`);
            const fullNameMatch2 = await this.detectBestMatchingColumn(fullName, externalDbQuery);
            if (fullNameMatch2 && fullNameMatch2.count > 0) {
              console.log(`[QueryEngine] âœ… FULL NAME FALLBACK SUCCESS: "${fullName}" â†’ ${fullNameMatch2.column} (${fullNameMatch2.count} matches)`);
              columnMatch = fullNameMatch2;
              // Update the orgTerm to use full name
              args.organization = fullName;
            }
          }
        }
        
        if (columnMatch && columnMatch.count > 0) {
          // Check if there's a dominant column (significantly more matches than 2nd best would require separate query)
          // For now, just use the best matching column
          console.log(`[QueryEngine] ğŸ¯ SMART ORGANIZATION DETECTION: "${orgTerm}" â†’ ${columnMatch.column} (${columnMatch.count} matches)`);
          functionName = columnMatch.functionName;
          delete args.organization;
          delete args._organization_override;  // Clear override so column-specific filter applies
          
          // CRITICAL FIX: Clear conflicting entity params that have the SAME value as orgTerm
          // This prevents SQL from having both Client AND Company filters for the same value
          // But PRESERVE distinct params (e.g., client + poc from different values in query)
          const orgTermLower = orgTerm.toLowerCase();
          if (columnMatch.paramName === 'client') {
            // Only clear company if it has the same value as the org term we're routing to client
            if (args.company && args.company.toLowerCase() === orgTermLower) {
              delete args.company;
              delete args._company_already_applied;
              console.log(`[QueryEngine] ğŸ§¹ SMART DETECTION CLEANUP: Cleared duplicate company (same as orgTerm)`);
            }
            // Only clear poc if it has the same value
            if (args.poc && args.poc.toLowerCase() === orgTermLower) {
              delete args.poc;
              delete args._poc_already_applied;
              console.log(`[QueryEngine] ğŸ§¹ SMART DETECTION CLEANUP: Cleared duplicate poc (same as orgTerm)`);
            }
          } else if (columnMatch.paramName === 'company') {
            if (args.client && args.client.toLowerCase() === orgTermLower) {
              delete args.client;
              delete args._client_already_applied;
              console.log(`[QueryEngine] ğŸ§¹ SMART DETECTION CLEANUP: Cleared duplicate client (same as orgTerm)`);
            }
            if (args.poc && args.poc.toLowerCase() === orgTermLower) {
              delete args.poc;
              delete args._poc_already_applied;
              console.log(`[QueryEngine] ğŸ§¹ SMART DETECTION CLEANUP: Cleared duplicate poc (same as orgTerm)`);
            }
          } else if (columnMatch.paramName === 'poc') {
            if (args.client && args.client.toLowerCase() === orgTermLower) {
              delete args.client;
              delete args._client_already_applied;
              console.log(`[QueryEngine] ğŸ§¹ SMART DETECTION CLEANUP: Cleared duplicate client (same as orgTerm)`);
            }
            if (args.company && args.company.toLowerCase() === orgTermLower) {
              delete args.company;
              delete args._company_already_applied;
              console.log(`[QueryEngine] ğŸ§¹ SMART DETECTION CLEANUP: Cleared duplicate company (same as orgTerm)`);
            }
          }
          
          args[columnMatch.paramName] = orgTerm;
          console.log(`[QueryEngine] DEBUG: SET args[${columnMatch.paramName}] = ${orgTerm} | args.client=${args.client} args.company=${args.company}`);
          // Mark as already applied to prevent double-filtering
          if (columnMatch.paramName === 'poc') {
            args._poc_already_applied = true;
          } else if (columnMatch.paramName === 'company') {
            args._company_already_applied = true;
          } else if (columnMatch.paramName === 'client') {
            args._client_already_applied = true;
          }
          // Clear title ONLY if we're routing to a NON-title column (client, company, poc)
          // If the title IS the main search term, we need to KEEP it for keyword search
          if (args.title && args.title.toLowerCase() === orgTerm.toLowerCase()) {
            // Only delete if we're routing to client/company/poc, not if title IS the search
            if (columnMatch.paramName !== 'keyword' && columnMatch.paramName !== 'title') {
              // Check if there are any matches in Title column - if so, keep the title
              const titleMatches = await this.detectAllMatchingColumns(args.title, externalDbQuery);
              const titleColumn = titleMatches.find(m => m.column === 'Title');
              if (!titleColumn || titleColumn.count === 0) {
                console.log(`[QueryEngine] ğŸ§¹ Clearing duplicate title filter: "${args.title}" (no Title column matches)`);
                delete args.title;
              } else {
                console.log(`[QueryEngine] âœ“ KEEPING title filter: "${args.title}" (found ${titleColumn.count} Title matches)`);
              }
            }
          }
          args._smart_detection_done = true;
          args._smart_detection_result = { 
            column: columnMatch.column, 
            count: columnMatch.count, 
            paramName: columnMatch.paramName, 
            paramValue: orgTerm,
            debug_args_client_after_set: args.client,
            debug_functionName_at_smart_detection: functionName
          };
          console.log(`[QueryEngine] ğŸ¯ DEBUG AFTER SMART: args.client = "${args.client}", args[${columnMatch.paramName}] = "${args[columnMatch.paramName]}"`);
          
          // CRITICAL FIX: Clear project_type if the entity name contains project type keywords
          // This prevents "DFW Airport" from adding both client filter AND project_type="Airports" filter
          if (args.project_type && orgTerm) {
            const projectTypeKeywords: Record<string, string[]> = {
              'Airports': ['airport', 'airports', 'aviation'],
              'Hospitals': ['hospital', 'hospitals', 'medical', 'health'],
              'Transit': ['transit', 'transportation', 'railway'],
              'K-12': ['school', 'schools', 'education'],
              'Higher Education': ['university', 'college'],
              'Government': ['government', 'civic', 'municipal'],
              'Water/Wastewater': ['water', 'wastewater', 'utility'],
              'Industrial': ['industrial', 'manufacturing', 'factory']
            };
            const entityLower = orgTerm.toLowerCase();
            const ptValue = Array.isArray(args.project_type) ? args.project_type[0] : args.project_type;
            const keywords = projectTypeKeywords[ptValue] || [];
            if (keywords.some(kw => entityLower.includes(kw))) {
              console.log(`[QueryEngine] ğŸ§¹ CLEARING project_type="${ptValue}" - term found in entity name "${orgTerm}"`);
              delete args.project_type;
              delete args._project_type_explicit;
            }
          }
          
          // ALSO CLEAR categories if entity name contains category keywords
          if (args.categories && Array.isArray(args.categories) && orgTerm) {
            const catKeywordMap: Record<string, string[]> = {
              'Transportation': ['airport', 'airports', 'aviation', 'transit', 'railway', 'airline', 'port'],
              'Healthcare': ['hospital', 'hospitals', 'medical', 'health', 'clinic'],
              'Education': ['school', 'schools', 'university', 'college', 'academy'],
              'Government': ['government', 'civic', 'municipal', 'federal', 'state']
            };
            const entLower = orgTerm.toLowerCase();
            const cleanedCats = args.categories.filter((cat: string) => {
              const kws = catKeywordMap[cat] || [];
              const hasKw = kws.some(k => entLower.includes(k));
              if (hasKw) {
                console.log(`[SmartOrg] ğŸ§¹ Removing category="${cat}" - keyword in entity "${orgTerm}"`);
                return false;
              }
              return true;
            });
            if (cleanedCats.length === 0) {
              delete args.categories;
              console.log(`[SmartOrg] âœ… All categories cleared for entity "${orgTerm}"`);
            } else if (cleanedCats.length !== args.categories.length) {
              args.categories = cleanedCats;
            }
          }
        } else {
          // No clear match, use 4-column search
          console.log(`[QueryEngine] ğŸ¢ ORGANIZATION DIRECT: Enabling 4-column filter for organization="${args.organization}"`);
          args._organization_override = true;
          args._smart_detection_done = true;
        }
      }
      // GUARD: When organization is set directly (without company conversion), ensure 4-column filter is used
      // This handles cases where LLM sets organization directly without going through company
      if (functionName === 'get_projects_by_combined_filters' && args.organization && !args._organization_override) {
        console.log(`[QueryEngine] ğŸ¢ ORGANIZATION DIRECT: Enabling 4-column filter for organization="${args.organization}"`);
        args._organization_override = true;
      }

      
      console.log(`[DEBUG] COMPREHENSIVE CHECK: entityVal=${args.organization || args.client || args.company}, hasCategories=${args.categories?.length}`);

      // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
      // COMPREHENSIVE ENTITY-CATEGORY CLEANUP: Run after all organization/client/company conversions
      // This catches cases where LLM sets categories that conflict with entity name keywords
      // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
      const entityVal = args.organization || args.client || args.company;
      if (entityVal && args.categories && Array.isArray(args.categories)) {
        const entityLower = entityVal.toLowerCase();
        const categoryKeywordMap: Record<string, string[]> = {
          'Transportation': ['airport', 'airports', 'aviation', 'transit', 'railway', 'airline', 'port'],
          'Healthcare': ['hospital', 'hospitals', 'medical', 'health', 'clinic'],
          'Education': ['school', 'schools', 'university', 'college', 'academy'],
          'Government': ['government', 'civic', 'municipal', 'federal', 'state']
        };
        const cleanedCategories = args.categories.filter((cat: string) => {
          const keywords = categoryKeywordMap[cat] || [];
          const hasKeyword = keywords.some(kw => entityLower.includes(kw));
          if (hasKeyword) {
            console.log(`[EntityCategoryCleanup] ğŸ§¹ Removing category="${cat}" - keyword found in entity "${entityVal}"`);
            return false;
          }
          return true;
        });
        if (cleanedCategories.length === 0) {
      
       // Also remove singular form
          console.log(`[EntityCategoryCleanup] âœ… All categories removed for entity "${entityVal}"`);
        } else if (cleanedCategories.length !== args.categories.length) {
          args.categories = cleanedCategories;
          console.log(`[EntityCategoryCleanup] âœ… Categories cleaned to: ${JSON.stringify(cleanedCategories)}`);
        }
      }

      // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
      // KEYWORD RECOVERY: Extract full phrase from question for keyword searches
      // This handles cases where LLM extraction returns a shorter version
      // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
      if (functionName === 'search_projects_by_keyword' && userQuestion) {
        // Extract entity from question by removing common query words
        let extractedKeyword = userQuestion
          .replace(/\b(show|display|list|get|find|search|all|the|projects?|data|for|of|with|from|by|me|give|provide)\b/gi, '')
          .replace(/\s+/g, ' ')
          .trim();
        // Strip any surrounding quotes
        extractedKeyword = extractedKeyword.replace(/^["']+|["']+$/g, '');
        
        // COLUMN KEYWORD CLEANUP: If the keyword starts with a column keyword like "title", "company", etc.
        // extract only the value that follows (the actual search term)
        const columnKeywordPrefixes = /^(?:title|client|company|module|sector|category|division|department|region|state|country|details|info|information)\s+/i;
        if (columnKeywordPrefixes.test(extractedKeyword)) {
          extractedKeyword = extractedKeyword.replace(columnKeywordPrefixes, '').trim();
          console.log(`[KEYWORD RECOVERY] Stripped column keyword prefix, now: "${extractedKeyword}"`);
        }
        
        // Use the extracted keyword if:
        // 1. args.keyword is not set, OR
        // 2. The extracted version is longer (contains more context from user question)
        const currentKeyword = args.keyword || '';
        if (extractedKeyword.length > 2 && extractedKeyword.length > currentKeyword.length) {
          console.log(`[processQuery] ğŸ”§ KEYWORD RECOVERY: Using full phrase "${extractedKeyword}" instead of "${currentKeyword}"`);
          args.keyword = extractedKeyword;
          
          // Clear project_type if it's contained within the keyword
          if (args.project_type && typeof args.project_type === 'string' && 
              extractedKeyword.toLowerCase().includes(args.project_type.toLowerCase())) {
            console.log(`[processQuery] ğŸ§¹ CLEARING project_type "${args.project_type}" - it's part of keyword`);
            delete args.project_type;
            delete args._project_type_explicit;
          }
        }
      }
      
      // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
      // KEYWORD SEARCH GUARD: Check if keyword matches a database column better than Title/Description
      // This runs column detection for search_projects_by_keyword queries to route to best column
      // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
      if (functionName === 'search_projects_by_keyword' && args.keyword && !args._keyword_column_checked) {
        const keywordTerm = args.keyword;
        const columnMatch = await this.detectBestMatchingColumn(keywordTerm, externalDbQuery);
        if (columnMatch && columnMatch.count > 0) {
          console.log(`[QueryEngine] ğŸ” KEYWORD COLUMN DETECTION: "${keywordTerm}" â†’ ${columnMatch.column} (${columnMatch.count} matches)`);
          // Route to the best matching column function instead of keyword search
          functionName = columnMatch.functionName;
          args[columnMatch.paramName] = keywordTerm;
          // Only delete keyword if routing to a different column (not keyword/title)
          if (columnMatch.paramName !== 'keyword') {
            delete args.keyword;
          }
          // Mark as already applied to prevent double-filtering
          if (columnMatch.paramName === 'poc') {
            args._poc_already_applied = true;
          } else if (columnMatch.paramName === 'company') {
            args._company_already_applied = true;
          } else if (columnMatch.paramName === 'city') {
            args._city_already_applied = true;
          }
        }
        args._keyword_column_checked = true;
      }
      
      // CLEANUP: Strip generic words like "Company", "Client", "projects" from organization names
      // These words are often included by users but should not be part of the search term
      if (args.organization && typeof args.organization === "string") {
        const originalOrg = args.organization;
        const GENERIC_WORDS = [" company", " client", " clients", " project", " projects", " corp", " corporation", " inc", " llc", " ltd", " limited", " group", " the"];
        let cleanedOrg = args.organization;
        for (const word of GENERIC_WORDS) {
          // Case-insensitive removal at end of string
          const regex = new RegExp(word + "$", "i");
          cleanedOrg = cleanedOrg.replace(regex, "");
        }
        cleanedOrg = cleanedOrg.trim();
        if (cleanedOrg !== originalOrg && cleanedOrg.length >= 2) {
          console.log(`[QueryEngine] ğŸ§¹ ORGANIZATION CLEANUP: "${originalOrg}" â†’ "${cleanedOrg}" (stripped generic suffix)`);
          args.organization = cleanedOrg;
        }
      }
      
      // CLEANUP: When organization filter is active, remove filters that appear to be artifacts
      // of the organization name (e.g., "New York" from "New York State Office of General Services")
      if (args._organization_override && args.organization && args.organization.length > 20) {
        const orgNameLower = args.organization.toLowerCase();
        
        // Remove state_code if it appears to be extracted from the organization name
        if (args.state_code) {
          const stateValue = String(args.state_code).toLowerCase();
          if (orgNameLower.includes(stateValue)) {
            console.log(`[QueryEngine] ğŸ§¹ CLEANUP: Removing state_code="${args.state_code}" (contained in organization name)`);
            delete args.state_code;
            delete args.states;
          }
        }
        
        // Remove project_type if it appears to be extracted from the organization name
        if (args.project_type) {
          const ptValue = String(args.project_type).toLowerCase();
          // Check if project_type value is contained in organization name
          if (orgNameLower.includes(ptValue) || orgNameLower.includes(ptValue.replace(/ /g, ""))) {
            console.log(`[QueryEngine] ğŸ§¹ CLEANUP: Removing project_type="${args.project_type}" (contained in organization name)`);
            delete args.project_type;
            delete args._project_type_explicit;
          }
        }
      }
      // Uses the generic detectBreakdownPattern function to handle ANY "by <column>" pattern
      // This runs AFTER all preprocessing to ensure the override is not overwritten
      const breakdownFunctionsForFinalCheck = [
        'get_division_breakdown', 'get_department_breakdown', 
        'get_revenue_by_division', 'get_revenue_by_department',
        'compare_divisions', 'compare_departments', 'get_category_breakdown',
        'get_project_type_breakdown', 'get_status_breakdown', 'get_top_clients',
        'compare_companies', 'get_top_pocs', 'get_size_distribution',
        'compare_years', 'get_revenue_by_month', 'get_revenue_by_state',
        'compare_states', 'compare_regions'
      ];
      
      // Use generic breakdown detection instead of hardcoded division/department only
      const { breakdownColumn: finalBreakdownCol, breakdownFunction: finalBreakdownFn } = detectBreakdownPattern(userQuestion);
      
      // DISAMBIGUATION GUARD: Skip final breakdown if disambiguation is locked
      const skipFinalBreakdown = args._disambiguation_locked || args._client_already_applied || args._company_already_applied || args._poc_already_applied || args._title_already_applied;
      if (finalBreakdownFn && !skipFinalBreakdown && !breakdownFunctionsForFinalCheck.includes(functionName)) {
        console.log(`[QueryEngine] ğŸ” GENERIC BREAKDOWN OVERRIDE (Final): Query has "by ${finalBreakdownCol}" - forcing ${finalBreakdownFn} instead of ${functionName}`);
        functionName = finalBreakdownFn;
        
        // Clean up the column value if it was incorrectly extracted as a filter
        if (finalBreakdownCol && args[finalBreakdownCol]) {
          console.log(`[QueryEngine] ğŸ§¹ Removing ${finalBreakdownCol} filter for breakdown query`);
          delete args[finalBreakdownCol];
        }
      }
      
      // Also apply generic garbage cleanup to args
      // IMPORTANT: Must delete garbage keys, not just copy cleaned values
      // CRITICAL FIX: Preserve poc and _poc_already_applied before garbage cleanup
      console.log(`[QueryEngine] ğŸ” PRESERVATION CHECK: args.poc=${args.poc}, typeof args.poc=${typeof args.poc}, args exists=${!!args}`);
      // If args.poc is a valid string, set the flag immediately to ensure skipUnrecognizedCheck works
      if (args.poc && typeof args.poc === "string") {
        args._poc_already_applied = true;
        console.log(`[QueryEngine] ğŸ” POC PRESERVATION: Setting _poc_already_applied=true for poc="${args.poc}"`);
      }
      // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
      // DISAMBIGUATION FLOW: When company is set but not verified by smart detection
      // Offer user clickable options to specify which column they meant
      // GUARD: Skip if _company_already_applied (user explicitly selected Company column via disambiguation)
      // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
      if (args.company && typeof args.company === "string" && !args._smart_detection_done && !args.client && !args._company_already_applied) {
        const entityValue = args.company;
        console.log(`[QueryEngine] ğŸ¤” DISAMBIGUATION CHECK: company="${entityValue}" not verified, checking all columns...`);
        
        const allMatches = await this.detectAllMatchingColumns(entityValue, externalDbQuery);
        console.log(`[QueryEngine] ğŸ” Found ${allMatches.length} columns with matches for "${entityValue}"`);
        
        // If we found matches, check if we should disambiguate or auto-select
        if (allMatches.length > 0) {
          const topMatch = allMatches[0];
          
          // If only one column has matches OR top match has significantly more, auto-select
          if (allMatches.length === 1 || (allMatches.length > 1 && topMatch.count > allMatches[1].count * 2)) {
            console.log(`[QueryEngine] âœ… AUTO-SELECT: Using ${topMatch.column} (${topMatch.count} matches)`);
            delete args.company;
            args[topMatch.paramName] = entityValue;
            if (topMatch.paramName === 'client') {
              delete args.company; // Remove company filter when switching to client
              functionName = 'get_projects_by_client';
              args._client_already_applied = true;
            }
            args._smart_detection_done = true;
          } else {
            // Multiple columns with similar match counts - ask user to clarify
            console.log(`[QueryEngine] ğŸ¯ DISAMBIGUATION NEEDED: Multiple columns with similar counts`);
            const queryRefNumber = `Q${Date.now().toString(36).toUpperCase()}${Math.random().toString(36).substring(2, 6).toUpperCase()}`;
            
            return {
              success: true,
              question: userQuestion,
              function_name: 'disambiguation',
              arguments: args,
              data: [{
                type: 'disambiguation',
                narrative: `As I am RMOne agent trained on millions of parameters, I found "${entityValue}" in multiple places. Could you please verify which one you meant?`,
                search_term: entityValue,
                options: allMatches.map(m => ({
                  column: m.column,
                  displayName: m.displayName,
                  count: m.count,
                  value: entityValue,
                  paramName: m.paramName,
                  functionName: m.functionName
                })),
                query_reference: queryRefNumber
              }],
              row_count: 0,
              summary: {},
              chart_config: null,
              message: 'Disambiguation needed',
            };
          }
        }
      }
      if (args.company && typeof args.company === "string") {
        args._company_already_applied = true;
        console.log(`[QueryEngine] ğŸ” COMPANY PRESERVATION: Setting _company_already_applied=true for company="${args.company}"`);
      }
      // ENHANCED CLIENT PRESERVATION: Protect organization-indicator clients from being deleted
      if (args.client && typeof args.client === "string") {
        const orgIndicatorsClient = /\b(company|corporation|corp|inc|llc|ltd|group|authority|agency|district|foundation|hospital|airports?|university|college|school|transit|metro|mta|port|center|institute|department|office|service|board|commission)\b/i;
        const hasOrgIndicator = orgIndicatorsClient.test(args.client);
        
        args._client_already_applied = true;
        
        if (hasOrgIndicator) {
          // Mark this client as an organization name that should NEVER be deleted
          args._org_indicator_client = true;
          console.log(`[QueryEngine] ğŸ” ORG-INDICATOR CLIENT: Locking client="${args.client}" (contains org indicator)`);
          
          // REGION DUPLICATE CLEANUP: If region is a substring of client name, remove it
          // E.g., client="Abu Dhabi Airports Company" and region="Abu Dhabi" â†’ remove region
          if (args.region && typeof args.region === 'string') {
            const clientLower = args.client.toLowerCase();
            const regionLower = args.region.toLowerCase();
            if (clientLower.includes(regionLower)) {
              console.log(`[QueryEngine] ğŸ§¹ REGION DUPLICATE CLEANUP: Removing region="${args.region}" (substring of client name)`);
              delete args.region;
            }
          }
        } else {
          console.log(`[QueryEngine] ğŸ” CLIENT PRESERVATION: Setting _client_already_applied=true for client="${args.client}"`);
        }
      }

      const ENTITY_PARAMS_FINAL = [
        'division', 'department', 'client', 'company', 'poc', 'status',
        'category', 'project_type', 'state', 'state_code', 'keyword',
        'sector', 'region', 'office', 'group'
      ];
      const cleanedArgs = cleanupGarbageValues(args, userQuestion);
      console.log(`[QueryEngine] DEBUG: BEFORE cleanup: args.client="${args.client}", AFTER cleanup: cleanedArgs.client="${cleanedArgs.client}"`);
      for (const param of ENTITY_PARAMS_FINAL) {
        if (args[param] !== undefined && cleanedArgs[param] === undefined) {
          console.log(`[QueryEngine] ğŸ§¹ Final cleanup: deleting ${param}="${args[param]}"`);
          delete args[param];
        }
      }
      Object.assign(args, cleanedArgs);

      // SECOND PRESERVATION: Ensure _poc_already_applied is set after Object.assign
      // This catches cases where cleanedArgs might have overwritten it
      if (args.poc && typeof args.poc === "string" && !args._poc_already_applied) {
        args._poc_already_applied = true;
        console.log(`[QueryEngine] ğŸ” POST-CLEANUP PRESERVATION: Setting _poc_already_applied=true for poc="${args.poc}"`);
      }
      console.log(`[QueryEngine] ğŸ” PRE-SKIP DEBUG: poc=${args.poc}, _poc_already_applied=${args._poc_already_applied}, company=${args.company}, organization=${args.organization}`);
      // Step 2.6: UNRECOGNIZED FILTER DETECTION
      // Check if user mentioned a filter term that wasn't recognized (e.g., "in xx", "xx projects")
      // Trigger friendly fallback if user specified an unknown category/entity
      console.log(`[QueryEngine] ğŸ” SKIP DEBUG: poc=${args.poc}, _poc_already_applied=${args._poc_already_applied}, company=${args.company}`);
      const skipUnrecognizedCheck = (args.modules && Array.isArray(args.modules) && args.modules.length > 0) || (args.regions && Array.isArray(args.regions) && args.regions.length > 0) || (args.project_type && typeof args.project_type === 'string') || (args.organization && typeof args.organization === 'string') || (args._poc_already_applied === true) || (args.poc && typeof args.poc === 'string') || (args.company && typeof args.company === 'string') || (args._company_already_applied === true) || (args.service_type && typeof args.service_type === 'string') || (args._service_type_already_applied === true) || (args._keyword_already_applied === true) || (args.keyword && typeof args.keyword === 'string');
      console.log(`[QueryEngine] ğŸ” SKIP CHECK RESULT: skipUnrecognizedCheck=${skipUnrecognizedCheck}`);
      console.log(`[QueryEngine] ğŸ” SKIP CHECK DEBUG: keyword="${args.keyword}", _keyword_already_applied=${args._keyword_already_applied}`);
      // HARD KEYWORD BYPASS: Force skip when keyword is set
      const hasKeyword = args.keyword && typeof args.keyword === 'string' && args.keyword.length > 3;
      const effectiveSkip = skipUnrecognizedCheck || hasKeyword;
      if (hasKeyword && !skipUnrecognizedCheck) {
        console.log(`[QueryEngine] ğŸ”‘ HARD KEYWORD BYPASS ACTIVATED: keyword="${args.keyword}"`);
      }
      if (effectiveSkip) {
        const skipReason = args.regions?.length > 0 ? `regions: ${args.regions.join(", ")}` : args.organization ? `organization: ${args.organization}` : args._poc_already_applied || args.poc ? `poc: ${args.poc || 'applied'}` : args.company || args._company_already_applied ? `company: ${args.company || 'applied'}` : `project_type: ${args.project_type}`;
        console.log(`[QueryEngine] ğŸ—ºï¸ SKIPPING detectUnrecognizedFilterTerm - ${skipReason}`);
      }
      const unrecognizedFilterCheck = effectiveSkip ? { hasUnrecognizedTerm: false } : this.detectUnrecognizedFilterTerm(userQuestion, args);
      if (unrecognizedFilterCheck.hasUnrecognizedTerm && !args._category_already_applied && !(args.categories?.length || args.category)) {
        console.log(`[QueryEngine] âš ï¸ Unrecognized filter term detected: "${unrecognizedFilterCheck.term}" (type: ${unrecognizedFilterCheck.filterType})`);
        console.log(`[TRACE] At KEYWORD CHECK: args.keyword="${args.keyword}", type=${typeof args.keyword}, len=${args.keyword?.length || 0}`);
        // KEYWORD BYPASS: If keyword is set, IMMEDIATELY execute and return
        if (args.keyword && typeof args.keyword === 'string' && args.keyword.length > 3) {
          console.log(`[QueryEngine] ğŸ”‘ KEYWORD BYPASS FORCE EXECUTE: keyword="${args.keyword}"`);
          const keywordResults = await this.executeQuery(functionName, args, externalDbQuery, userQuestion);
          return {
            success: true,
            question: userQuestion,
            function_name: functionName,
            arguments: args,
            data: keywordResults.data || [],
            row_count: keywordResults.row_count || 0,
            summary: keywordResults.summary || {},
            chart_config: keywordResults.chart_config || null,
            message: keywordResults.message || "Query executed via keyword bypass",
            sql_query: keywordResults.sql_query,
            sql_params: keywordResults.sql_params,
          };
        } else if (args.poc || args.company || args.organization || args.client || args.project_name || args._poc_already_applied || args._company_already_applied || args._client_already_applied || args._keyword_already_applied) {
          console.log(`[QueryEngine] ğŸš€ ENTITY GUARD: Skipping fallback block (poc=${args.poc}, company=${args.company}, project_name=${args.project_name})`);
          // Continue to executeQuery - do NOT return fallback
        } else {
          // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
          // FALLBACK DISAMBIGUATION: Before returning fallback, try to extract entity and disambiguate
          // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
          const entityMatches = userQuestion.match(/(?:city of |client |for )([A-Za-z][A-Za-z\s]{2,30})(?:\s+projects?|\s+client|$)/i);
          if (entityMatches && entityMatches[1]) {
            const extractedEntity = entityMatches[1].trim();
            console.log(`[QueryEngine] ğŸ” FALLBACK DISAMBIGUATION: Extracted entity "${extractedEntity}" from question`);
            const allColumnMatches = await this.detectAllMatchingColumns(extractedEntity, externalDbQuery);
            if (allColumnMatches.length > 0) {
              const topMatch = allColumnMatches[0];
              if (allColumnMatches.length > 1 && allColumnMatches[1].count > topMatch.count / 2) {
                console.log(`[QueryEngine] ğŸ”€ FALLBACK DISAMBIGUATION: Multiple columns match, returning options`);
                return {
                  success: true,
                  question: userQuestion,
                  function_name: 'disambiguation_required',
                  arguments: args,
                  data: [{
                    type: 'disambiguation',
                    entity: extractedEntity,
                    columns: allColumnMatches,
                    message: `I found "${extractedEntity}" in multiple places. Which type of question would you like to ask?`
                  }],
                  row_count: 0,
                  summary: {},
                  chart_config: null,
                  message: 'disambiguation_required'
                };
              } else {
                console.log(`[QueryEngine] âœ… FALLBACK DISAMBIGUATION: Auto-selecting ${topMatch.column} for "${extractedEntity}"`);
                args[topMatch.paramName] = extractedEntity;
                args._smart_detection_done = true;
                const newFunctionName = topMatch.functionName;
                const results = await this.executeQuery(newFunctionName, args, externalDbQuery, userQuestion);
                return {
                  ...results,
                  question: userQuestion,
                  function_name: newFunctionName,
                  arguments: args,
                };
              }
            }
          }
          // Generate a query reference and return the friendly fallback
          console.log(`[CRITICAL FALLBACK] keyword="${args.keyword}", _keyword_already_applied=${args._keyword_already_applied}, unrecognizedTerm="${unrecognizedFilterCheck.term}"`);
          
          // ABSOLUTE FINAL KEYWORD GUARD: If keyword is set, NEVER return fallback
          if (args.keyword && typeof args.keyword === 'string' && args.keyword.length > 3) {
            console.log(`[CRITICAL] KEYWORD GUARD AT FALLBACK: Skipping fallback for keyword="${args.keyword}"`);
            // Fall through to executeQuery - do NOT return fallback
          } else {
            const queryRefNumber = `Q${Date.now().toString(36).toUpperCase()}${Math.random().toString(36).substring(2, 6).toUpperCase()}`;
            const fallbackMessage = `Great question! I need to talk to my creators to ensure that I have the right answer for you. Query # ${queryRefNumber}`;
          
            return {
              success: true,
              question: userQuestion,
              function_name: functionName,
              arguments: args,
              _debug_at_fallback: {
                keyword_at_check: args.keyword,
                keyword_type: typeof args.keyword,
                keyword_len: args.keyword?.length || 0,
                unrecognizedTerm: unrecognizedFilterCheck.term,
                hasUnrecognizedTerm: unrecognizedFilterCheck.hasUnrecognizedTerm
              },
              data: [{
                type: "ai_analysis",
                narrative: fallbackMessage,
                aggregates: { count: 0, totalFee: 0, avgFee: 0 },
                samples: [],
                question: userQuestion,
                is_fallback: true,
                query_reference: queryRefNumber,
                unrecognized_term: unrecognizedFilterCheck.term
              }],
              row_count: 0,
              summary: {},
              chart_config: null,
              message: "Query needs review",
              ai_insights: fallbackMessage,
              sql_query: undefined,
              sql_params: undefined,
            };
          }
        }
      }

      // Step 3: Execute query
      console.log(`[DEBUG] â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•`);
      console.log(`[DEBUG] BEFORE executeQuery:`);
      console.log(`[DEBUG]   functionName = ${functionName}`);
      console.log(`[DEBUG]   args = ${JSON.stringify(args, null, 2)}`);
      console.log(`[DEBUG] â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•`);
      
      // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
      // PROJECT_NAME REROUTING: When LLM returns project_name with get_project_by_id,
      // reroute to search_projects_by_keyword since get_project_by_id expects PIDs, not names
      // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
      if (functionName === 'get_project_by_id' && args.project_name && !args.pid_start && !args.pid_end) {
        console.log(`[QueryEngine] ğŸ”„ PROJECT_NAME REROUTING: get_project_by_id â†’ search_projects_by_keyword (project_name="${args.project_name}")`);
        // Run column detection to find which column contains this entity
        const allColumnMatches = await this.detectAllMatchingColumns(args.project_name, externalDbQuery);
        const matchingColumns = allColumnMatches.filter(m => m.count > 0);
        
        if (matchingColumns.length > 1) {
          // Multiple columns have matches - show disambiguation
          console.log(`[QueryEngine] ğŸ”€ PROJECT_NAME DISAMBIGUATION: Found ${matchingColumns.length} columns with matches`);
          return {
            success: true,
            question: userQuestion,
            function_name: 'disambiguation_required',
            arguments: args,
            data: [{
              type: 'disambiguation',
              searchTerm: args.project_name,
              columns: matchingColumns.map(m => ({
                column: m.column,
                displayName: m.displayName || m.column,
                count: m.count,
                value: args.project_name,
                paramName: m.paramName,
                functionName: m.functionName
              }))
            }],
            row_count: 0,
            summary: {},
            chart_config: null,
            message: `"${args.project_name}" was found in multiple columns. Please select which column to search:`,
            _disambiguation_pending: true
          };
        } else if (matchingColumns.length === 1) {
          // Single column has matches - auto-execute with that column
          const match = matchingColumns[0];
          console.log(`[QueryEngine] âœ… PROJECT_NAME AUTO-EXECUTE: "${args.project_name}" â†’ ${match.column} (${match.count} matches)`);
          args[match.paramName] = args.project_name;
          delete args.project_name;
          functionName = match.functionName;
        } else {
          // No matches found - try keyword search as last resort
          console.log(`[QueryEngine] âš ï¸ PROJECT_NAME NO COLUMN MATCH: Trying keyword search`);
          args.keyword = args.project_name;
          delete args.project_name;
          functionName = 'search_projects_by_keyword';
        }
      }
      
      // POST-NORMALIZATION GUARD: Route ai_fallback to proper function after normalization
      // This catches cases where project_type is set via normalization (e.g., "Road/Highway" â†’ "Transportation")
      if (functionName === 'ai_fallback' && args.project_type && !args.division && !args.divisions) {
        console.log(`[QueryEngine] ğŸ—ï¸ POST-NORM PROJECT_TYPE GUARD: ai_fallback â†’ get_projects_by_project_type (project_type=${args.project_type})`);
        functionName = 'get_projects_by_project_type';
      }
      // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
      // DEFENSIVE CLIENT RESTORATION: Restore preserved client if lost during processing
      // Also handle organization cleanup for combined_filters case
      // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
      if (args._preserved_client && !args.client && functionName === 'get_projects_by_client') {
        // Clean up common LLM prefixes like "Client X" â†’ "X"
        let cleanedClient = args._preserved_client.replace(/^Client\s+/i, '').trim();
        console.log(`[QueryEngine] ğŸ”„ CLIENT RESTORATION: Restoring client="${cleanedClient}" (original="${args._preserved_client}", cleaned)`);
        args.client = cleanedClient;
        args._client_restored = true;
      }
      
      // Clean up organization value if it has "Client " prefix (indicates it was a client, not org)
      if (args.organization && typeof args.organization === 'string') {
        const orgValue = args.organization;
        if (/^Client\s+/i.test(orgValue)) {
          const cleanedOrg = orgValue.replace(/^Client\s+/i, '').trim();
          console.log(`[QueryEngine] ğŸ§¹ ORGANIZATION CLEANUP: Removing "Client " prefix from organization="${orgValue}" â†’ "${cleanedOrg}"`);
          args.organization = cleanedOrg;
        }
      }
      
      console.log(`[DEBUG] JUST BEFORE executeQuery: args.client=${args.client}, args.company=${args.company}, args.organization=${args.organization}`);
      
      // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
      // CRITICAL KEYWORD RECOVERY: Ensure keyword is set BEFORE executeQuery
      // This must run here because the keyword param building happens inside executeQuery
      // and we need args.keyword to be populated when cleanedArgsForExecute is created
      // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
      if (functionName === 'search_projects_by_keyword' && args._keyword_already_applied && !args.keyword) {
        // Extract keyword from question by removing common query words
        let extractedKeyword = userQuestion
          .replace(/\b(show|display|list|get|find|search|all|the|projects?|data|for|of|with|from|by|me|give|provide|to)\b/gi, '')
          .replace(/\s+/g, ' ')
          .trim();
        // Strip surrounding quotes
        extractedKeyword = extractedKeyword.replace(/^["']+|["']+$/g, '');
        if (extractedKeyword.length > 2) {
          console.log(`[processQuery] ğŸ”§ PRE-EXECUTE KEYWORD RECOVERY: Setting keyword="${extractedKeyword}"`);
          args.keyword = extractedKeyword;
        }
      }
      
      // FINAL HALLUCINATION GUARD: Strip geography args reintroduced by context merge
      const cleanedArgsForExecute = stripHallucinatedGeography(args, userQuestion);
      console.log(`[CATEGORY_TRACE] PRE-EXECUTE: args.category="${args.category}", cleanedArgs.category="${cleanedArgsForExecute.category}", fn="${functionName}"`);
      const results = await this.executeQuery(functionName, cleanedArgsForExecute, externalDbQuery, userQuestion);
      console.log(`[DEBUG] results.success=${results.success}, error=${results.error}`);
      if (!results.success) {
      }
      if (!results.success) {
        // Convert technical errors to user-friendly messages
        const errorMessage = results.error || "Query execution failed";
        
        // Treat "not found" and "no data" errors as AI fallback opportunity
        if (
          errorMessage.includes("not found") ||
          errorMessage.includes("has no") ||
          errorMessage.includes("No data available") ||
          errorMessage.includes("No projects found")
        ) {
          // CRITICAL FIX: For valid entity queries, return clean "no results" instead of fallback
          // Define isValidEntityQuery to include ALL entity types (poc, company, client, keyword, project_type, etc.)
          const entityFunctionNames = ['get_projects_by_project_type', 'get_projects_by_poc', 'search_projects_by_keyword', 'get_projects_by_combined_filters', 'get_projects_by_client', 'get_projects_by_company'];
          const isEntityFunction = entityFunctionNames.includes(functionName);
          const isValidEntityQuery = isEntityFunction || !!(
            args.poc || args.company || args.organization || args.client || args.keyword || args.project_type ||
            args._poc_already_applied || args._company_already_applied || args._client_already_applied || 
            args._keyword_already_applied || args._project_type_already_applied
          );
          console.log(`[QueryEngine] ğŸ¯ REACHED ENTITY CHECK: args.poc=${args.poc}, args._poc_already_applied=${args._poc_already_applied}, args.project_type=${args.project_type}`);
          console.log(`[QueryEngine] ğŸ¯ isValidEntityQuery = ${isValidEntityQuery}`);
          
          if (isValidEntityQuery) {
            const entityType = args.poc ? 'POC' : args.company ? 'company' : args.project_type ? 'project type' : args.keyword ? 'title/keyword' : args.client ? 'client' : 'organization';
            const entityValue = args.poc || args.company || args.project_type || args.keyword || args.client || args.organization || 'specified entity';
            const filterDesc = [
              args.status ? (Array.isArray(args.status) ? `Status: ${args.status.join(', ')}` : `Status: ${args.status}`) : null,
              args.start_date && args.end_date ? `Date: ${args.start_date} to ${args.end_date}` : null,
              args.year ? `Year: ${args.year}` : null,
            ].filter(Boolean).join(', ');
            
            const noResultsMessage = filterDesc 
              ? `No projects found for ${entityType} "${entityValue}" matching your filters (${filterDesc}).`
              : `No projects found for ${entityType} "${entityValue}".`;
            
            return {
              success: true,
              question: userQuestion,
              function_name: functionName,
              arguments: args,
              data: [{
                type: 'ai_analysis',
                narrative: noResultsMessage,
                aggregates: { count: 0, totalFee: 0, avgFee: 0 },
                samples: [],
                question: userQuestion,
                is_empty_result: true,
              }],
              row_count: 0,
              summary: {},
              chart_config: null,
              message: noResultsMessage,
              sql_query: results.sql_query,
              sql_params: results.sql_params,
            };
          }
          
          console.log(`[QueryEngine] ğŸ”„ No results - triggering AI fallback`);
          const fallbackResult = await this.handleAIFallback(
            userQuestion,
            'no_results',
            {
              attemptedFunction: functionName,
              appliedFilters: args,
              errorMessage: errorMessage,
              previousContext
            },
            externalDbQuery
          );
          
          return {
            success: true,
            question: userQuestion,
            function_name: functionName,
            arguments: args,
            data: fallbackResult.data,
            row_count: 0,
            summary: {},
            chart_config: null,
            message: fallbackResult.message || "AI provided helpful guidance",
            sql_query: results.sql_query,
            sql_params: results.sql_params,
          };
        }
        
        // For execution errors, try AI fallback
        // NOTE: Do NOT return clean "no results" for execution errors - these could be real DB/SQL errors
        // that need to surface properly
        // ENTITY GUARD: For POC/company queries, return clean no-results instead of fallback
        // ONLY if the error is a "no data" type error, NOT a genuine SQL/connection error
        const isDataRelatedError = errorMessage.includes("No data") || errorMessage.includes("no data") ||
          errorMessage.includes("No projects") || errorMessage.includes("no results") ||
          errorMessage.includes("No records") || errorMessage.includes("empty") ||
          !errorMessage.includes("SQL") && !errorMessage.includes("connection") && 
          !errorMessage.includes("timeout") && !errorMessage.includes("syntax") &&
          !errorMessage.includes("Invalid") && !errorMessage.includes("Error:");
        const entityFnNames = ['get_projects_by_project_type', 'get_projects_by_poc', 'search_projects_by_keyword', 'get_projects_by_combined_filters', 'get_projects_by_client', 'get_projects_by_company'];
        const isEntityFn = entityFnNames.includes(functionName);
        const isEntityQuery = isEntityFn || !!(args.poc || args.company || args.organization || args.project_type || args.keyword || args.client || args.project_name || args._poc_already_applied || args._company_already_applied || args._project_type_already_applied || args._keyword_already_applied || args._client_already_applied);
        if (isEntityQuery && isDataRelatedError) {
          console.log(`[QueryEngine] ğŸ›¡ï¸ ENTITY GUARD AT EXECUTION_ERROR: Returning clean no-results for entity query (poc=${args.poc}, company=${args.company}, project_type=${args.project_type}, project_name=${args.project_name})`);
          const entityType = args.poc ? "POC" : args.company ? "company" : args.project_type ? "project type" : args.keyword ? "keyword" : args.client ? "client" : args.project_name ? "project name" : "organization";
          const entityValue = args.poc || args.company || args.project_type || args.keyword || args.client || args.project_name || args.organization || "specified entity";
          const filterDesc = [
            args.status ? (Array.isArray(args.status) ? `Status: ${args.status.join(", ")}` : `Status: ${args.status}`) : null,
            args.start_date && args.end_date ? `Date: ${args.start_date} to ${args.end_date}` : null,
            args.year ? `Year: ${args.year}` : null,
          ].filter(Boolean).join(", ");
          const noResultsMessage = filterDesc
            ? `No projects found for ${entityType} "${entityValue}" matching your filters (${filterDesc}).`
            : `No projects found for ${entityType} "${entityValue}".`;
          return {
            success: true,
            question: userQuestion,
            function_name: functionName,
            arguments: args,
            data: [{
              type: "ai_analysis",
              narrative: noResultsMessage,
              aggregates: { count: 0, totalFee: 0, avgFee: 0 },
              samples: [],
              question: userQuestion,
              is_empty_result: true,
            }],
            row_count: 0,
            summary: {},
            chart_config: null,
            message: noResultsMessage,
            sql_query: results.sql_query,
            sql_params: results.sql_params,
          };
        }
        console.log(`[QueryEngine] ğŸ”„ Execution error - triggering AI fallback`);
        const fallbackResult = await this.handleAIFallback(
          userQuestion,
          'execution_error',
          {
            attemptedFunction: functionName,
            appliedFilters: args,
            errorMessage: errorMessage,
            previousContext
          },
          externalDbQuery
        );
        
        return {
          success: true,
          question: userQuestion,
          function_name: functionName,
          arguments: args,
          data: fallbackResult.data,
          row_count: 0,
          summary: {},
          chart_config: null,
          message: fallbackResult.message || "AI provided helpful guidance",
        };
      }
      
      // Check for empty results OR fallback responses - these should return clean 0-results with SQL
      const isEmptyOrFallback = results.data.length === 0 || 
        (results.data.length === 1 && results.data[0]?.is_fallback === true);
      console.log(`[DEBUG] 0-RESULTS CHECK: data.length=${results.data?.length}, is_fallback=${results.data?.[0]?.is_fallback}, isEmptyOrFallback=${isEmptyOrFallback}`);
      if (isEmptyOrFallback) {
        console.log(`[QueryEngine] ğŸ¯ ENTERING 0-RESULTS BLOCK - args.poc=${args.poc}, args.status=${JSON.stringify(args.status)}, previousContext=${!!previousContext}, _disambiguation_column=${!!args._disambiguation_column}`);
        console.log(`[QueryEngine] ğŸ¯ 0-RESULTS DEBUG: project_type=${args.project_type}, _project_type_already_applied=${args._project_type_already_applied}`);
        // EARLY ENTITY CHECK: For POC/company/org queries, return clean "no results" immediately
        // This bypasses all the retry/self-correction logic for entity-based queries
        // FOLLOW-UP CHECK: For follow-up queries with previousContext, return clean no-results with SQL
        // Also check for entity queries with _already_applied flags (these come from disambiguation)
        const isFollowUpQuery = !!(
          previousContext || 
          args._disambiguation_column || 
          args._project_type_already_applied ||
          args._keyword_already_applied ||
          args._company_already_applied ||
          args._poc_already_applied ||
          args._client_already_applied
        );
        console.log(`[QueryEngine] ğŸ” FOLLOW-UP CHECK: previousContext=${!!previousContext}, _project_type_already_applied=${args._project_type_already_applied}, isFollowUpQuery=${isFollowUpQuery}`);
        if (isFollowUpQuery) {
          console.log(`[QueryEngine] âœ… FOLLOW-UP 0-RESULTS: Returning empty result with SQL preserved`);
          const filterDesc = [
            args.status ? (Array.isArray(args.status) ? `Status: ${args.status.slice(0,2).join(", ")}${args.status.length > 2 ? "..." : ""}` : `Status: ${args.status}`) : null,
            args.service_type ? `Service Type: ${args.service_type}` : null,
            args.start_date && args.end_date ? `Date: ${args.start_date} to ${args.end_date}` : null,
          ].filter(Boolean).join(", ");
          const noResultsMessage = filterDesc
            ? `No projects found matching your filters (${filterDesc}).`
            : `No projects found matching your criteria.`;
          return {
            success: true,
            question: userQuestion,
            function_name: functionName,
            arguments: args,
            data: [{
              type: "ai_analysis",
              narrative: noResultsMessage,
              aggregates: { count: 0, totalFee: 0, avgFee: 0 },
              samples: [],
              question: userQuestion,
              is_empty_result: true,
            }],
            row_count: 0,
            summary: {},
            chart_config: null,
            message: noResultsMessage,
            sql_query: results.sql_query,
            sql_params: results.sql_params,
          };
        }
        
        console.log(`[QueryEngine] ğŸ” COLUMN FALLBACK CHECK: poc=${args.poc}, company=${args.company}, org=${args.organization}, keyword=${args.keyword}, project_type=${args.project_type}, project_name=${args.project_name}`);
        const earlyEntityCheck = !!(
          args.poc || args.company || args.organization || args.keyword || args.project_type || args.client || args.project_name ||
          args._poc_already_applied || args._company_already_applied || args._keyword_already_applied || 
          args._project_type_already_applied || args._client_already_applied
        );
        console.log(`[QueryEngine] ğŸ” COLUMN FALLBACK: earlyEntityCheck=${earlyEntityCheck}`);
        if (earlyEntityCheck) {
          // When _keyword_already_applied is true but keyword is undefined, extract entity from question
          let entityValue = args.poc || args.company || args.organization || args.keyword || args.project_name;
          
          if (!entityValue && args._keyword_already_applied) {
            // Extract entity from question text - look for quoted text or noun phrases
            const quotedMatch = userQuestion.match(/"([^"]+)"|'([^']+)'/);
            if (quotedMatch) {
              entityValue = quotedMatch[1] || quotedMatch[2];
            } else {
              // Try to extract main entity by removing common query words
              const cleaned = userQuestion
                .replace(/\b(show|display|list|get|find|search|all|the|projects?|data|for|of|with|from|by)\b/gi, '')
                .trim();
              if (cleaned.length > 2) {
                entityValue = cleaned;
              }
            }
            console.log(`[QueryEngine] ğŸ”§ KEYWORD RECOVERY: Extracted entity "${entityValue}" from question`);
          }
          
          // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
          // COLUMN-BASED FALLBACK: Before returning "no results", try searching all columns
          // This ensures we don't miss matches in other columns
          // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
          if (entityValue && !args._column_fallback_tried) {
            console.log(`[QueryEngine] ğŸ” COLUMN-BASED FALLBACK: 0 results for "${entityValue}" - trying all columns`);
            args._column_fallback_tried = true;
            
            const allColumnMatches = await this.detectAllMatchingColumns(entityValue, externalDbQuery);
            const matchingColumns = allColumnMatches.filter(m => m.count > 0);
            
            if (matchingColumns.length > 1) {
              // Multiple columns have matches - show disambiguation
              console.log(`[QueryEngine] ğŸ”€ COLUMN FALLBACK DISAMBIGUATION: Found ${matchingColumns.length} columns with matches`);
              return {
                function_name: 'disambiguation_required',
                arguments: args,
                row_count: 0,
                message: `"${entityValue}" was found in multiple columns. Please select which column to search:`,
                data: [{
                  type: 'disambiguation',
                  searchTerm: entityValue,
                  columns: matchingColumns.map(m => ({
                    column: m.column,
                    displayName: m.displayName || m.column,
                    count: m.count,
                  value: entityValue,
                    paramName: m.paramName,
                    functionName: m.functionName
                  }))
                }],
                _disambiguation_pending: true
              };
            } else if (matchingColumns.length === 1) {
              // Single column has matches - auto-execute with that column
              const match = matchingColumns[0];
              console.log(`[QueryEngine] âœ… COLUMN FALLBACK AUTO-EXECUTE: "${entityValue}" â†’ ${match.column} (${match.count} matches)`);
              
              // Clear old params and set the correct one
              delete args.poc;
              delete args.company;
              delete args.organization;
              delete args.keyword;
              args[match.paramName] = entityValue;
              
              // Re-execute with correct function
              const retryResult = await this.executeQuery(match.functionName, args, externalDbQuery, previousContext);
              if (retryResult.data && retryResult.data.length > 0) {
                return {
                  success: true,
                  question: userQuestion,
                  function_name: match.functionName,
                  arguments: args,
                  data: retryResult.data,
                  row_count: retryResult.data.length,
                  summary: {},
                  chart_config: null,
                  message: `Found ${retryResult.data.length} results`,
                  sql_query: retryResult.sql_query,
                  sql_params: retryResult.sql_params,
                };
              }
            }
            // If no matches found in any column, continue to show no-results
            console.log(`[QueryEngine] âš ï¸ COLUMN FALLBACK: No matches found in any column for "${entityValue}"`);
          }
          
          console.log(`[QueryEngine] âœ… EARLY ENTITY CHECK: poc=${args.poc}, returning clean no-results`);
          const entityType = args.poc ? "POC" : args.company ? "company" : args.project_type ? "project type" : args.keyword ? "keyword" : args.client ? "client" : "organization";
          const filterDesc = [
            args.status ? (Array.isArray(args.status) ? `Status: ${args.status.join(", ")}` : `Status: ${args.status}`) : null,
            args.start_date && args.end_date ? `Date: ${args.start_date} to ${args.end_date}` : null,
            args.year ? `Year: ${args.year}` : null,
          ].filter(Boolean).join(", ");
          const noResultsMessage = filterDesc
            ? `No projects found for ${entityType} "${entityValue}" matching your filters (${filterDesc}).`
            : `No projects found for ${entityType} "${entityValue}".`;
          return {
            success: true,
            question: userQuestion,
            function_name: functionName,
            arguments: args,
            data: [{
              type: "ai_analysis",
              narrative: noResultsMessage,
              aggregates: { count: 0, totalFee: 0, avgFee: 0 },
              samples: [],
              question: userQuestion,
              is_empty_result: true,
            }],
            row_count: 0,
            summary: {},
            chart_config: null,
            message: noResultsMessage,
            sql_query: results.sql_query,
            sql_params: results.sql_params,
          };
        }
        console.log(`[QueryEngine] ğŸ”„ Empty results - attempting auto-retry with fuzzy matching`);
        
        // Check if this is a category/type-based query that might benefit from auto-retry
        const categoryValue = args.category || args.project_type;
        const isAutoRetryCandidate = categoryValue && !args.__autoRetryPerformed;
        
        if (isAutoRetryCandidate) {
          console.log(`[AutoRetry] Searching for better match for: "${categoryValue}"`);
          
          const bestMatch = await this.findClosestCategoryMatch(categoryValue, externalDbQuery);
          
          if (bestMatch && bestMatch.similarity >= 0.8) {
            console.log(`[AutoRetry] âœ… Found good match: "${bestMatch.match}" (${(bestMatch.similarity * 100).toFixed(1)}%) - retrying query`);
            
            // Build retry arguments with proper typing
            const retryArgs: Record<string, any> = { ...args, __autoRetryPerformed: true };
            
            // Update the category/project_type based on which column matched
            if (bestMatch.column === 'project_type') {
              retryArgs.project_type = bestMatch.match;
              // If original was category, clear it
              if (args.category && !args.project_type) {
                delete retryArgs.category;
              }
            } else {
              retryArgs.category = bestMatch.match;
            }
            
            // Determine the best function to use
            let retryFunctionName = functionName;
            if (bestMatch.column === 'project_type' && functionName.includes('category')) {
              // Switch to project type function if available
              if (functionName === 'get_largest_by_category') {
                // Keep same function - it now checks both columns
              } else if (functionName === 'get_projects_by_category') {
                retryFunctionName = 'get_projects_by_project_type';
              }
            }
            
            console.log(`[AutoRetry] Retrying with function: ${retryFunctionName}, args:`, JSON.stringify(retryArgs));
            
            // Execute retry query using the function execution logic
            const retryResults = await this.executeQuery(retryFunctionName, retryArgs, externalDbQuery, userQuestion);
            
            if (retryResults.data && retryResults.data.length > 0) {
              console.log(`[AutoRetry] âœ… Success! Found ${retryResults.data.length} results`);
              
              // Return the successful retry results
              const chartConfig = this.generateChartConfig(retryResults.data, retryFunctionName);
              const summary = this.calculateSummaryStats(retryResults.data);
              
              return {
                success: true,
                question: userQuestion,
                function_name: retryFunctionName,
                arguments: retryArgs,
                data: retryResults.data,
                row_count: retryResults.data.length,
                summary,
                chart_config: chartConfig,
                message: `Found ${retryResults.data.length} results (matched "${bestMatch.match}")`,
                sql_query: retryResults.sql_query,
                sql_params: retryResults.sql_params,
              };
            } else {
              console.log(`[AutoRetry] âŒ Retry also returned empty results`);
            }
          } else {
            console.log(`[AutoRetry] No sufficiently similar match found (threshold: 80%)`);
          }
        }
        
        // Step 2: Smart filter relaxation - remove non-essential filters and retry
        // This handles cases like "opportunities where Gregory Heinz is contact" 
        // where AI might add extra project_type filter that returns no results
        // IMPORTANT: Do NOT relax if this is a PID-based follow-up query (user said "from these")
        const hasPersonFilter = args.contact || args.poc || args.company || args.client;
        const hasExtraFilters = args.project_type || args.category || args.status;
        const hasPidsConstraint = args.pids && Array.isArray(args.pids) && args.pids.length > 0;
        
        // Skip filter relaxation for PID-based follow-up queries - empty result is valid
        if (hasPidsConstraint) {
          console.log(`[FilterRelax] Skipping - PID constraint present (follow-up query). Empty result is valid.`);
          console.log(`[FilterRelax] User asked about specific ${args.pids.length} projects, none match the criteria.`);
        } else if (args._project_type_explicit) {
          // User explicitly requested a project type (via keyword like "Healthcare") - don't relax this filter
          console.log(`[FilterRelax] Skipping - project_type was explicitly requested by user. Empty result is valid.`);
          console.log(`[FilterRelax] User asked for "${args.project_type}" projects, and there are none matching the criteria.`);
        } else if (hasPersonFilter && hasExtraFilters && !args.__filterRelaxationPerformed) {
          console.log(`[FilterRelax] Detected person-based query with extra filters - attempting relaxation`);
          
          // Build relaxed args keeping only the core person filter
          const relaxedArgs: Record<string, any> = { __filterRelaxationPerformed: true };
          
          // Keep person-related filters
          if (args.contact) relaxedArgs.contact = args.contact;
          if (args.poc) relaxedArgs.poc = args.poc;
          if (args.company) relaxedArgs.company = args.company;
          if (args.client) relaxedArgs.client = args.client;
          
          // Keep essential filters that user likely intended
          if (args.state_code) relaxedArgs.state_code = args.state_code;
          if (args.states) relaxedArgs.states = args.states;
          if (args.min_fee) relaxedArgs.min_fee = args.min_fee;
          if (args.max_fee) relaxedArgs.max_fee = args.max_fee;
          if (args.start_date) relaxedArgs.start_date = args.start_date;
          if (args.end_date) relaxedArgs.end_date = args.end_date;
          if (args.limit) relaxedArgs.limit = args.limit;
          if (args.sort_field) relaxedArgs.sort_field = args.sort_field;
          if (args.sort_direction) relaxedArgs.sort_direction = args.sort_direction;
          // PRESERVE status when user explicitly requested open/closed projects
          if (args.status) relaxedArgs.status = args.status;
          
          const removedFilters = [];
          if (args.project_type) removedFilters.push(`project_type: ${args.project_type}`);
          if (args.category) removedFilters.push(`category: ${args.category}`);
          // Status is now preserved - if (args.status) removedFilters.push(`status: ${args.status}`);
          
          console.log(`[FilterRelax] Removed filters: ${removedFilters.join(', ')}`);
          console.log(`[FilterRelax] Retrying with relaxed args:`, JSON.stringify(relaxedArgs));
          
          try {
            // Use a general search function that works with person filters
            let relaxedFunctionName = 'search_projects';
            
            // If we have contact/poc, use get_projects_by_poc
            if (args.contact || args.poc) {
              relaxedFunctionName = 'get_projects_by_poc';
              // Ensure poc/contact is set correctly
              if (args.contact && !relaxedArgs.poc) {
                relaxedArgs.poc = relaxedArgs.contact;
              }
            }
            
            const relaxedResults = await this.executeQuery(relaxedFunctionName, relaxedArgs, externalDbQuery, userQuestion);
            
            if (relaxedResults.data && relaxedResults.data.length > 0) {
              console.log(`[FilterRelax] âœ… Success! Found ${relaxedResults.data.length} results after removing filters`);
              
              const chartConfig = this.generateChartConfig(relaxedResults.data, relaxedFunctionName);
              const summary = this.calculateSummaryStats(relaxedResults.data);
              
              return {
                success: true,
                question: userQuestion,
                function_name: relaxedFunctionName,
                arguments: relaxedArgs,
                data: relaxedResults.data,
                row_count: relaxedResults.data.length,
                summary,
                chart_config: chartConfig,
                message: `Found ${relaxedResults.data.length} results (broadened search by removing ${removedFilters.join(', ')})`,
                sql_query: relaxedResults.sql_query,
                sql_params: relaxedResults.sql_params,
              };
            } else {
              console.log(`[FilterRelax] âŒ Relaxed query also returned empty results`);
            }
          } catch (relaxError: any) {
            console.log(`[FilterRelax] Error during relaxed retry:`, relaxError.message);
          }
        }
        
        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        // SELF-CORRECTION LOOP: Re-classify with error feedback before fallback
        // This gives the LLM a chance to correct its classification mistake
        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        if (!args.__selfCorrectionPerformed) {
          console.log(`[QueryEngine] ğŸ”„ Attempting self-correction loop...`);
          
          try {
            // Fetch valid database values to help LLM make better choices
            const dbHints = await this.fetchDatabaseHints(externalDbQuery);
            
            // Request re-classification with error feedback
            const correctedClassification = await this.openaiClient.reclassifyWithFeedback(
              userQuestion,
              this.functionDefinitions,
              {
                previousFunction: functionName,
                previousArgs: args,
                errorType: 'no_results',
                errorMessage: `Query returned 0 results with filters: ${JSON.stringify(args)}`,
                databaseHints: dbHints
              }
            );
            
            // Check if correction is meaningful: different function OR different arguments
            const argsChanged = JSON.stringify(correctedClassification.arguments) !== JSON.stringify(args);
            const functionChanged = correctedClassification.function_name !== functionName;
            
            // BREAKDOWN OVERRIDE: Apply same "by division/department" override to self-correction results
            const breakdownFunctionsInSelfCorrect = [
              'get_division_breakdown', 'get_department_breakdown', 
              'get_revenue_by_division', 'get_revenue_by_department'
            ];
            const hasByDivisionSelfCorrect = /\bby\s+(?:the\s+)?division\b/i.test(userQuestion);
            const hasByDepartmentSelfCorrect = /\bby\s+(?:the\s+)?department\b/i.test(userQuestion);
            
            if (hasByDivisionSelfCorrect && !breakdownFunctionsInSelfCorrect.includes(correctedClassification.function_name)) {
              console.log(`[SelfCorrection] ğŸ¢ BREAKDOWN OVERRIDE: Query has "by division" - forcing get_division_breakdown instead of ${correctedClassification.function_name}`);
              correctedClassification.function_name = 'get_division_breakdown';
            } else if (hasByDepartmentSelfCorrect && !breakdownFunctionsInSelfCorrect.includes(correctedClassification.function_name)) {
              console.log(`[SelfCorrection] ğŸ¢ BREAKDOWN OVERRIDE: Query has "by department" - forcing get_department_breakdown instead of ${correctedClassification.function_name}`);
              correctedClassification.function_name = 'get_department_breakdown';
            }
            
            if (correctedClassification.function_name !== 'none' && (functionChanged || argsChanged)) {
              console.log(`[SelfCorrection] ğŸ”„ Trying corrected classification: ${correctedClassification.function_name} (function changed: ${functionChanged}, args changed: ${argsChanged})`);
              
              // IMPORTANT: Preserve inherited context filters that should NOT be discarded
              // e.g., if follow-up is "LFDH NY division" from "healthcare $800M 2026", 
              // we should keep categories, min_fee, dates from original context
              const inheritedFilters: Record<string, any> = {};
              const keysToInherit = ['categories', '_explicit_category', 'min_fee', 'max_fee', 'start_date', 'end_date', 'year', 'status'];
              for (const key of keysToInherit) {
                if (args[key] !== undefined && correctedClassification.arguments[key] === undefined) {
                  inheritedFilters[key] = args[key];
                  console.log(`[SelfCorrection] ğŸ“‹ Preserving inherited filter: ${key} = ${JSON.stringify(args[key])}`);
                }
              }
              
              // Mark as self-corrected to prevent infinite loop, and include inherited filters
              const correctedArgs: Record<string, any> = { 
                ...inheritedFilters,
                ...correctedClassification.arguments, 
                __selfCorrectionPerformed: true 
              };
              
              
              // COMPANY DETECTION GUARD: Override self-correction if user is asking for a known company
              const knownCompaniesInSelfCorrect = new Set(["ais", "gafcon", "gei", "hill", "liro", "palladium", "stobg", "jcm", "l.r. kimball", "lrkimball", "arc-tec", "schipporeit", "rwb", "rwbgroup", "deltek", "ims", "cbl", "cblarchitects", "blw"]);
              const questionWordsLower = userQuestion.toLowerCase();
              let detectedCompanyInSelfCorrect: string | null = null;
              for (const company of Array.from(knownCompaniesInSelfCorrect)) {
                const companyPattern = new RegExp(`\\b${company.replace(/[.*+?^${}()|[\]\\]/g, "\\$&")}\\b`, "i");
                if (companyPattern.test(questionWordsLower)) {
                  detectedCompanyInSelfCorrect = company;
                  break;
                }
              }
              if (detectedCompanyInSelfCorrect) {
                console.log(`[SelfCorrection] ğŸ¢ COMPANY OVERRIDE: Detected company "${detectedCompanyInSelfCorrect}" - forcing organization filter`);
                correctedArgs.organization = detectedCompanyInSelfCorrect;
                correctedArgs._organization_override = true;
                correctedClassification.function_name = "get_projects_by_combined_filters";
                delete correctedArgs.project_type;
                delete correctedArgs.project_types;
                delete correctedArgs.categories;
                delete correctedArgs.keyword;
              }
              // Execute the corrected query
              const correctedResults = await this.executeQuery(
                correctedClassification.function_name,
                correctedArgs,
                externalDbQuery,
                userQuestion
              );
              
              if (correctedResults.data && correctedResults.data.length > 0) {
                console.log(`[SelfCorrection] âœ… Success! Corrected query returned ${correctedResults.data.length} results`);
                
                const chartConfig = this.generateChartConfig(correctedResults.data, correctedClassification.function_name);
                const summary = this.calculateSummaryStats(correctedResults.data);
                
                return {
                  success: true,
                  question: userQuestion,
                  function_name: correctedClassification.function_name,
                  arguments: correctedArgs,
                  data: correctedResults.data,
                  row_count: correctedResults.data.length,
                  summary,
                  chart_config: chartConfig,
                  message: `Found ${correctedResults.data.length} results (auto-corrected)`,
                  sql_query: correctedResults.sql_query,
                  sql_params: correctedResults.sql_params,
                };
              } else {
                console.log(`[SelfCorrection] âŒ Corrected query also returned empty results`);
              }
            } else {
              console.log(`[SelfCorrection] No better classification found`);
            }
          } catch (selfCorrectionError: any) {
            console.log(`[SelfCorrection] Error during self-correction:`, selfCorrectionError.message);
          }
        }
        
        // No auto-retry possible or retry failed
        // CRITICAL FIX: For valid entity-based queries (POC, company, organization),
        // return "No matching projects found" instead of triggering AI fallback
        // This prevents showing "I need to talk to my creators" when the query is valid but has 0 results
        console.log(`[QueryEngine] ğŸ¯ REACHED ENTITY CHECK: args.poc=${args.poc}, args._poc_already_applied=${args._poc_already_applied}, args.project_type=${args.project_type}`);
        const entityFunctionNamesGuard = ['get_projects_by_project_type', 'get_projects_by_poc', 'search_projects_by_keyword', 'get_projects_by_combined_filters', 'get_projects_by_client', 'get_projects_by_company'];
        const isEntityFunctionGuard = entityFunctionNamesGuard.includes(functionName);
        const isValidEntityQuery = isEntityFunctionGuard || !!(
          args.poc || args.company || args.organization || args.client || args.keyword || args.project_type ||
          args._poc_already_applied || args._company_already_applied || args._client_already_applied || 
          args._keyword_already_applied || args._project_type_already_applied
        );
        console.log(`[QueryEngine] ğŸ¯ isValidEntityQuery = ${isValidEntityQuery}`);
        
        if (isValidEntityQuery) {
          console.log(`[QueryEngine] âœ“ Valid entity query with 0 results - returning simple no-results message`);
          const entityType = args.poc ? 'POC' : args.company ? 'company' : args.project_type ? 'project type' : args.keyword ? 'keyword' : args.client ? 'client' : 'organization';
          const entityValue = args.poc || args.company || args.project_type || args.keyword || args.client || args.organization || 'specified entity';
          const filterDesc = [
            args.status ? (Array.isArray(args.status) ? `Status: ${args.status.join(', ')}` : `Status: ${args.status}`) : null,
            args.start_date && args.end_date ? `Date: ${args.start_date} to ${args.end_date}` : null,
            args.start_date && !args.end_date ? `From: ${args.start_date}` : null,
            args.year ? `Year: ${args.year}` : null,
            args.project_type ? `Type: ${args.project_type}` : null,
            args.categories ? `Categories: ${args.categories.join(', ')}` : null,
          ].filter(Boolean).join(', ');
          
          const noResultsMessage = filterDesc 
            ? `No projects found for ${entityType} "${entityValue}" matching your filters (${filterDesc}).`
            : `No projects found for ${entityType} "${entityValue}".`;
          
          return {
            success: true,
            question: userQuestion,
            function_name: functionName,
            arguments: args,
            data: [{
              type: 'ai_analysis',
              narrative: noResultsMessage,
              aggregates: { count: 0, totalFee: 0, avgFee: 0 },
              samples: [],
              question: userQuestion,
              is_empty_result: true,
            }],
            row_count: 0,
            summary: {},
            chart_config: null,
            message: noResultsMessage,
            sql_query: results.sql_query,
            sql_params: results.sql_params,
          };
        }
        
        // Fall back to AI suggestions (with auto-execute) for non-entity queries
        console.log(`[QueryEngine] ğŸ”„ Triggering AI fallback with auto-execute`);
        const fallbackResult = await this.handleAIFallback(
          userQuestion,
          'no_results',
          {
            attemptedFunction: functionName,
            appliedFilters: args,
            previousContext
          },
          externalDbQuery
        );
        
        // Check if fallback auto-executed a successful alternative query
        if (fallbackResult.row_count && fallbackResult.row_count > 0) {
          console.log(`[QueryEngine] âœ… Fallback auto-execute returned ${fallbackResult.row_count} results!`);
          return {
            success: true,
            question: userQuestion,
            function_name: fallbackResult.function_name || functionName,
            arguments: fallbackResult.arguments || args,
            data: fallbackResult.data,
            row_count: fallbackResult.row_count,
            summary: fallbackResult.summary || {},
            chart_config: fallbackResult.chart_config || null,
            message: fallbackResult.message || `Found ${fallbackResult.row_count} results`,
            sql_query: fallbackResult.sql_query,
            sql_params: fallbackResult.sql_params,
          };
        }
        
        // No auto-execute success - return the text-based fallback
        return {
          success: true,
          question: userQuestion,
          function_name: functionName,
          arguments: args,
          data: fallbackResult.data,
          row_count: 0,
          summary: {},
          chart_config: null,
          message: fallbackResult.message || "AI provided helpful guidance",
          sql_query: results.sql_query,
          sql_params: results.sql_params,
        };
      }

      // Merge extracted args from special handlers (e.g., tag values from get_projects_with_same_attribute)
      const finalArgs = results.extracted_args 
        ? { ...args, ...results.extracted_args }
        : args;

      // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
      // SANITIZE RESPONSE: Apply year guard to response arguments
      // If year filter is set (from "this year" detection), ensure start_date/end_date are removed
      // This prevents executeQuery normalization from re-adding dates
      // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
      const responseArgs = results.arguments ? { ...results.arguments } : { ...finalArgs };
      // Apply hallucination guard to response arguments
      const cleanedResponseArgs = stripHallucinatedGeography(responseArgs, userQuestion);
      cleanedResponseArgs._debug_client = args.client;
      cleanedResponseArgs._debug_args_before_execute = JSON.stringify({ client: args.client, company: args.company, organization: args.organization });
      const currentYearForSanitize = new Date().getFullYear();
      const askedForThisYearCheck = /\b(this\s+year|current\s+year|starting\s+this\s+year)\b/i.test(userQuestion);
      
      if (askedForThisYearCheck) {
        // Ensure year is set
        if (!cleanedResponseArgs.year) {
          cleanedResponseArgs.year = currentYearForSanitize;
        }
        // Remove start_date/end_date for cleaner YEAR() filter
        if (cleanedResponseArgs.start_date || cleanedResponseArgs.end_date) {
          console.log(`[processQuery] ğŸ“… FINAL SANITIZE: Year filter (${cleanedResponseArgs.year}) active, removing dates from response`);
          console.log(`[processQuery]   Removing: start_date=${cleanedResponseArgs.start_date}, end_date=${cleanedResponseArgs.end_date}`);
          delete cleanedResponseArgs.start_date;
          delete cleanedResponseArgs.end_date;
          cleanedResponseArgs._date_already_applied = true;
        }
      }

      // Step 4: Generate chart and summary (skip for AI analysis which has its own metadata)
      const isAIAnalysis = results.data?.[0]?.type === 'ai_analysis';
      const chartConfig = isAIAnalysis ? (results.chart_config || null) : this.generateChartConfig(results.data, functionName);
      const summary = isAIAnalysis ? (results.summary || {}) : this.calculateSummaryStats(results.data);

      return {
        success: true,
        question: results.question || userQuestion,
        function_name: results.function_name || functionName,
        arguments: cleanedResponseArgs, // Sanitized arguments - year guard applied
        data: results.data,
        row_count: results.row_count || results.data.length, // Preserve AI analysis row_count (aggregates.count)
        summary,
        chart_config: chartConfig,
        message: results.message || `Found ${results.data.length} results`, // Preserve AI analysis message
        sql_query: results.sql_query,
        sql_params: results.sql_params,
      };
    } catch (error: any) {
      console.error("Error processing query:", error);
      
      // Try AI fallback for unexpected errors
      try {
        console.log(`[QueryEngine] ğŸ”„ Unexpected error - triggering AI fallback`);
        const fallbackResult = await this.handleAIFallback(
          userQuestion,
          'execution_error',
          {
            errorMessage: error?.message || 'Unknown error',
            previousContext
          },
          externalDbQuery
        );
        
        return {
          success: true,
          question: userQuestion,
          function_name: "ai_fallback",
          arguments: {},
          data: fallbackResult.data,
          row_count: 0,
          summary: {},
          chart_config: null,
          message: fallbackResult.message || "AI provided helpful guidance",
        };
      } catch (fallbackError) {
        console.error("Error in AI fallback:", fallbackError);
        return {
          success: false,
          error: "internal_error",
          message: "An unexpected error occurred. Please try rephrasing your question or try again later.",
          data: [],
        };
      }
    }
  }

  private async preprocessQuery(
    userQuestion: string,
    classification: { function_name: string; arguments: Record<string, any> },
    externalDbQuery: (sql: string, params?: any[]) => Promise<any[]>,
    previousContext?: { question: string; function_name: string; arguments: Record<string, any>; result_data?: any[] },
    preAppliedFilters: Record<string, any> = {}
  ): Promise<{ function_name: string; arguments: Record<string, any> }> {
    const args = classification.arguments;
    
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    // EARLY EXIT: If disambiguation is locked, skip ALL preprocessing
    // This preserves user's explicit column selection without modification
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    if (args._disambiguation_locked) {
      console.log(`[preprocessQuery] ğŸ”’ DISAMBIGUATION LOCKED: Skipping all preprocessing`);
      console.log(`[preprocessQuery] ğŸ”’ Preserving function="${classification.function_name}", args=${JSON.stringify(args)}`);
      return classification;
    }

    // PREPROCESSING: Detect explicit "category" keyword in user question
    // This prevents the safety net from converting categories â†’ project_type
    // when the user explicitly asked for a category
    const categoryExplicit = /\b(request\s+)?category|categories|categorized|categorised\b/i.test(userQuestion);
    if (categoryExplicit && (args.categories || args.category)) {
      args._explicit_category = true;
      console.log(`[CategoryDetect] ğŸ“‚ User explicitly said "category" - preserving Request Category filter`);
    }

    // PREPROCESSING: Fix "from DATE" patterns - ensure end_date is open-ended
    // When user says "from 07-01-2025" or "from 2026", AI might extract a closed date range
    // We need to detect "from/after/since" and fix end_date to be far future
    const questionLower = userQuestion.toLowerCase();
    
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    // CRITICAL FIX: "this year" / "starting this year" should use YEAR parameter
    // LLM often passes today's date instead of using year filter for full calendar year
    // Using YEAR() = 2026 is cleaner than start_date >= 2026-01-01
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    const currentYear = new Date().getFullYear();
    const todayStr = new Date().toISOString().split('T')[0]; // e.g., "2026-01-08"
    const yearStartStr = `${currentYear}-01-01`; // e.g., "2026-01-01"
    
    // Match "this year", "current year", "starting this year", etc.
    const thisYearPattern = /\b(this\s+year|current\s+year|starting\s+this\s+year)\b/i;
    if (thisYearPattern.test(userQuestion)) {
      console.log(`[DateFix] ğŸ“… Detected "this year" pattern in question: "${userQuestion}"`);
      console.log(`[DateFix]   Current args BEFORE: start_date=${args.start_date}, end_date=${args.end_date}, year=${args.year}`);
      
      // Convert to year parameter for cleaner SQL (YEAR() = 2026 instead of >= date)
      if (!args.year) {
        args.year = currentYear;
        console.log(`[DateFix] ğŸ“… Set year=${currentYear} for "this year" query`);
      }
      
      // ALWAYS remove start_date/end_date when year filter is set for "this year" queries
      // The year filter will cover the full calendar year
      if (args.start_date) {
        console.log(`[DateFix] ğŸ“… Removing start_date=${args.start_date} (year filter ${args.year} covers full year)`);
        delete args.start_date;
      }
      if (args.end_date) {
        console.log(`[DateFix] ğŸ“… Removing end_date=${args.end_date} (year filter ${args.year} covers full year)`);
        delete args.end_date;
      }
      
      console.log(`[DateFix]   Current args AFTER: start_date=${args.start_date}, end_date=${args.end_date}, year=${args.year}`);
    }
    
    // CRITICAL FIX: "after 2025" should mean 2026-01-01, NOT 2025-01-01
    // "after YEAR" means starting from the NEXT year (exclusive)
    const afterYearMatch = userQuestion.match(/\bafter\s+(\d{4})\b/i);
    if (afterYearMatch && args.start_date) {
      const mentionedYear = parseInt(afterYearMatch[1], 10);
      const expectedWrongStart = `${mentionedYear}-01-01`;
      const correctStart = `${mentionedYear + 1}-01-01`;
      
      // If AI set start_date to the mentioned year, fix it to next year
      if (args.start_date === expectedWrongStart) {
        console.log(`[DateFix] ğŸ“… Detected "after YEAR" pattern - fixing exclusive year interpretation`);
        console.log(`[DateFix]   "after ${mentionedYear}" means starting from ${mentionedYear + 1}`);
        console.log(`[DateFix]   Original: start_date=${args.start_date}`);
        args.start_date = correctStart;
        console.log(`[DateFix]   Fixed: start_date=${args.start_date} (exclusive - next year)`);
      }
    }
    
    // Check if this is an open-ended "from" query (includes year-only like "from 2026")
    // Also check for "YEAR or later" pattern (e.g., "2025 or later" = "from 2025")
    const isFromQuerySpecificDate = /\b(from|starting\s+from|after|since)\s+\d{1,2}[-\/]\d{1,2}[-\/]\d{4}\b/i.test(userQuestion) ||
                                    /\b(from|starting\s+from|after|since)\s+\d{4}[-\/]\d{1,2}[-\/]\d{1,2}\b/i.test(userQuestion);
    const isFromQueryYearOnly = /\b(from|starting\s+from|after|since)\s+(\d{4})\b/i.test(userQuestion);
    const isYearOrLater = /\b(\d{4})\s+or\s+later\b/i.test(userQuestion);
    const isOnQuery = /\b(on|starting\s+on)\s+\d{1,2}[-\/]\d{1,2}[-\/]\d{4}\b/i.test(userQuestion);
    
    // Handle "YEAR or later" pattern - set open-ended date range from that year
    if (isYearOrLater && !isFromQueryYearOnly) {
      const yearLaterMatch = userQuestion.match(/\b(\d{4})\s+or\s+later\b/i);
      if (yearLaterMatch) {
        const year = parseInt(yearLaterMatch[1], 10);
        console.log(`[DateFix] ğŸ“… Detected "YEAR or later" pattern: ${year} or later`);
        
        // If no start_date set, or start_date is wrong, fix it
        if (!args.start_date || args.start_date !== `${year}-01-01`) {
          args.start_date = `${year}-01-01`;
          console.log(`[DateFix]   Set start_date=${args.start_date} (inclusive from ${year})`);
        }
        
        // Ensure end_date is open-ended
        if (!args.end_date || args.end_date === `${year}-12-31`) {
          args.end_date = "2099-12-31";
          console.log(`[DateFix]   Set end_date=${args.end_date} (open-ended)`);
        }
      }
    }
    
    // Handle "from" patterns - ensure open-ended date range
    if (args.start_date) {
      // Case 0: start_date exists but end_date is missing - set open-ended if "from" pattern
      if (!args.end_date && (isFromQuerySpecificDate || isFromQueryYearOnly) && !isOnQuery) {
        console.log(`[DateFix] ğŸ“… Detected "from" pattern with missing end_date`);
        console.log(`[DateFix]   Original: start_date=${args.start_date}, end_date=undefined`);
        args.end_date = "2099-12-31"; // Open-ended future
        console.log(`[DateFix]   Fixed: end_date=${args.end_date} (open-ended)`);
      }
      // Case 1: Same start/end dates with specific date format (e.g., "from 07-01-2025")
      else if (args.end_date && args.start_date === args.end_date && isFromQuerySpecificDate && !isOnQuery) {
        console.log(`[DateFix] ğŸ“… Detected "from DATE" pattern with same start/end dates`);
        console.log(`[DateFix]   Original: start_date=${args.start_date}, end_date=${args.end_date}`);
        args.end_date = "2099-12-31"; // Open-ended future
        console.log(`[DateFix]   Fixed: end_date=${args.end_date} (open-ended)`);
      }
      // Case 2: Year-only query like "from 2026" - end_date is Dec 31 of same year but should be open-ended
      else if (args.end_date && isFromQueryYearOnly && !isFromQuerySpecificDate && !isOnQuery) {
        // Extract the year from the question
        const yearMatch = userQuestion.match(/\b(from|starting\s+from|after|since)\s+(\d{4})\b/i);
        if (yearMatch) {
          const year = yearMatch[2];
          // If end_date is Dec 31 of the specified year, make it open-ended
          if (args.end_date === `${year}-12-31`) {
            console.log(`[DateFix] ğŸ“… Detected "from YEAR" pattern (year-only: ${year})`);
            console.log(`[DateFix]   Original: start_date=${args.start_date}, end_date=${args.end_date}`);
            args.end_date = "2099-12-31"; // Open-ended future
            console.log(`[DateFix]   Fixed: end_date=${args.end_date} (open-ended)`);
          }
        }
      }
    }

    // PREPROCESSING GUARD: Detect duration-in-status queries and force get_stalled_deals
    // This prevents the semantic time parser from incorrectly converting "stuck for X days" into date ranges
    // IMPORTANT: Do NOT match time-based phrases like "last 45 days", "past 30 days", "next 60 days"
    const isTimeBasedPhrase = /\b(?:last|past|next|previous|within\s+the\s+last|within\s+the\s+past)\s+\d+\s+days?\b/i.test(userQuestion);
    
    const durationPatterns = [
      /stuck\s+(?:in\s+)?.*?(?:for\s+)?(?:over|more\s+than|longer\s+than)?\s*(\d+)\s+days?/i,
      /been\s+in\s+.*?(?:for\s+)?(?:over|more\s+than)?\s*(\d+)\s+days?/i,
      // Only match "in [status] for X days" - NOT "in last X days" (time-based filtering)
      /(?:in|within)\s+(?!last|past|next|previous|the\s+last|the\s+past).*?(?:for\s+)?(?:over|more\s+than|longer\s+than)?\s*(\d+)\s+days?/i,
      /(?:pipeline|status)\s+(?:for\s+)?(?:over|more\s+than|longer\s+than)?\s*(\d+)\s+days?/i,
    ];

    let durationMatch = null;
    for (const pattern of durationPatterns) {
      const match = userQuestion.match(pattern);
      if (match) {
        durationMatch = match;
        break;
      }
    }

    // Skip DurationGuard if this is clearly a time-based phrase (last X days, next X days, etc.)
    if (durationMatch && !isTimeBasedPhrase) {
      const minDays = parseInt(durationMatch[1], 10);
      console.log(`[DurationGuard] ğŸ¯ Detected duration-in-status query: "${userQuestion}"`);
      console.log(`[DurationGuard]   Forcing function: get_stalled_deals`);
      console.log(`[DurationGuard]   Extracted min_days_stalled: ${minDays}`);
      
      // Force the function to get_stalled_deals
      classification.function_name = 'get_stalled_deals';
      args.min_days_stalled = minDays;
      
      // Remove any date ranges that may have been extracted
      delete args.start_date;
      delete args.end_date;
      delete args.time_reference;
      
      console.log(`[DurationGuard]   Final args:`, JSON.stringify(args));
    }

    // PREPROCESSING: Detect multiple size values in user question
    // When user says "mega and small projects", extract both sizes even if AI only extracted one
    const sizeKeywords = {
      'mega': 'Mega', 'huge': 'Mega', 'massive': 'Mega', 'giant': 'Mega',
      'large': 'Large', 'big': 'Large', 'major': 'Large',
      'medium': 'Medium', 'mid-sized': 'Medium', 'moderate': 'Medium',
      'small': 'Small', 'minor': 'Small', 'little': 'Small',
      'micro': 'Micro', 'tiny': 'Micro'
    };
    
    // Look for patterns like "mega and small", "large or medium", "small, medium and large"
    const multiSizePattern = /\b(mega|huge|massive|giant|large|big|major|medium|mid-sized|moderate|small|minor|little|micro|tiny)\b.*?\b(and|or|,)\b.*?\b(mega|huge|massive|giant|large|big|major|medium|mid-sized|moderate|small|minor|little|micro|tiny)\b/gi;
    const multiSizeMatch = questionLower.match(multiSizePattern);
    
    if (multiSizeMatch) {
      // Extract all size keywords from the question
      const foundSizes = new Set<string>();
      for (const [keyword, canonical] of Object.entries(sizeKeywords)) {
        const regex = new RegExp(`\\b${keyword}\\b`, 'i');
        if (regex.test(questionLower)) {
          foundSizes.add(canonical);
        }
      }
      
      if (foundSizes.size > 1) {
        const sizesArray = Array.from(foundSizes);
        console.log(`[SizeExtract] ğŸ¯ Detected multiple sizes in question: ${sizesArray.join(', ')}`);
        args.size = sizesArray;
      }
    }

    // PREPROCESSING: Extract US state names from user query
    // Maps full state names and common abbreviations to exact database values
    const US_STATES: Record<string, string> = {
      'alabama': 'Alabama', 'al': 'Alabama',
      'alaska': 'Alaska', 'ak': 'Alaska',
      'arizona': 'Arizona', 'az': 'Arizona',
      'arkansas': 'Arkansas', 'ar': 'Arkansas',
      'california': 'California', 'ca': 'California', 'cali': 'California',
      'colorado': 'Colorado', 'co': 'Colorado',
      'connecticut': 'Connecticut', 'ct': 'Connecticut',
      'delaware': 'Delaware', 'de': 'Delaware',
      'florida': 'Florida', 'fl': 'Florida',
      'georgia': 'Georgia', 'ga': 'Georgia',
      'hawaii': 'Hawaii', 'hi': 'Hawaii',
      'idaho': 'Idaho', 'id': 'Idaho',
      'illinois': 'Illinois', 'il': 'Illinois',
      'indiana': 'Indiana', 'in': 'Indiana',
      'iowa': 'Iowa', 'ia': 'Iowa',
      'kansas': 'Kansas', 'ks': 'Kansas',
      'kentucky': 'Kentucky', 'ky': 'Kentucky',
      'louisiana': 'Louisiana', 'la': 'Louisiana',
      'maine': 'Maine', 'me': 'Maine',
      'maryland': 'Maryland', 'md': 'Maryland',
      'massachusetts': 'Massachusetts', 'ma': 'Massachusetts',
      'michigan': 'Michigan', 'mi': 'Michigan',
      'minnesota': 'Minnesota', 'mn': 'Minnesota',
      'mississippi': 'Mississippi', 'ms': 'Mississippi',
      'missouri': 'Missouri', 'mo': 'Missouri',
      'montana': 'Montana', 'mt': 'Montana',
      'nebraska': 'Nebraska', 'ne': 'Nebraska',
      'nevada': 'Nevada', 'nv': 'Nevada',
      'new hampshire': 'New Hampshire', 'nh': 'New Hampshire',
      'new jersey': 'New Jersey', 'nj': 'New Jersey',
      'new mexico': 'New Mexico', 'nm': 'New Mexico',
      'new york': 'New York', 'ny': 'New York',
      'north carolina': 'North Carolina', 'nc': 'North Carolina',
      'north dakota': 'North Dakota', 'nd': 'North Dakota',
      'ohio': 'Ohio', 'oh': 'Ohio',
      'oklahoma': 'Oklahoma', 'ok': 'Oklahoma',
      'oregon': 'Oregon', 'or': 'Oregon',
      'pennsylvania': 'Pennsylvania', 'pa': 'Pennsylvania',
      'rhode island': 'Rhode Island', 'ri': 'Rhode Island',
      'south carolina': 'South Carolina', 'sc': 'South Carolina',
      'south dakota': 'South Dakota', 'sd': 'South Dakota',
      'tennessee': 'Tennessee', 'tn': 'Tennessee',
      'texas': 'Texas', 'tx': 'Texas',
      'utah': 'Utah', 'ut': 'Utah',
      'vermont': 'Vermont', 'vt': 'Vermont',
      'virginia': 'Virginia', 'va': 'Virginia',
      'washington': 'Washington', 'wa': 'Washington',
      'west virginia': 'West Virginia', 'wv': 'West Virginia',
      'wisconsin': 'Wisconsin', 'wi': 'Wisconsin',
      'wyoming': 'Wyoming', 'wy': 'Wyoming',
    };
    
    // REGION MAPPING: Maps region names to their constituent states (covers all 50 states)
    // Used for queries like "projects in the West" or "show me midwest deals"
    const REGION_TO_STATES: Record<string, string[]> = {
      // West Region (13 states)
      'west': ['Alaska', 'Arizona', 'California', 'Colorado', 'Hawaii', 'Idaho', 'Montana', 'Nevada', 'New Mexico', 'Oregon', 'Utah', 'Washington', 'Wyoming'],
      'western': ['Alaska', 'Arizona', 'California', 'Colorado', 'Hawaii', 'Idaho', 'Montana', 'Nevada', 'New Mexico', 'Oregon', 'Utah', 'Washington', 'Wyoming'],
      'pacific': ['Alaska', 'California', 'Hawaii', 'Oregon', 'Washington'],
      'mountain': ['Arizona', 'Colorado', 'Idaho', 'Montana', 'Nevada', 'New Mexico', 'Utah', 'Wyoming'],
      
      // Midwest Region (12 states)
      'midwest': ['Illinois', 'Indiana', 'Iowa', 'Kansas', 'Michigan', 'Minnesota', 'Missouri', 'Nebraska', 'North Dakota', 'Ohio', 'South Dakota', 'Wisconsin'],
      'midwestern': ['Illinois', 'Indiana', 'Iowa', 'Kansas', 'Michigan', 'Minnesota', 'Missouri', 'Nebraska', 'North Dakota', 'Ohio', 'South Dakota', 'Wisconsin'],
      'great lakes': ['Illinois', 'Indiana', 'Michigan', 'Minnesota', 'Ohio', 'Wisconsin'],
      'plains': ['Iowa', 'Kansas', 'Minnesota', 'Missouri', 'Nebraska', 'North Dakota', 'South Dakota'],
      
      // South Region (16 states + DC conceptually)
      'south': ['Alabama', 'Arkansas', 'Delaware', 'Florida', 'Georgia', 'Kentucky', 'Louisiana', 'Maryland', 'Mississippi', 'North Carolina', 'Oklahoma', 'South Carolina', 'Tennessee', 'Texas', 'Virginia', 'West Virginia'],
      'southern': ['Alabama', 'Arkansas', 'Delaware', 'Florida', 'Georgia', 'Kentucky', 'Louisiana', 'Maryland', 'Mississippi', 'North Carolina', 'Oklahoma', 'South Carolina', 'Tennessee', 'Texas', 'Virginia', 'West Virginia'],
      'southeast': ['Alabama', 'Florida', 'Georgia', 'Kentucky', 'Mississippi', 'North Carolina', 'South Carolina', 'Tennessee', 'Virginia', 'West Virginia'],
      'southeastern': ['Alabama', 'Florida', 'Georgia', 'Kentucky', 'Mississippi', 'North Carolina', 'South Carolina', 'Tennessee', 'Virginia', 'West Virginia'],
      'southwest': ['Arizona', 'New Mexico', 'Oklahoma', 'Texas'],
      'southwestern': ['Arizona', 'New Mexico', 'Oklahoma', 'Texas'],
      'gulf': ['Alabama', 'Florida', 'Louisiana', 'Mississippi', 'Texas'],
      'gulf coast': ['Alabama', 'Florida', 'Louisiana', 'Mississippi', 'Texas'],
      
      // Northeast Region (9 states)
      'northeast': ['Connecticut', 'Maine', 'Massachusetts', 'New Hampshire', 'New Jersey', 'New York', 'Pennsylvania', 'Rhode Island', 'Vermont'],
      'northeastern': ['Connecticut', 'Maine', 'Massachusetts', 'New Hampshire', 'New Jersey', 'New York', 'Pennsylvania', 'Rhode Island', 'Vermont'],
      'new england': ['Connecticut', 'Maine', 'Massachusetts', 'New Hampshire', 'Rhode Island', 'Vermont'],
      'mid-atlantic': ['Delaware', 'Maryland', 'New Jersey', 'New York', 'Pennsylvania'],
      'mid atlantic': ['Delaware', 'Maryland', 'New Jersey', 'New York', 'Pennsylvania'],
      'east coast': ['Connecticut', 'Delaware', 'Florida', 'Georgia', 'Maine', 'Maryland', 'Massachusetts', 'New Hampshire', 'New Jersey', 'New York', 'North Carolina', 'Pennsylvania', 'Rhode Island', 'South Carolina', 'Vermont', 'Virginia'],
      'eastern': ['Connecticut', 'Delaware', 'Florida', 'Georgia', 'Maine', 'Maryland', 'Massachusetts', 'New Hampshire', 'New Jersey', 'New York', 'North Carolina', 'Pennsylvania', 'Rhode Island', 'South Carolina', 'Vermont', 'Virginia'],
      
      // Special regions
      'tristate': ['Connecticut', 'New Jersey', 'New York'],
      'rust belt': ['Illinois', 'Indiana', 'Michigan', 'Ohio', 'Pennsylvania', 'Wisconsin'],
      'sun belt': ['Alabama', 'Arizona', 'California', 'Florida', 'Georgia', 'Louisiana', 'Mississippi', 'Nevada', 'New Mexico', 'North Carolina', 'South Carolina', 'Texas'],
    };

    // Check for region keywords in the question and expand to states
    // CRITICAL: First check for EXCLUSION patterns ("except west", "excluding midwest")
    console.log(`[RegionExpand] ğŸ” Checking exclusions. args.exclude_states=${!!args.exclude_states}, args.states=${!!args.states}, questionLower="${questionLower.substring(0, 100)}..."`);
    if (!args.exclude_states) {
      for (const [regionKey, regionStates] of Object.entries(REGION_TO_STATES)) {
        // Match patterns like "except west region", "excluding midwest", "not in south", "but not west"
        const excludePattern = new RegExp(`\\b(except|excluding|exclude|not\\s+in|but\\s+not|outside\\s+of?)\\s+(the\\s+)?${regionKey}(\\s+region|\\s+states?|\\s+area)?\\b`, 'i');
        if (excludePattern.test(questionLower)) {
          console.log(`[RegionExpand] ğŸš« EXCLUSION DETECTED: "${regionKey}" â†’ EXCLUDING ${regionStates.length} states`);
          args.exclude_states = regionStates;
          // Remove any conflicting inclusion states
          if (args.states) {
            console.log(`[RegionExpand] ğŸ—‘ï¸ DELETING args.states (${args.states.length} states) due to exclusion`);
          }
          delete args.states;
          delete args.state_code;
          break;
        }
      }
    }
    console.log(`[RegionExpand] ğŸ“Š After exclusion check: args.exclude_states=${args.exclude_states?.length || 0} states, args.states=${args.states?.length || 0} states`);
    
    // Only detect INCLUSION regions if we didn't detect an exclusion AND no states/regions already set
    // FIX: Use Region column directly instead of expanding to individual states
    if (!args.exclude_states && !args.state_code && !args.states && !args.regions) {
      for (const [regionKey, regionStates] of Object.entries(REGION_TO_STATES)) {
        // Match "west region", "in the west", "western states", "from midwest", etc.
        const regionPattern = new RegExp(`\\b(in\\s+the\\s+)?${regionKey}(\\s+region|\\s+states?|\\s+area)?\\b`, 'i');
        if (regionPattern.test(questionLower)) {
          // Use Region column directly instead of expanding to states
          console.log(`[RegionExpand] ğŸŒ Detected region "${regionKey}" â†’ Region column filter (NOT state expansion)`);
          args.regions = [regionKey]; // Use Region column, not states
          // Remove state_code if set
          delete args.state_code;
          break;
        }
      }
    }

    // Create a lookup map for abbreviations to full names
    const STATE_ABBREV_TO_FULL: Record<string, string> = {
      'AL': 'Alabama', 'AK': 'Alaska', 'AZ': 'Arizona', 'AR': 'Arkansas',
      'CA': 'California', 'CO': 'Colorado', 'CT': 'Connecticut', 'DE': 'Delaware',
      'FL': 'Florida', 'GA': 'Georgia', 'HI': 'Hawaii', 'ID': 'Idaho',
      'IL': 'Illinois', 'IN': 'Indiana', 'IA': 'Iowa', 'KS': 'Kansas',
      'KY': 'Kentucky', 'LA': 'Louisiana', 'ME': 'Maine', 'MD': 'Maryland',
      'MA': 'Massachusetts', 'MI': 'Michigan', 'MN': 'Minnesota', 'MS': 'Mississippi',
      'MO': 'Missouri', 'MT': 'Montana', 'NE': 'Nebraska', 'NV': 'Nevada',
      'NH': 'New Hampshire', 'NJ': 'New Jersey', 'NM': 'New Mexico', 'NY': 'New York',
      'NC': 'North Carolina', 'ND': 'North Dakota', 'OH': 'Ohio', 'OK': 'Oklahoma',
      'OR': 'Oregon', 'PA': 'Pennsylvania', 'RI': 'Rhode Island', 'SC': 'South Carolina',
      'SD': 'South Dakota', 'TN': 'Tennessee', 'TX': 'Texas', 'UT': 'Utah',
      'VT': 'Vermont', 'VA': 'Virginia', 'WA': 'Washington', 'WV': 'West Virginia',
      'WI': 'Wisconsin', 'WY': 'Wyoming'
    };

    // If state_code is already set (from AI), normalize abbreviation to full name
    if (args.state_code) {
      const upperState = args.state_code.toUpperCase();
      if (STATE_ABBREV_TO_FULL[upperState]) {
        console.log(`[StateNormalize] ğŸ”„ Converting abbreviation "${args.state_code}" â†’ "${STATE_ABBREV_TO_FULL[upperState]}"`);
        args.state_code = STATE_ABBREV_TO_FULL[upperState];
      }
    }
    
    // INTERNATIONAL REGION DETECTION: Convert state_code to region for non-US locations
    // LLM sometimes extracts international regions as state_code instead of region
    // e.g., "Hong Kong" â†’ should filter by Region column, not State column
    const INTERNATIONAL_REGIONS = [
      'hong kong', 'europe', 'mena', 'middle east', 'asia', 'southeast asia', 'south east asia',
      'singapore', 'canada', 'latin america', 'south america', 'central america',
      'sub-saharan africa', 'africa', 'oceania', 'australia', 'united kingdom', 'uk',
      'china', 'japan', 'india', 'korea', 'vietnam', 'thailand', 'malaysia', 'indonesia',
      'philippines', 'taiwan', 'uae', 'saudi arabia', 'qatar', 'dubai', 'abu dhabi',
      'germany', 'france', 'spain', 'italy', 'netherlands', 'belgium', 'switzerland',
      'poland', 'czech', 'austria', 'sweden', 'norway', 'denmark', 'finland', 'ireland',
      'portugal', 'greece', 'turkey', 'russia', 'ukraine', 'brazil', 'mexico', 'argentina',
      'chile', 'colombia', 'peru', 'central asia', 'caribbean', 'puerto rico'
    ];
    
    if (args.state_code) {
      const stateCodeLower = args.state_code.toLowerCase();
      if (INTERNATIONAL_REGIONS.includes(stateCodeLower)) {
        console.log(`[RegionNormalize] ğŸŒ Converting state_code to region: "${args.state_code}" â†’ International region`);
        args.region = args.state_code;
        delete args.state_code;
      }
    }
    
    // Also check if "region" appears in the question with an international region name
    // GUARD: Skip region extraction if it's part of a division/department name
    // e.g., "UK Domestic division" â†’ don't extract "UK" as region
    const isDivisionDeptQuery = /\b(?:division|department)\b/i.test(questionLower);
    
    if (!args.region && !args.state_code) {
      for (const intlRegion of INTERNATIONAL_REGIONS) {
        const regionPattern = new RegExp(`\\b${intlRegion}\\s*(?:region|area|market)?\\b`, 'i');
        if (regionPattern.test(questionLower)) {
          // GUARD: For division/department queries, check if region appears BEFORE "division"/"department"
          // e.g., "UK Domestic division" â†’ "UK" appears before "division" â†’ skip
          if (isDivisionDeptQuery) {
            const regionBeforeDivDeptRegex = new RegExp(`\\b${intlRegion}\\b.*\\b(?:division|department)\\b`, 'i');
            if (regionBeforeDivDeptRegex.test(questionLower)) {
              console.log(`[RegionDetect] âš ï¸ Skipping "${intlRegion}" - appears to be part of division/department name`);
              continue; // Skip this region, try next one
            }
          }
          
          // Capitalize properly for display
          const formattedRegion = intlRegion.split(' ').map(w => w.charAt(0).toUpperCase() + w.slice(1)).join(' ');
          console.log(`[RegionDetect] ğŸŒ Detected international region in question: "${formattedRegion}"`);
          args.region = formattedRegion;
          break;
        }
      }
    }
    
    // Check for state names in the question if state_code is not already set
    if (!args.state_code) {
      // First check for multi-word state names
      const multiWordStates = ['new hampshire', 'new jersey', 'new mexico', 'new york', 
                               'north carolina', 'north dakota', 'rhode island', 
                               'south carolina', 'south dakota', 'west virginia'];
      for (const stateName of multiWordStates) {
        const regex = new RegExp(`\\b${stateName}\\b`, 'i');
        if (regex.test(questionLower)) {
          args.state_code = US_STATES[stateName];
          console.log(`[StateExtract] ğŸ¯ Detected US state: "${stateName}" â†’ ${args.state_code}`);
          break;
        }
      }
      
      // Then check for single-word state names and abbreviations
      if (!args.state_code) {
        // GUARD: Skip state extraction for division queries
        // "LFDH NY division" should NOT extract "NY" as a state - it's part of the division name
        const isDivisionQuery = /\bdivision\b/i.test(questionLower);
        
        for (const [key, value] of Object.entries(US_STATES)) {
          // Skip multi-word keys (already checked above)
          if (key.includes(' ')) continue;
          // Match state name as whole word (not part of another word)
          const regex = new RegExp(`\\b${key}\\b`, 'i');
          if (regex.test(questionLower)) {
            // Avoid false positives for common words
            if (key === 'in' || key === 'or' || key === 'me' || key === 'ok' || key === 'hi' || key === 'id') {
              // Only match if preceded by "in" or "from" for context
              const contextRegex = new RegExp(`\\b(in|from)\\s+${key}\\b`, 'i');
              if (!contextRegex.test(questionLower)) continue;
            }
            
            // GUARD: For division queries, skip state codes that appear within division name context
            // e.g., "LFDH NY division" â†’ skip NY, "projects in NY" â†’ extract NY
            if (isDivisionQuery) {
              // Check if state code appears BEFORE "division" (likely part of division name)
              const stateBeforeDivisionRegex = new RegExp(`\\b${key}\\s+division\\b`, 'i');
              const wordBeforeStateRegex = new RegExp(`\\w+\\s+${key}\\s+division\\b`, 'i');
              if (stateBeforeDivisionRegex.test(questionLower) || wordBeforeStateRegex.test(questionLower)) {
                console.log(`[StateExtract] âš ï¸ SKIPPING "${key}" - appears to be part of division name, not a state filter`);
                continue;
              }
            }
            
            args.state_code = value;
            console.log(`[StateExtract] ğŸ¯ Detected US state: "${key}" â†’ ${args.state_code}`);
            break;
          }
        }
      }
    }

    // PREPROCESSING: Detect "state lookup between X and Y" range queries
    // Patterns: "state lookup between 1750 and 1850", "state between 1000-2000"
    const stateLookupRangePatterns = [
      /state\s*(?:lookup)?\s*(?:between|from)\s*(\d+)\s*(?:and|to|-)\s*(\d+)/i,
      /(?:between|from)\s*(\d+)\s*(?:and|to|-)\s*(\d+)\s*(?:state|lookup)/i,
    ];
    
    for (const pattern of stateLookupRangePatterns) {
      const match = userQuestion.match(pattern);
      if (match) {
        const min = parseInt(match[1], 10);
        const max = parseInt(match[2], 10);
        console.log(`[StateRange] ğŸ¯ Detected state lookup range: ${min} to ${max}`);
        args.state_lookup_min = Math.min(min, max);
        args.state_lookup_max = Math.max(min, max);
        // Clear any misinterpreted state_code that may have been set
        delete args.state_code;
        // Force to get_projects_by_combined_filters - required since get_projects_by_state needs state_code
        classification.function_name = 'get_projects_by_combined_filters';
        console.log(`[StateRange] Forced function to: get_projects_by_combined_filters`);
        break;
      }
    }

    // SPECIAL CASE: Handle get_projects_by_quarter with time_reference
    // This function requires integer year and quarter, not date ranges
    if (classification.function_name === 'get_projects_by_quarter' && args.time_reference) {
      const timeRef = args.time_reference.toLowerCase();
      
      // Extract quarter and year from patterns like "quarter 1 of 2024", "Q1 2024", "q1 of 2024"
      const quarterPatterns = [
        /(?:quarter|q)\s*(\d)\s*(?:of\s+)?(\d{4})/i,  // "quarter 1 of 2024", "Q1 2024"
        /(\d{4})\s*(?:quarter|q)\s*(\d)/i,            // "2024 Q1"
      ];
      
      let matched = false;
      for (const pattern of quarterPatterns) {
        const match = timeRef.match(pattern);
        if (match) {
          // First pattern: quarter then year
          // Second pattern: year then quarter
          if (pattern === quarterPatterns[0]) {
            args.quarter = parseInt(match[1], 10);
            args.year = parseInt(match[2], 10);
          } else {
            args.year = parseInt(match[1], 10);
            args.quarter = parseInt(match[2], 10);
          }
          console.log(`[QuarterExtract] Parsed "${args.time_reference}" â†’ year=${args.year}, quarter=${args.quarter}`);
          delete args.time_reference;
          matched = true;
          break;
        }
      }
      
      // If no quarter pattern matched, switch to date range query instead
      if (!matched) {
        console.log(`[QuarterExtract] Could not parse quarter from "${args.time_reference}", switching to date range query`);
        classification.function_name = 'get_projects_by_date_range';
        const dateRange = this.timeParser.parse(args.time_reference);
        if (dateRange) {
          args.start_date = dateRange[0];
          args.end_date = dateRange[1];
        }
        delete args.time_reference;
      }
    }
    // Process semantic time references ONLY if NOT a duration-in-status query
    // If min_days_stalled exists, skip date parsing to avoid conflicts
    // ALSO skip if year filter is already set (from "this year" detection above)
    else if (args.time_reference && !args.min_days_stalled && !args.year) {
      const timeRef = args.time_reference;
      const dateRange = this.timeParser.parse(timeRef);

      if (dateRange) {
        args.start_date = dateRange[0];
        args.end_date = dateRange[1];
        
        // Fix: Detect "from YEAR" patterns and make end_date open-ended
        // e.g., "from 2026" should mean 2026-01-01 to 2099-12-31, not just 2026
        const isFromYearPattern = /\b(from|starting\s+from|after|since)\s+(\d{4})\b/i.test(timeRef);
        const isFromSpecificDate = /\b(from|starting\s+from|after|since)\s+\d{1,2}[-\/]\d{1,2}[-\/]\d{4}\b/i.test(timeRef) ||
                                   /\b(from|starting\s+from|after|since)\s+\d{4}[-\/]\d{1,2}[-\/]\d{1,2}\b/i.test(timeRef);
        const isOnPattern = /\b(on|starting\s+on)\b/i.test(timeRef);
        
        if ((isFromYearPattern || isFromSpecificDate) && !isOnPattern) {
          console.log(`[TimeRefFix] ğŸ“… Detected "from" pattern in time_reference: "${timeRef}"`);
          console.log(`[TimeRefFix]   Original parsed: start=${args.start_date}, end=${args.end_date}`);
          args.end_date = "2099-12-31"; // Open-ended future
          console.log(`[TimeRefFix]   Fixed: end_date=${args.end_date} (open-ended)`);
        }
        
        delete args.time_reference;
      } else {
        delete args.time_reference;
      }
    } else if (args.min_days_stalled) {
      // Duration query: remove time_reference and date ranges
      delete args.time_reference;
      delete args.start_date;
      delete args.end_date;
    } else if (args.year && args.time_reference) {
      // Year filter already set (from "this year" detection) - just clean up time_reference
      console.log(`[DateFix] ğŸ“… Year filter (${args.year}) takes precedence, removing time_reference: "${args.time_reference}"`);
      delete args.time_reference;
    }

    // Fix: Convert categories array to single category for get_projects_by_category template
    // This prevents duplicate parameter binding (template expects $1, not $1 and $2)
    if (classification.function_name === 'get_projects_by_category' && args.categories && Array.isArray(args.categories)) {
      if (args.categories.length > 0) {
        args.category = args.categories[0]; // Use first category
    
       // Also remove singular form // Remove array to prevent duplicate filter
        console.log(`[Normalize] Converted categories array to single category: "${args.category}"`);
      }
    }

    // Client normalization - ensure all Client values start with "Client "
    // BUT: Only for actual client IDs (numbers), NOT person names
    // SKIP normalization if _client_already_applied (user explicitly selected Client filter)
    if (args.client && !args._client_already_applied) {
      const client = args.client.trim();
      
      // Check if it looks like a person name (has space and letters, not just numbers)
      // BUT: Organization names like "Abu Dhabi Airports Company" should NOT be treated as person names
      const orgIndicators = /\b(company|corporation|corp|inc|llc|ltd|group|authority|agency|district|foundation|hospital|airports?|university|college|school|transit|metro|mta|port|center|institute|department|office|service|board|commission)\b/i;
      const hasOrgIndicator = orgIndicators.test(client);
      const looksLikePersonName = !hasOrgIndicator && /^[A-Za-z]+\s+[A-Za-z]+$/.test(client) && client.split(' ').length <= 3;
      
      if (looksLikePersonName) {
        // This is a person name like "Amy Wincko" - it was misclassified!
        // Auto-correct: Move to POC field and change function to get_projects_by_poc
        console.log(`[Normalize] âš ï¸ AUTO-CORRECTING: "${client}" is a person name, not a client ID!`);
        console.log(`[Normalize]   Rerouting from get_projects_by_client â†’ get_projects_by_poc`);
        
        // Move client value to poc
        args.poc = client;
        delete args.client;
        
        // Change function to get_projects_by_poc if it was a client-based function
        if (classification.function_name === 'get_projects_by_client' || 
            classification.function_name === 'get_projects_by_client_and_fee_range' ||
            classification.function_name === 'get_projects_by_client_status_win_range') {
          classification.function_name = 'get_projects_by_poc';
          console.log(`[Normalize]   Function changed to: get_projects_by_poc`);
        }
      } else if (/^\d+$/.test(client)) {
        // Just a number like "4885" -> "Client 4885"
        args.client = `Client ${client}`;
        console.log(`[Normalize] Client normalized: "${args.client}"`);
      } else if (/^clid\d+$/i.test(client)) {
        // "clid4885" or "Client4885" (no space) -> "Client 4885"
        const num = client.replace(/^clid/i, '');
        args.client = `Client ${num}`;
        console.log(`[Normalize] Fixed Client spacing: "${client}" â†’ "${args.client}"`);
      } else if (!hasOrgIndicator && !client.toUpperCase().startsWith('Client')) {
        // Doesn't start with Client and not a person name and not an organization -> add prefix
        // Organization names like "Abu Dhabi Airports Company" should NOT get "Client " prefix
        args.client = `Client ${client}`;
        console.log(`[Normalize] Client normalized: "${args.client}"`);
      } else if (hasOrgIndicator) {
        // Organization name - use as-is, don't add "Client " prefix
        console.log(`[Normalize] Organization name preserved: "${args.client}"`);
      }
    }

    // CRITICAL GUARD: Auto-correct get_top_pocs â†’ get_projects_by_poc for specific POC name queries
    // When user asks "projects by Alex" (specific person), they want a LISTING, not a POC leaderboard
    // Only use get_top_pocs when: asking for "top POCs", "breakdown by POC", "POC with most projects", etc.
    // NOTE: "Alex's top projects" should STILL get listing (top describes projects, not POCs)
    if (classification.function_name === 'get_top_pocs') {
      // Handle both string and array POC values
      const pocValue = args.poc;
      let hasSpecificPocName = false;
      if (typeof pocValue === 'string' && pocValue.trim().length > 0) {
        hasSpecificPocName = true;
      } else if (Array.isArray(pocValue) && pocValue.length === 1 && pocValue[0].trim().length > 0) {
        // Single POC in array is still a specific name query
        hasSpecificPocName = true;
      }
      
      // Check if query has LEADERBOARD/RANKING intent - keywords that imply comparing MULTIPLE POCs
      // TRUE aggregation: "top POCs", "best sales reps", "which contact has most", "breakdown by poc"
      // NOT aggregation: "Alex's top projects", "best projects by Alex", "Alex's largest deals"
      const leaderboardPatterns = [
        /\b(top|best|highest|most|ranking)\s+(sales\s*reps?|pocs?|contacts?|point\s+of\s+contacts?)\b/i,  // "top POCs", "best sales reps"
        /\b(which|what|who)\s+(sales\s*rep|poc|contact)\s+(has|with|handles?|generates?)\s+(the\s+)?(most|highest|largest)/i,  // "which POC has most"
        /\bbreak\s*down\s+(?:projects?\s+)?(?:by|per)\s+(?:the\s+)?(poc|contact|sales\s*rep)/i,  // "breakdown by POC"
        /\b(by|per)\s+(?:the\s+)?(poc|contact|sales\s*rep|point\s+of\s+contact)\s*$/i,  // "by POC" at end of query
        /\bpoc\s+(breakdown|ranking|leaderboard|comparison)/i,  // "POC breakdown", "POC ranking"
        /\b(compare|comparing)\s+.+\s+to\s+(?:other\s+)?(?:pocs?|contacts?|sales\s*reps?|peers?)/i,  // "compare Alex to other POCs"
        /\bcompare\s+(?:the\s+)?(?:pocs?|contacts?|sales\s*reps?)/i,  // "compare POCs", "compare the contacts"
        /\brank(?:ing|s|ed)?\s+.+\s+(?:among|against|versus|vs\.?|relative\s+to|compared\s+to)\s+(?:other\s+)?(?:pocs?|contacts?|sales\s*reps?|peers?)/i,  // "rank Alex among POCs"
        /\b(?:where|how)\s+does\s+.+\s+rank\b/i,  // "where does Alex rank", "where does Amy Wincko rank"
        /\brelative\s+performance\s+of\b/i,  // "relative performance of Alex"
        /\bhow\s+(?:is|does)\s+.+\s+(?:performing\s+)?compared\s+to\s+(?:other|all|the|peers?)/i,  // "how is Alex compared to peers"
        /\b.+\s+versus\s+(?:other\s+)?(?:pocs?|contacts?|sales\s*reps?)/i,  // "Alex versus other POCs"
        /\b.+\s+vs\.?\s+(?:other\s+)?(?:pocs?|contacts?|sales\s*reps?)/i,  // "Alex vs other contacts"
      ];
      
      const hasLeaderboardIntent = leaderboardPatterns.some(pattern => pattern.test(userQuestion));
      
      if (hasSpecificPocName && !hasLeaderboardIntent) {
        const pocName = Array.isArray(pocValue) ? pocValue[0] : pocValue;
        console.log(`[Normalize] âš ï¸ AUTO-CORRECTING: get_top_pocs â†’ get_projects_by_poc`);
        console.log(`[Normalize]   Reason: Specific POC name "${pocName}" without leaderboard intent`);
        console.log(`[Normalize]   User wants LISTING of projects for this POC, not POC leaderboard`);
        classification.function_name = 'get_projects_by_poc';
      }
    }

    // Handle clients array (for compare_clients, etc.)
    if (args.clients && Array.isArray(args.clients)) {
      args.clients = args.clients.map(client => {
        const trimmed = client.trim();
        
        // Check if it looks like a person name
        const looksLikePersonName = /^[A-Za-z]+\s+[A-Za-z]+/.test(trimmed);
        
        if (looksLikePersonName) {
          console.log(`[Normalize] âš ï¸ WARNING: "${trimmed}" looks like a person name (POC), not a client ID!`);
          return trimmed; // Don't add Client to person names
        } else if (/^\d+$/.test(trimmed)) {
          // Just a number like "4885" -> "Client 4885"
          return `Client ${trimmed}`;
        } else if (/^clid\d+$/i.test(trimmed)) {
          // "clid4885" or "Client4885" (no space) -> "Client 4885"
          const num = trimmed.replace(/^clid/i, '');
          console.log(`[Normalize] Fixed Client spacing: "${trimmed}" â†’ "Client ${num}"`);
          return `Client ${num}`;
        } else if (!trimmed.toUpperCase().startsWith('Client')) {
          return `Client ${trimmed}`;
        }
        return client;
      });
      console.log(`[Normalize] Clients array normalized: ${JSON.stringify(args.clients)}`);
    }

    // POST-PROCESSING: Detect "leading projects" pattern and inject Lead status
    // This handles cases like "leading projects above 5 million" where OpenAI doesn't extract status
    if (!args.status) {
      const leadingProjectsPattern = /\b(leading)\s+(?:projects?|opportunities?|deals?)\s+(?:above|over|greater than|more than|exceeding|with|valued|worth)/i;
      if (leadingProjectsPattern.test(userQuestion)) {
        args.status = 'Lead';
        console.log(`[QueryEngine] ğŸ“Š POST-PROCESSING: Injected status "Lead" from "leading projects" pattern`);
      }
    }

    // GUARD: Remove ALL limits unless user explicitly requested a specific count
    // Explicit limit patterns: "top 10", "first 5", "last 3", "bottom 5", "only 1", "single", "one project"
    // Also ordinals: "second largest", "third best", "5th biggest"
    if (args.limit) {
      const hasExplicitNumericLimit = /\b(top|first|last|bottom|only|just|smallest|largest|biggest|lowest|highest|cheapest)\s+(\d+|active|open|won|closed|submitted|lead|qualified)\s*(\d+)?\b/i.test(userQuestion);
      const hasOrdinalRequest = /\b(second|third|fourth|fifth|sixth|seventh|eighth|ninth|tenth|\d+(st|nd|rd|th))\s+(largest|biggest|smallest|best|worst|highest|lowest)/i.test(userQuestion);
      const hasSingleRequest = /\b(single|one\s+project|1\s+project|the\s+largest|the\s+biggest|the\s+smallest|the\s+highest|the\s+lowest|the\s+best|the\s+worst)\b/i.test(userQuestion);
      
      const hasExplicitLimit = hasExplicitNumericLimit || hasOrdinalRequest || hasSingleRequest;
      
      if (!hasExplicitLimit) {
        console.log(`[Limit Guard] Removing limit=${args.limit} - no explicit limit requested in: "${userQuestion}"`);
        delete args.limit;
        delete args.offset;
      }
    }
    
    // GUARD: Redirect POC queries for known company names to organization queries
    // Companies like "Liro", "AECOM", "Jacobs" should be treated as organization, not POC
    if (classification.function_name === "get_projects_by_poc" && args.poc) {
      const knownCompanyPatterns = /\b(ais|gafcon|gei|hill|liro|palladium|stobg|aecom|jacobs|wsp|hdr|stantec|gannett|parsons|tetra|arcadis|kimley|horn|atkins|kiewit|fluor|bechtel|skanska|turner|mortenson|hensel|phelps|mccarthy|holder|brasfield|gorrie|gilbane|clark|walsh|balfour|beatty|vinci|bouygues|hochtief|royal|bam|samsung|hyundai|daewoo|obayashi|kajima|shimizu|taisei|takenaka)\b/i;
      if (knownCompanyPatterns.test(args.poc)) {
        console.log(`[POC-to-Company Guard] Redirecting POC "${args.poc}" to organization query`);
        classification.function_name = "get_projects_by_combined_filters";
        args.organization = args.poc;
        args._organization_override = true;

        delete args.poc;
        delete args._poc_already_applied;
      }
    }
    
    // GUARD: Detect known company names in query and force organization filter
    // This catches cases where LLM classifies query incorrectly (e.g., "Hill projects" as project type)
    const companyPattern = /\b(ais|gafcon|gei|hill|liro|palladium|stobg)\b/i;
    const companyMatch = userQuestion.match(companyPattern);
    console.log(`[DEBUG] Company Detection: userQuestion="${userQuestion}", companyMatch=${JSON.stringify(companyMatch)}, args.organization=${args.organization}, args._organization_already_applied=${args._organization_already_applied}`);
    if (companyMatch && !args.organization && !args._organization_already_applied) {
      const detectedCompany = companyMatch[1];
      // Check if query is asking about this as a company (not using it as a word in another context)
      const isCompanyContext = /\b(projects?|deals?|opportunities?|work|portfolio|revenue|fee|client)\s*(of|for|from|by|at)?\s*(ais|gafcon|gei|hill|liro|palladium|stobg)\b|\b(ais|gafcon|gei|hill|liro|palladium|stobg)\s*(projects?|deals?|opportunities?|company|work|portfolio)/i.test(userQuestion);
      if (isCompanyContext) {
        console.log(`[Company Detection Guard] Detected company "${detectedCompany}" in query - adding organization filter`);
        classification.function_name = "get_projects_by_combined_filters";
        args.organization = detectedCompany;
        args._organization_override = true;

        // Remove conflicting filters that might have been set incorrectly
        delete args.project_type;
        delete args.project_types;
        delete args._project_type_already_applied;
      }
    }
    
    // GUARD: When organization is a known company, remove conflicting category/keyword/project_type filters
    // The LLM sometimes sets organization correctly BUT also adds wrong categories like ["hill"]
    if (args.organization && args._organization_override) {
      const companyLower = args.organization.toLowerCase();
      const knownCompanies = ["ais", "gafcon", "gei", "hill", "liro", "palladium", "stobg"];
      if (knownCompanies.includes(companyLower)) {
        // Remove category filter if it matches the company name (incorrect classification)
        if (args.categories && Array.isArray(args.categories)) {
          const cleanedCategories = args.categories.filter((c: string) => c.toLowerCase() !== companyLower);
          if (cleanedCategories.length === 0) {
            console.log(`[Company Cleanup Guard] Removing incorrect categories: ${JSON.stringify(args.categories)}`);
        
       // Also remove singular form
          } else if (cleanedCategories.length < args.categories.length) {
            console.log(`[Company Cleanup Guard] Cleaned categories from ${JSON.stringify(args.categories)} to ${JSON.stringify(cleanedCategories)}`);
            args.categories = cleanedCategories;
          }
        }
        // Remove keyword if it matches the company name
        if (args.keyword && args.keyword.toLowerCase() === companyLower) {
          console.log(`[Company Cleanup Guard] Removing incorrect keyword: "${args.keyword}"`);
          delete args.keyword;
        }
        // Remove project_type filters that match the company name
        if (args.project_type && typeof args.project_type === "string" && args.project_type.toLowerCase() === companyLower) {
          console.log(`[Company Cleanup Guard] Removing incorrect project_type: "${args.project_type}"`);
          delete args.project_type;
        }
        if (args.project_types && Array.isArray(args.project_types)) {
          const cleanedTypes = args.project_types.filter((t: string) => t.toLowerCase() !== companyLower);
          if (cleanedTypes.length === 0) {
            console.log(`[Company Cleanup Guard] Removing incorrect project_types: ${JSON.stringify(args.project_types)}`);
            delete args.project_types;
          } else if (cleanedTypes.length < args.project_types.length) {
            args.project_types = cleanedTypes;
          }
        }
        // Remove tags that match the company name
        if (args.tags && Array.isArray(args.tags)) {
          const cleanedTags = args.tags.filter((t: string) => t.toLowerCase() !== companyLower);
          if (cleanedTags.length === 0) {
            console.log(`[Company Cleanup Guard] Removing incorrect tags: ${JSON.stringify(args.tags)}`);
          } else if (cleanedTags.length < args.tags.length) {
            console.log(`[Company Cleanup Guard] Cleaned tags from ${JSON.stringify(args.tags)} to ${JSON.stringify(cleanedTags)}`);
            args.tags = cleanedTags;
          }
        }
      }
    }
    
    // GUARD: Clear project_type when entity name (company/client/organization) contains project type keywords
    // This prevents "DFW Airport" from filtering by both Client="DFW Airport" AND ProjectType="Airports"
    const entityValue = args.company || args.client || args.organization;
    if (entityValue && args.project_type) {
      const projectTypeKeywordMap: Record<string, string[]> = {
        'Airports': ['airport', 'airports', 'aviation'],
        'Hospitals': ['hospital', 'hospitals', 'medical', 'health'],
        'Transit': ['transit', 'transportation', 'railway'],
        'K-12': ['school', 'schools'],
        'Higher Education': ['university', 'college'],
        'Government': ['government', 'civic', 'municipal'],
        'Water/Wastewater': ['water', 'wastewater', 'utility'],
        'Industrial': ['industrial', 'manufacturing', 'factory']
      };
      const entityLower = entityValue.toLowerCase();
      const ptVal = Array.isArray(args.project_type) ? args.project_type[0] : args.project_type;
      const keywords = projectTypeKeywordMap[ptVal] || [];
      if (keywords.some(kw => entityLower.includes(kw))) {
        console.log(`[Entity-ProjectType Guard] ğŸ§¹ Clearing project_type="${ptVal}" - keyword found in entity name "${entityValue}"`);
        delete args.project_type;
        delete args._project_type_explicit;
      }
    }
    
    
    // GUARD: Clear categories when entity name (company/client/organization) contains category keywords
    // This prevents "DFW Airport" from filtering by both Client="DFW Airport" AND categories=["Transportation"]
    if (entityValue && args.categories && Array.isArray(args.categories)) {
      const categoryKeywordMap: Record<string, string[]> = {
        'Transportation': ['airport', 'airports', 'aviation', 'transit', 'railway', 'airline', 'port'],
        'Healthcare': ['hospital', 'hospitals', 'medical', 'health', 'clinic'],
        'Education': ['school', 'schools', 'university', 'college', 'academy'],
        'Government': ['government', 'civic', 'municipal', 'federal', 'state'],
        'Water': ['water', 'wastewater', 'utility'],
        'Industrial': ['industrial', 'manufacturing', 'factory']
      };
      const entityLower = entityValue.toLowerCase();
      const filteredCategories = args.categories.filter((cat: string) => {
        const keywords = categoryKeywordMap[cat] || [];
        const hasKeyword = keywords.some(kw => entityLower.includes(kw));
        if (hasKeyword) {
          console.log(`[Entity-Category Guard] ğŸ§¹ Removing category="${cat}" - keyword found in entity name "${entityValue}"`);
          return false;
        }
        return true;
      });
      if (filteredCategories.length === 0) {
    
       // Also remove singular form
      } else if (filteredCategories.length !== args.categories.length) {
        args.categories = filteredCategories;
      }
    }

    // GUARD: Remove incorrectly parsed division/department when user is asking for columns in output
    const askingForColumns = /\b(with|including|show|display|add|include)\s+(the\s+)?(division|department|poc|contact|status|fee|client)/i.test(userQuestion);
    if (askingForColumns) {
      if (args.division && typeof args.division === "string" && /\d/.test(args.division)) {
        console.log(`[Column Request Guard] Removing incorrectly parsed division: "${args.division}"`);
        delete args.division;
        delete args.divisions;
      }
      if (args.departments && Array.isArray(args.departments)) {
        const badDepts = args.departments.filter((d: string) => /\d/.test(d) || d.length > 30);
        if (badDepts.length > 0) {
          console.log(`[Column Request Guard] Removing incorrectly parsed departments: ${JSON.stringify(badDepts)}`);
          delete args.departments;
        }
      }
    }
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    // COMPREHENSIVE OPEN/CLOSED STATUS DETECTION
    // Handles many natural language patterns for expressing project status
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    
    // OPEN synonyms: open, active, ongoing, in progress, current, live, running, pursuing, pending, in pipeline
    const OPEN_SYNONYMS = '(open|active|ongoing|in\\s*progress|current|live|running|pursuing|pending|in\\s*pipeline|in\\s*the\\s*works|underway|working|operating|available|in\\s*play|not\\s*closed|still\\s*open|still\\s*active)';
    
    // CLOSED synonyms: closed, inactive, done, finished, completed, ended, terminated, cancelled, lost, dead, stopped, concluded, over, past, historical, archived, killed
    const CLOSED_SYNONYMS = '(closed?|inactive|done|finished|completed|ended|terminated|cancel+ed|lost|dead|stopped|concluded|over|past|historical|archived|killed|defunct|wrapped\\s*up|shut\\s*down|not\\s*active|no\\s*longer\\s*active)';
    
    // Pattern 1: [status] [noun] - e.g., "open projects", "active deals", "closed opportunities"
    const pattern1Open = new RegExp(`\\b${OPEN_SYNONYMS}\\s+(?:\\w+\\s+)*?(projects?|deals?|opportunities?|items?|work|pipeline)\\b`, 'i');
    const pattern1Closed = new RegExp(`\\b${CLOSED_SYNONYMS}\\s+(?:\\w+\\s+)*?(projects?|deals?|opportunities?|items?|work|pipeline)\\b`, 'i');
    
    // Pattern 2: [noun] that/which are [status] - e.g., "projects that are open", "deals which are active"
    const pattern2Open = new RegExp(`\\b(projects?|deals?|opportunities?|items?|work)\\s+(that|which|currently|still)\\s+(are\\s+)?${OPEN_SYNONYMS}\\b`, 'i');
    const pattern2Closed = new RegExp(`\\b(projects?|deals?|opportunities?|items?|work)\\s+(that|which|currently|still)\\s+(are\\s+)?${CLOSED_SYNONYMS}\\b`, 'i');
    
    // Pattern 3: [noun] [preposition] [status] status - e.g., "projects with open status", "deals in active status"
    const pattern3Open = new RegExp(`\\b(projects?|deals?|opportunities?)\\s+(with|in|having|at)\\s+${OPEN_SYNONYMS}\\s*(status|state)?\\b`, 'i');
    const pattern3Closed = new RegExp(`\\b(projects?|deals?|opportunities?)\\s+(with|in|having|at)\\s+${CLOSED_SYNONYMS}\\s*(status|state)?\\b`, 'i');
    
    // Pattern 4: standalone status mentions with context - e.g., "show me active ones", "find all closed"
    const pattern4Open = new RegExp(`\\b(show|list|find|get|display|give)\\s+(me\\s+)?(all\\s+)?${OPEN_SYNONYMS}\\s*(ones?)?\\b`, 'i');
    const pattern4Closed = new RegExp(`\\b(show|list|find|get|display|give)\\s+(me\\s+)?(all\\s+)?${CLOSED_SYNONYMS}\\s*(ones?)?\\b`, 'i');
    
    // Pattern 5: "currently [status]" or "still [status]" - e.g., "currently active", "still open"
    const pattern5Open = new RegExp(`\\b(currently|still|presently|now)\\s+${OPEN_SYNONYMS}\\b`, 'i');
    const pattern5Closed = new RegExp(`\\b(currently|still|presently|now)\\s+${CLOSED_SYNONYMS}\\b`, 'i');
    
    // Pattern 6: negation patterns - "not closed" = open, "not active" = closed
    const negationOpen = /\b(not|isn't|aren't|is\s+not|are\s+not)\s+(closed?|inactive|done|finished|dead)\b/i;
    const negationClosed = /\b(not|isn't|aren't|is\s+not|are\s+not)\s+(open|active|ongoing|running|live)\b/i;
    
    // Pattern 7: [noun] [status] [time/date] - e.g., "projects closed in 2025", "deals closed last year"
    const pattern7Open = new RegExp(`\\b(projects?|deals?|opportunities?|items?|work)\\s+${OPEN_SYNONYMS}\\s+(in|since|from|during|last|this|between|for)\\b`, 'i');
    const pattern7Closed = new RegExp(`\\b(projects?|deals?|opportunities?|items?|work)\\s+${CLOSED_SYNONYMS}\\s+(in|since|from|during|last|this|between|for)\\b`, 'i');
    
    const hasOpenKeyword = pattern1Open.test(userQuestion) || pattern2Open.test(userQuestion) || 
                           pattern3Open.test(userQuestion) || pattern4Open.test(userQuestion) || 
                           pattern5Open.test(userQuestion) || pattern7Open.test(userQuestion) || negationOpen.test(userQuestion);
    const hasClosedKeyword = pattern1Closed.test(userQuestion) || pattern2Closed.test(userQuestion) || 
                             pattern3Closed.test(userQuestion) || pattern4Closed.test(userQuestion) || 
                             pattern5Closed.test(userQuestion) || pattern7Closed.test(userQuestion) || negationClosed.test(userQuestion);
    
    if (hasOpenKeyword) console.log(`[Status Guard] Detected OPEN status pattern in: "${userQuestion}"`);
    if (hasClosedKeyword) console.log(`[Status Guard] Detected CLOSED status pattern in: "${userQuestion}"`);
    // OPEN STATUS GUARD: When user says "open", ALWAYS force the correct open statuses
    if (hasOpenKeyword) {
      const correctOpenStatuses = ["Proposal Development", "Qualified Lead", "Submitted", "Won", "Lead", "In Progress", "Hold"];
      console.log(`[Status Guard] User said "open" - forcing open statuses: ${JSON.stringify(correctOpenStatuses)}. Was: ${JSON.stringify(args.status)}`);
      args.status = correctOpenStatuses;
    }
    // CLOSED STATUS GUARD: When user says "closed", filter on StatusChoice = Lost/No Go/Cancelled/Hold
    if (hasClosedKeyword) {
      const correctClosedStatuses = ["Lost", "No Go", "Cancelled"];
      console.log(`[Status Guard] User said "closed" - forcing closed statuses: ${JSON.stringify(correctClosedStatuses)}. Was: ${JSON.stringify(args.status)}`);
      args.status = correctClosedStatuses;
    }
    if (args.status) {
      // POST-PROCESSING GUARD: Split comma-separated or " or "-separated status strings into arrays
      // This handles cases where GPT returns "Proposal Development, Submitted" instead of ["Proposal Development", "Submitted"]
      if (typeof args.status === 'string' && (args.status.includes(',') || args.status.includes(' or ') || args.status.includes(' OR '))) {
        console.log(`[Status Split] Detected multi-status string: "${args.status}"`);
        // Split by comma, " or ", " OR " and trim each element
        args.status = args.status
          .split(/,|\s+or\s+/i)
          .map(s => s.trim())
          .filter(s => s.length > 0);
        console.log(`[Status Split] Split into array: ${JSON.stringify(args.status)}`);
      }
      
      // Handle both string and array status values
      if (Array.isArray(args.status) && args.status.length > 0) {
        // FIX: Convert old closed/open mappings to new ones
        const statusLowerArray = args.status.map((s: string) => s.toLowerCase());
        const hasWon = statusLowerArray.includes("won");
        const hasLost = statusLowerArray.includes("lost");
        const hasProposalDev = statusLowerArray.some((s: string) => s.includes("proposal"));
        // If status array is ["won", "lost"] (old closed definition) but NO open statuses, replace with new closed
        if (hasWon && hasLost && !hasProposalDev && statusLowerArray.length <= 4) {
          args.status = ["Lost", "No Go", "Cancelled"];
          console.log(`[Status Fix] Replaced old closed ["Won","Lost"] with ["Lost", "No Go", "Cancelled"]`);
        }
        // If status array has pursuing/dormant (old open), replace with new open
        else if (statusLowerArray.some((s: string) => s === "pursuing" || s === "dormant")) {
          args.status = ["Proposal Development", "Qualified Lead", "Submitted", "Won", "Lead", "In Progress", "Hold"];
          console.log(`[Status Fix] Replaced old open (Pursuing/Dormant) with correct statuses`);
        }
        // Normalize each status value in the array
        args.status = args.status.map((s: string) => {
          const status = s.toLowerCase();
          if (["won", "win", "winning", "successful", "awarded"].includes(status)) {
            return "won";
          } else if (["lost", "lose", "losing", "unsuccessful", "rejected"].includes(status)) {
            // Keep "lost" as-is - let the query run and return empty if not found
            // This is better than silently mapping to a different status
            console.log(`[Status Normalization] Keeping "lost" as requested (may return empty results if status doesn't exist)`);
            return "lost";
          } else if (["submit", "submitted", "pending", "awaiting"].includes(status)) {
            return "submitted";
          } else if (["lead", "leads", "opportunity", "opportunities"].includes(status)) {
            return "lead";
          } else if (["proposal", "proposal development", "developing"].includes(status)) {
            return "proposal development";
          } else if (["hold", "holding", "paused", "abandoned"].includes(status)) {
            return "hold";
          // "active", "ongoing", "current" should expand to all open statuses, NOT just "in progress"
          // Only "in progress", "progress", "working" map to the specific "In Progress" status
          } else if (["in progress", "progress", "working"].includes(status)) {
            return "in progress";
          } else if (["qualified", "qualified lead"].includes(status)) {
            return "qualified lead";
          }
          return s; // Keep original if no match
        });
      } else {
        // Single status value
        const status = args.status.toLowerCase();
        // Handle "open" and "closed" as special multi-status keywords
        // "open", "active", "ongoing", "current" all mean ALL open statuses
        if (["open", "active", "ongoing", "current"].includes(status)) {
          args.status = ["Proposal Development", "Qualified Lead", "Submitted", "Won", "Lead", "In Progress", "Hold"];
          console.log(`[Status Normalization] Converted "open" â†’ ["Proposal Development", "Qualified Lead", "Submitted", "Won", "Lead", "In Progress", "Hold"]`);
          return classification; // Exit early since we changed to array
        } else if (["closed", "close"].includes(status)) {
          args.status = ["Lost", "No Go", "Cancelled"];
          console.log(`[Status Normalization] Converted "closed" â†’ ["Lost", "No Go", "Cancelled"]`);
          return classification; // Exit early since we changed to array
        }
        if (["won", "win", "winning", "successful", "awarded"].includes(status)) {
          args.status = "won";
        } else if (["lost", "lose", "losing", "unsuccessful", "rejected"].includes(status)) {
          // Keep "lost" as-is - let the query run and return empty if not found
          // This is more intuitive than silently mapping to a different status
          console.log(`[Status Normalization] Keeping "lost" as requested (may return empty results if status doesn't exist)`);
          console.log(`[Status Normalization]    Available statuses in database: Hold, In Progress, Lead, Proposal Development, Qualified Lead, Submitted, Won`);
          args.status = "lost";
        } else if (["submit", "submitted", "pending", "awaiting"].includes(status)) {
          args.status = "submitted";
        } else if (["lead", "leads", "opportunity", "opportunities"].includes(status)) {
          args.status = "lead";
        } else if (["proposal", "proposal development", "developing"].includes(status)) {
          args.status = "proposal development";
        } else if (["hold", "holding", "paused", "abandoned"].includes(status)) {
          args.status = "hold";
        } else if (["in progress", "progress", "working"].includes(status)) {
          args.status = "in progress";
        } else if (["qualified", "qualified lead"].includes(status)) {
          args.status = "qualified lead";
        }
      }
    }

    // Smart reference_pid resolution: Handle placeholders and superlatives
    if (args.reference_pid) {
      const refLower = args.reference_pid.toLowerCase().trim();
      
      // STEP 1: Try to extract a concrete PID/ID from the string FIRST
      // Patterns to match: "PID 820", "820", "project 820", etc.
      const pidPatterns = [
        /(?:pid\s*[:#-]?\s*)(\d+)/i,           // "PID 820", "PID: 820", "PID #820"
        /(?:project\s+)(\d+)/i,                 // "project 820"
        /(?:id\s*[:#-]?\s*)(\d+)/i,            // "ID 820", "ID: 820"
        /\b(\d{3,})\b/,                         // Standalone number with 3+ digits (e.g., "820")
      ];
      
      let extractedPID: string | null = null;
      for (const pattern of pidPatterns) {
        const match = args.reference_pid.match(pattern);
        if (match && match[1]) {
          extractedPID = match[1];
          console.log(`[PID Extraction] âœ“ Found PID "${extractedPID}" in "${args.reference_pid}"`);
          args.reference_pid = `PID ${extractedPID}`;
          break;
        }
      }
      
      // STEP 2: Only run PLACEHOLDER DETECTION if NO concrete PID was found
      if (!extractedPID) {
        const placeholderPatterns = [
          /^a\s+given\s+(project|pursuit|item|record)/i,
          /^the\s+given\s+(project|pursuit|item|record)/i,
          /^selected\s+(project|pursuit|item|record|client|company)/i,
          /^the\s+selected\s+(project|pursuit|item|record|client|company)/i,
          /^this\s+(project|pursuit|item|record)/i,
          /^that\s+(project|pursuit|item|record)/i,
          /^same\s+(tags|attributes|categories|type|status)/i,
          /^the\s+same\s+(tags|attributes|categories|type|status)/i,
        ];
        
        const isPlaceholder = placeholderPatterns.some(pattern => pattern.test(refLower));
        
        if (isPlaceholder) {
          console.log(`[Placeholder Detection] âš ï¸ Reference "${args.reference_pid}" is a PLACEHOLDER`);
          console.log(`[Placeholder Detection]    User needs to specify an actual project ID (e.g., "PID 820")`);
          // Return error message asking for clarification
          throw new Error(`Please specify which project you want to find similar projects to. For example: "Show similar projects to PID 820" or "Find projects similar to the first one in the results"`);
        }
      }
      
      // SUPERLATIVE RESOLUTION: "most challenging", "biggest", "largest", etc.
      const superlativePatterns = {
        'most challenging': { sort: 'fee', order: 'desc', label: 'highest-value' },
        'biggest': { sort: 'fee', order: 'desc', label: 'highest-value' },
        'largest': { sort: 'fee', order: 'desc', label: 'highest-value' },
        'highest': { sort: 'fee', order: 'desc', label: 'highest-value' },
        'most expensive': { sort: 'fee', order: 'desc', label: 'highest-value' },
        'smallest': { sort: 'fee', order: 'asc', label: 'lowest-value' },
        'cheapest': { sort: 'fee', order: 'asc', label: 'lowest-value' },
        'least expensive': { sort: 'fee', order: 'asc', label: 'lowest-value' },
        'most likely': { sort: 'win', order: 'desc', label: 'highest win rate' },
        'least likely': { sort: 'win', order: 'asc', label: 'lowest win rate' },
      };
      
      let matchedSuperlative: { sort: string; order: string; label: string } | null = null;
      for (const [pattern, config] of Object.entries(superlativePatterns)) {
        if (refLower.includes(pattern)) {
          matchedSuperlative = config;
          break;
        }
      }
      
      if (matchedSuperlative && previousContext?.result_data && previousContext.result_data.length > 0) {
        // Auto-resolve from previous results
        console.log(`[Superlative Resolution] Detected "${args.reference_pid}" - resolving to ${matchedSuperlative.label} from previous ${previousContext.result_data.length} results`);
        
        // Helper to parse numeric values with commas and currency symbols
        const parseNumeric = (value: string | number | undefined): number => {
          if (value === undefined || value === null || value === '') return 0;
          if (typeof value === 'number') return value;
          // Remove commas, dollar signs, and other currency symbols
          const cleaned = String(value).replace(/[$,]/g, '').trim();
          const parsed = parseFloat(cleaned);
          return isNaN(parsed) ? 0 : parsed;
        };
        
        // Sort previous results by the specified field
        const sortedResults = [...previousContext.result_data].sort((a, b) => {
          let aVal = 0, bVal = 0;
          
          if (matchedSuperlative!.sort === 'fee') {
            aVal = parseNumeric(a.Fee);
            bVal = parseNumeric(b.Fee);
          } else if (matchedSuperlative!.sort === 'win') {
            aVal = parseNumeric(a['Win %']);
            bVal = parseNumeric(b['Win %']);
          }
          
          return matchedSuperlative!.order === 'desc' ? bVal - aVal : aVal - bVal;
        });
        
        const topResult = sortedResults[0];
        if (topResult && topResult['Project Name']) {
          const resolvedPid = topResult['Project Name'];
          args.reference_pid = resolvedPid;
          const feeM = parseNumeric(topResult.Fee) / 1000000;
          const winPct = parseNumeric(topResult['Win %']);
          console.log(`[Superlative Resolution] âœ“ Resolved to: ${resolvedPid}`);
          console.log(`[Superlative Resolution]   Fee: $${feeM.toFixed(1)}M, Win: ${winPct}%`);
          console.log(`[Superlative Resolution]   From ${previousContext.result_data.length} previous results`);
        } else {
          console.log(`[Superlative Resolution] âš ï¸ Could not extract Project Name from top result`);
          console.log(`[Superlative Resolution]   Top result keys: ${Object.keys(topResult || {}).join(', ')}`);
        }
      } else if (matchedSuperlative && (!previousContext || !previousContext.result_data || previousContext.result_data.length === 0)) {
        console.log(`[Superlative Resolution] âš ï¸ Detected superlative "${args.reference_pid}" but no previous results available`);
        throw new Error(`To find similar projects to "the ${matchedSuperlative.label} project", please:
1. First run a query to get some projects (e.g., "Show all projects starting in 2026")
2. Then use the "Ask a follow-up question" button below those results
3. Type: "Show similar projects to ${args.reference_pid}"

Alternatively, specify a project directly: "Show similar projects to PID 820"`);
      }
    }

    // Extract limit from question if not provided
    if (!args.limit) {
      const limit = NumberCalculator.parseLimit(userQuestion);
      if (limit) {
        args.limit = limit;
      }
    }

    // Detect "last X" vs "top X" pattern for sort direction
    // "last X" = lowest fees (ASC), "top X" / "first X" = highest fees (DESC)
    if (args.limit && !args.sort_direction) {
      const lowerQuestion = userQuestion.toLowerCase();
      const lastPattern = /\b(last|bottom|lowest|smallest)\s+\d+/i;
      const topPattern = /\b(top|first|highest|largest|biggest)\s+\d+/i;
      
      if (lastPattern.test(lowerQuestion)) {
        args.sort_direction = "ASC";
        console.log(`[Sort Direction] Detected "last X" pattern â†’ ASC (lowest first)`);
      } else if (topPattern.test(lowerQuestion)) {
        args.sort_direction = "DESC";
        console.log(`[Sort Direction] Detected "top X" pattern â†’ DESC (highest first)`);
      }
    }

    // Calculate percentiles for size-based queries
    if (args.size || classification.function_name === "get_size_distribution") {
      await this.sizeCalculator.calculatePercentiles(externalDbQuery, false, TABLE);
    }

    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    // FINAL GUARD: Ensure "this year" queries use YEAR() filter
    // This is a safety net - semantic parsing may have set start_date instead of year
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    const currentYearFinal = new Date().getFullYear();
    const thisYearPatternFinal = /\b(this\s+year|current\s+year|starting\s+this\s+year)\b/i;
    
    // If user asked for "this year", set flag and year parameter
    if (thisYearPatternFinal.test(userQuestion)) {
      args._this_year_detected = true; // Flag for buildAdditionalFilters
      if (!args.year) {
        args.year = currentYearFinal;
        console.log(`[preprocessQuery] ğŸ“… FINAL GUARD: Detected "this year", setting year=${currentYearFinal}`);
      }
    }
    
    // If year is set (from any source), remove date range filters
    if (args.year !== undefined && args.year !== null && !isNaN(Number(args.year))) {
      if (args.start_date || args.end_date) {
        console.log(`[preprocessQuery] ğŸ“… FINAL GUARD: Year filter (${args.year}) set, removing redundant dates`);
        console.log(`[preprocessQuery]   Removing: start_date=${args.start_date}, end_date=${args.end_date}`);
        delete args.start_date;
        delete args.end_date;
        args._date_already_applied = true;
      }
    }

    return classification;
  }

  /**
   * Normalize status values to match database values
   * Note: "closed" is handled separately as it maps to BOTH "Won" and "Lost"
   */
  private normalizeStatus(status: string): string | string[] {
    const statusLower = status.toLowerCase().trim();
    
    
    // "Closed" = Lost, No Go, Cancelled, Hold (deals no longer in pipeline)
    if (["closed", "close"].includes(statusLower)) {
      console.log(`[Status Normalization] "closed" â†’ ["Lost", "No Go", "Cancelled"]`);
      return ["Lost", "No Go", "Cancelled"];
    }
    
    // "Open" = Proposal Development, Qualified Lead, Submitted, Won (active pipeline)
    if (["open"].includes(statusLower)) {
      console.log(`[Status Normalization] "open" â†’ ["Proposal Development", "Qualified Lead", "Submitted", "Won", "Lead", "In Progress", "Hold"]`);
      return ["Proposal Development", "Qualified Lead", "Submitted", "Won", "Lead", "In Progress", "Hold"];
    }
    
    // Won status - includes "successfully", "done", "finished", "completed"
    if (["won", "win", "winning", "successful", "successfully", "awarded", "done", "finished", "completed", "complete"].includes(statusLower)) {
      return "won";
    } else if (["lost", "lose", "losing", "unsuccessful", "rejected", "failed"].includes(statusLower)) {
      // Keep "lost" as-is - let the query run and return empty if not found
      console.log(`[Status Normalization] Keeping "lost" as requested (may return empty results)`);
      return "lost";
    } else if (["submit", "submitted", "pending", "awaiting", "under review", "review"].includes(statusLower)) {
      return "submitted";
    } else if (["lead", "leads", "opportunity", "opportunities", "prospect", "prospects"].includes(statusLower)) {
      return "lead";
    } else if (["proposal", "proposal development", "developing", "in development"].includes(statusLower)) {
      return "proposal development";
    } else if (["hold", "holding", "paused", "abandoned", "on hold"].includes(statusLower)) {
      return "hold";
    } else if (["in progress", "progress", "working"].includes(statusLower)) {
      return "in progress";
    // NOTE: "active", "ongoing", "current" are NOT mapped here - they mean ALL open statuses
    // and should be handled at a higher level before calling this function
    } else if (["qualified", "qualified lead"].includes(statusLower)) {
      return "qualified lead";
    }
    
    return statusLower;
  }

  /**
   * Apply in-memory filters to context data for follow-up questions with numeric conditions.
   * Handles patterns like "fee above 20M", "win% over 50%", etc.
   */
  private applyInMemoryContextFilters(
    question: string,
    contextData: any[]
  ): { applied: boolean; data: any[]; conditions: string[] } {
    if (!contextData || contextData.length === 0) {
      return { applied: false, data: [], conditions: [] };
    }

    const questionLower = question.toLowerCase();
    const conditions: string[] = [];
    let filteredData = [...contextData];

    // Helper to parse numeric values (handles 20M, 50%, commas, etc.)
    const parseNumber = (value: string | number | undefined): number => {
      if (value === undefined || value === null || value === '') return 0;
      if (typeof value === 'number') return value;
      
      let str = String(value).replace(/[$,]/g, '').trim();
      
      // Handle M/K suffixes
      const multiplierMatch = str.match(/^([\d.]+)\s*(m|k|b)?$/i);
      if (multiplierMatch) {
        const num = parseFloat(multiplierMatch[1]);
        const suffix = (multiplierMatch[2] || '').toLowerCase();
        if (suffix === 'm') return num * 1_000_000;
        if (suffix === 'k') return num * 1_000;
        if (suffix === 'b') return num * 1_000_000_000;
        return num;
      }
      
      // Handle percentage sign
      str = str.replace(/%$/, '');
      
      const parsed = parseFloat(str);
      return isNaN(parsed) ? 0 : parsed;
    };

    // Parse threshold from question text (e.g., "above 20M" â†’ 20000000)
    const parseThresholdFromQuestion = (text: string): number | null => {
      if (!text || text.trim() === '') return null;
      
      // Clean the text and try to match a number with optional suffix
      const cleanText = text.trim().replace(/,/g, '');
      const match = cleanText.match(/^([\d.]+)\s*(m|k|b|million|thousand|billion)?$/i);
      if (!match) return null;
      
      const num = parseFloat(match[1]);
      if (isNaN(num) || num <= 0) return null;
      
      const suffix = (match[2] || '').toLowerCase();
      if (suffix === 'm' || suffix === 'million') return num * 1_000_000;
      if (suffix === 'k' || suffix === 'thousand') return num * 1_000;
      if (suffix === 'b' || suffix === 'billion') return num * 1_000_000_000;
      return num;
    };

    // FILTER PATTERNS for Fee (also handles "budget", "cost")
    // NOTE: Requires explicit numeric threshold - "budget over 2 million" works, "highest budget" does NOT
    const feePatterns = [
      { pattern: /\b(?:fee|budget|budgets|cost|costs)\s+(?:above|over|greater\s+than|more\s+than|exceeds?|>\s*=?)\s*([\d.,]+\s*[mkb]?(?:illion|housand)?)/i, op: '>' },
      { pattern: /\b(?:fee|budget|budgets|cost|costs)\s+(?:below|under|less\s+than|<\s*=?)\s*([\d.,]+\s*[mkb]?(?:illion|housand)?)/i, op: '<' },
      { pattern: /\b(?:fee|budget|budgets|cost|costs)\s+(?:at\s+least|minimum|>=)\s*([\d.,]+\s*[mkb]?(?:illion|housand)?)/i, op: '>=' },
      { pattern: /\b(?:fee|budget|budgets|cost|costs)\s+(?:at\s+most|maximum|<=)\s*([\d.,]+\s*[mkb]?(?:illion|housand)?)/i, op: '<=' },
      // Alternative patterns: "above X budget/fee", "over 2 million"
      { pattern: /(?:above|over|greater\s+than|more\s+than|>\s*=?)\s*([\d.,]+\s*[mkb]?(?:illion|housand)?)\s*(?:fee|budget|cost|in\s+fee|in\s+budget)/i, op: '>' },
      // Pattern for "budgets over X" without explicit keyword after number
      { pattern: /\b(?:budgets?|costs?|fee)\s+(?:over|above)\s+([\d.,]+\s*[mkb]?(?:illion|housand)?)/i, op: '>' },
    ];

    for (const { pattern, op } of feePatterns) {
      const match = questionLower.match(pattern);
      if (match) {
        const threshold = parseThresholdFromQuestion(match[1]);
        if (threshold !== null) {
          conditions.push(`Fee ${op} ${threshold.toLocaleString()}`);
          filteredData = filteredData.filter(row => {
            const fee = parseNumber(row.Fee);
            switch (op) {
              case '>': return fee > threshold;
              case '<': return fee < threshold;
              case '>=': return fee >= threshold;
              case '<=': return fee <= threshold;
              default: return true;
            }
          });
          break; // Only apply one fee filter
        }
      }
    }

    // FILTER PATTERNS for Win %
    // "win% over/above 50%", "probability above 50", "win rate over 50"
    const winPatterns = [
      { pattern: /\b(?:win\s*%?|win\s+rate|win\s+probability|probability|likelihood)\s+(?:above|over|greater\s+than|more\s+than|exceeds?|>\s*=?)\s*([\d.]+)\s*%?/i, op: '>' },
      { pattern: /\b(?:win\s*%?|win\s+rate|win\s+probability|probability|likelihood)\s+(?:below|under|less\s+than|<\s*=?)\s*([\d.]+)\s*%?/i, op: '<' },
      { pattern: /\b(?:win\s*%?|win\s+rate|win\s+probability|probability|likelihood)\s+(?:at\s+least|minimum|>=)\s*([\d.]+)\s*%?/i, op: '>=' },
      { pattern: /\b(?:win\s*%?|win\s+rate|win\s+probability|probability|likelihood)\s+(?:at\s+most|maximum|<=)\s*([\d.]+)\s*%?/i, op: '<=' },
      // Alternative patterns: "over 50% win", "above 50% probability"
      { pattern: /(?:above|over|greater\s+than|more\s+than|>\s*=?)\s*([\d.]+)\s*%?\s*(?:win|probability)/i, op: '>' },
    ];

    for (const { pattern, op } of winPatterns) {
      const match = questionLower.match(pattern);
      if (match) {
        const threshold = parseFloat(match[1]);
        if (!isNaN(threshold)) {
          conditions.push(`Win% ${op} ${threshold}%`);
          filteredData = filteredData.filter(row => {
            const winPct = parseNumber(row['Win %']);
            switch (op) {
              case '>': return winPct > threshold;
              case '<': return winPct < threshold;
              case '>=': return winPct >= threshold;
              case '<=': return winPct <= threshold;
              default: return true;
            }
          });
          break; // Only apply one win% filter
        }
      }
    }

    // FILTER PATTERNS for Project Type (in-memory filtering for follow-ups)
    // "relate to higher education", "medical buildings", "are hospitals", "International Development only"
    const projectTypePatterns = [
      { pattern: /\b(?:relate(?:s?|d)?|about|for|involving)\s+(?:to\s+)?higher\s+education\b/i, type: 'Higher Education' },
      { pattern: /\b(?:are|is)\s+higher\s+education\b/i, type: 'Higher Education' },
      { pattern: /\bhigher\s+education\s+(?:projects?|ones?)?\s*(?:only)?\b/i, type: 'Higher Education' },
      { pattern: /\b(?:relate(?:s?|d)?|about|for|involving)\s+(?:to\s+)?hospital/i, type: 'Hospitals' },
      { pattern: /\b(?:are|is)\s+hospitals?\b/i, type: 'Hospitals' },
      { pattern: /\bhospitals?\s+(?:projects?|ones?)?\s*(?:only)?\b/i, type: 'Hospitals' },
      { pattern: /\bmedical\s+buildings?\b/i, type: 'Medical Buildings' },
      { pattern: /\bmedical\s+facilities?\b/i, type: 'Hospitals' },
      // International Development patterns
      { pattern: /\binternational\s+development\s+(?:projects?|ones?)?\s*(?:only)?\b/i, type: 'International Development' },
      { pattern: /\b(?:relate(?:s?|d)?|about|for|involving)\s+(?:to\s+)?international\s+development\b/i, type: 'International Development' },
      { pattern: /\b(?:are|is)\s+international\s+development\b/i, type: 'International Development' },
      // Transportation patterns
      { pattern: /\btransportation\s+(?:projects?|ones?)?\s*(?:only)?\b/i, type: 'Transportation' },
      // Bridges patterns
      { pattern: /\bbridges?\s+(?:projects?|ones?)?\s*(?:only)?\b/i, type: 'Bridges' },
      // Generic patterns
      { pattern: /\b(?:relate(?:s?|d)?|about|for|involving)\s+(?:to\s+)?buildings?\s+(?:or\s+)?facilities?\b/i, type: null }, // Generic - search description
      { pattern: /\b(?:relate(?:s?|d)?|about|for|involving)\s+(?:to\s+)?(?:solar|energy)\b/i, type: null }, // Use description search
    ];

    for (const { pattern, type } of projectTypePatterns) {
      if (pattern.test(questionLower)) {
        if (type) {
          conditions.push(`Project Type = ${type}`);
          const typeLower = type.toLowerCase();
          filteredData = filteredData.filter(row => {
            // Try both "ProjectType" and "ProjectType" column names
            const projectType = String(row['Project Type'] || row['ProjectType'] || row['project_type'] || '').toLowerCase();
            return projectType.includes(typeLower);
          });
        }
        break;
      }
    }

    // FILTER PATTERNS for Description search (for generic keyword follow-ups)
    // "relate to buildings or facilities", "about airports", "municipal", "energy"
    const descriptionKeywordPatterns = [
      { pattern: /\b(?:relate(?:s?|d)?|about|involving|mention)\s+(?:to\s+)?buildings?\s+(?:or\s+)?facilities?\b/i, keywords: ['building', 'facility'] },
      { pattern: /\b(?:relate(?:s?|d)?|about|involving|mention)\s+(?:to\s+)?(?:airport|airports)\b/i, keywords: ['airport'] },
      { pattern: /\bmunicipal\b/i, keywords: ['municipal', 'municipality', 'city'] },
      { pattern: /\b(?:relate(?:s?|d)?|about|involving|mention)\s+(?:to\s+)?energy\b/i, keywords: ['energy', 'power', 'electric'] },
    ];

    for (const { pattern, keywords } of descriptionKeywordPatterns) {
      if (pattern.test(questionLower) && conditions.length === 0) { // Only apply if no other condition matched
        conditions.push(`Description contains: ${keywords.join(' OR ')}`);
        filteredData = filteredData.filter(row => {
          const description = String(row['Description'] || '').toLowerCase();
          const projectName = String(row['Project Name'] || '').toLowerCase();
          const tags = String(row['Tags'] || '').toLowerCase();
          // Match if any keyword is found in description, project name, or tags
          return keywords.some(kw => 
            description.includes(kw) || projectName.includes(kw) || tags.includes(kw)
          );
        });
        break;
      }
    }

    // FILTER PATTERNS for Date/Year
    // "starting this year", "starting next year", "begin in 2025", "starting in 2026"
    const currentYear = new Date().getFullYear();
    
    // Helper to get start date from row with multiple possible column names
    const getStartDate = (row: any): string | null => {
      const value = row['Start Date'] || row['StartDate'] || row['start_date'] || row['startDate'];
      if (!value) return null;
      
      // Handle Date objects
      if (value instanceof Date) {
        return value.toISOString().split('T')[0];
      }
      
      const strValue = String(value).trim();
      
      // Check for ISO format (YYYY-MM-DD or YYYY-MM-DDTHH:mm:ss)
      if (/^\d{4}-\d{2}-\d{2}/.test(strValue)) {
        return strValue.split('T')[0];
      }
      
      // Check for MM/DD/YYYY format
      const mdyMatch = strValue.match(/^(\d{1,2})\/(\d{1,2})\/(\d{4})/);
      if (mdyMatch) {
        const month = mdyMatch[1].padStart(2, '0');
        const day = mdyMatch[2].padStart(2, '0');
        const year = mdyMatch[3];
        return `${year}-${month}-${day}`;
      }
      
      // Check for DD/MM/YYYY format (common in some locales)
      const dmyMatch = strValue.match(/^(\d{1,2})-(\d{1,2})-(\d{4})/);
      if (dmyMatch) {
        const day = dmyMatch[1].padStart(2, '0');
        const month = dmyMatch[2].padStart(2, '0');
        const year = dmyMatch[3];
        return `${year}-${month}-${day}`;
      }
      
      // Try to parse as a date and normalize
      const parsed = new Date(strValue);
      if (!isNaN(parsed.getTime())) {
        return parsed.toISOString().split('T')[0];
      }
      
      return null;
    };
    
    // Check for "this year" pattern
    if (/\b(starting|start|begin|beginning)\s+(this\s+year|in\s+this\s+year)\b/i.test(questionLower) ||
        /\b(this\s+year).{0,20}(starting|begin)/i.test(questionLower)) {
      const yearStart = `${currentYear}-01-01`;
      const yearEnd = `${currentYear}-12-31`;
      conditions.push(`Start Date in ${currentYear}`);
      filteredData = filteredData.filter(row => {
        const dateStr = getStartDate(row);
        if (!dateStr) return false;
        return dateStr >= yearStart && dateStr <= yearEnd;
      });
    }
    
    // Check for "next year" pattern
    else if (/\b(starting|start|begin|beginning)\s+(next\s+year|in\s+next\s+year)\b/i.test(questionLower) ||
             /\b(next\s+year).{0,20}(starting|begin)/i.test(questionLower)) {
      const nextYear = currentYear + 1;
      const yearStart = `${nextYear}-01-01`;
      const yearEnd = `${nextYear}-12-31`;
      conditions.push(`Start Date in ${nextYear}`);
      filteredData = filteredData.filter(row => {
        const dateStr = getStartDate(row);
        if (!dateStr) return false;
        return dateStr >= yearStart && dateStr <= yearEnd;
      });
    }
    
    // Check for specific year pattern (e.g., "starting in 2025", "begin in the 2026 cycle")
    else {
      const specificYearMatch = questionLower.match(/\b(?:starting|start|begin|beginning)\s+(?:in\s+)?(?:the\s+)?(\d{4})(?:\s+cycle)?\b/i);
      if (specificYearMatch) {
        const year = parseInt(specificYearMatch[1], 10);
        const yearStart = `${year}-01-01`;
        const yearEnd = `${year}-12-31`;
        conditions.push(`Start Date in ${year}`);
        filteredData = filteredData.filter(row => {
          const dateStr = getStartDate(row);
          if (!dateStr) return false;
          return dateStr >= yearStart && dateStr <= yearEnd;
        });
      }
    }

    // Only mark as applied if we found and applied at least one condition
    if (conditions.length > 0) {
      console.log(`[InMemoryFilter] Applied ${conditions.length} filter(s): ${conditions.join(', ')}`);
      console.log(`[InMemoryFilter] Filtered ${contextData.length} â†’ ${filteredData.length} results`);
      return { applied: true, data: filteredData, conditions };
    }

    return { applied: false, data: contextData, conditions: [] };
  }

  /**
   * Helper function to substitute parameters into SQL query for logging
   */
  private substituteParams(sql: string, params: any[]): string {
    let result = sql;
    params.forEach((param, index) => {
      const placeholder = `$${index + 1}`;
      let value: string;
      
      if (param === null || param === undefined) {
        value = 'NULL';
      } else if (typeof param === 'string') {
        value = `'${param.replace(/'/g, "''")}'`;
      } else if (Array.isArray(param)) {
        value = `ARRAY[${param.map(v => typeof v === 'string' ? `'${v.replace(/'/g, "''")}'` : v).join(', ')}]`;
      } else if (typeof param === 'number' || typeof param === 'boolean') {
        value = String(param);
      } else {
        value = `'${String(param).replace(/'/g, "''")}'`;
      }
      
      result = result.replace(new RegExp('\\$' + (index + 1) + '(?=\\D|$)', 'g'), value);
    });
    
    return result;
  }

  /**
   * Security check: Validates that SQL is read-only (SELECT only)
   */
  private isReadOnlySQL(sql: string): boolean {
    const sqlUpper = sql.toUpperCase().trim();
    
    // Block any destructive operations (as SQL statements, not functions)
    const destructiveStatements = [
      'INSERT ', 'UPDATE ', 'DELETE ', 'DROP ', 'ALTER ', 'TRUNCATE ', 
      'CREATE ', 'RENAME ', 'GRANT ', 'REVOKE '
    ];
    
    for (const statement of destructiveStatements) {
      // Check for statement at start or after whitespace/semicolon
      const pattern = new RegExp(`(^|[\\s;])${statement}`, 'i');
      if (pattern.test(sql)) {
        return false;
      }
    }
    
    // Only allow SELECT statements (including WITH...SELECT)
    // Note: REPLACE() function is allowed, but REPLACE statement is blocked above
    return sqlUpper.startsWith('SELECT') || sqlUpper.startsWith('WITH');
  }

  /**
   * Parse ordinal position from text (first, second, third, 1st, 2nd, etc.)
   * Returns the position number (1-indexed) or null if not an ordinal
   */
  private parseOrdinalPosition(text: string): number | null {
    const lowerText = text.toLowerCase().trim();
    
    // Handle word-based ordinals
    const wordOrdinals: Record<string, number> = {
      'first': 1,
      'second': 2,
      'third': 3,
      'fourth': 4,
      'fifth': 5,
      'sixth': 6,
      'seventh': 7,
      'eighth': 8,
      'ninth': 9,
      'tenth': 10,
    };
    
    // Check for word-based ordinals with optional "project"
    for (const [word, position] of Object.entries(wordOrdinals)) {
      const regex = new RegExp(`\\b${word}(?:\\s+project)?\\b`, 'i');
      if (regex.test(lowerText)) {
        return position;
      }
    }
    
    // Handle numeric ordinals (1st, 2nd, 3rd, 4th, etc.)
    const numericMatch = lowerText.match(/(\d+)(?:st|nd|rd|th)(?:\s+project)?/);
    if (numericMatch) {
      return parseInt(numericMatch[1], 10);
    }
    
    return null;
  }

  /**
   * Handle AI-powered data analysis queries
   * Fetches relevant data and uses GPT-5 to provide analytical insights
   */
  private async handleAIDataAnalysis(
    args: Record<string, any>,
    externalDbQuery: (sql: string, params?: any[]) => Promise<any[]>
  ): Promise<{ success: boolean; question?: string; function_name?: string; arguments?: Record<string, any>; data: any[]; row_count?: number; summary?: any; chart_config?: any; message?: string; error?: string; sql_query?: string; sql_params?: any[] }> {
    try {
      // SAFETY NET: If categories is set but project_type is not, treat categories as project_type
      // This handles cases where AI incorrectly populated categories instead of project_type
      // The main guard in processQuery should catch this, but this is a backup
      if (args.categories && !args.project_type && !args.project_types) {
        const categoriesArray = Array.isArray(args.categories) ? args.categories : [args.categories];
        if (categoriesArray.length > 0) {
          console.log(`[AI Analysis] âš ï¸ SAFETY NET: Moving categories to project_type`);
          args.project_type = categoriesArray[0];
      
       // Also remove singular form
        }
      }
      
      const { analysis_question, status, categories, project_type, tags, min_fee, max_fee, time_reference, start_date, end_date } = args;
      
      // Parse time_reference if provided
      let actualStartDate = start_date;
      let actualEndDate = end_date;
      
      if (time_reference && !start_date && !end_date) {
        const parser = new SemanticTimeParser();
        const dateResult = parser.parse(time_reference);
        
        // Check if parsing succeeded (returns [startDate, endDate] or null)
        if (dateResult && Array.isArray(dateResult) && dateResult.length === 2) {
          actualStartDate = dateResult[0];
          actualEndDate = dateResult[1];
          console.log(`[AI Analysis] Parsed time_reference "${time_reference}" â†’ ${actualStartDate} to ${actualEndDate}`);
        } else {
          console.log(`[AI Analysis] Could not parse time_reference "${time_reference}", proceeding without date filter`);
        }
      }
      
      console.log(`[AI Analysis] Question: "${analysis_question}"`);
      console.log(`[AI Analysis] Filters:`, { status, categories, project_type, tags, min_fee, max_fee, start_date: actualStartDate, end_date: actualEndDate });
      
      // Build WHERE clauses with parameterized queries
      const whereClauses: string[] = ['1=1'];
      const params: any[] = [];
      let paramIndex = 1;
      
      if (status) {
        // Handle both single status and array of statuses
        if (Array.isArray(status)) {
          const statusConditions = status.map((s: string) => {
            const condition = `"StatusChoice" LIKE @p${paramIndex}`;
            params.push(`%${s}%`);
            paramIndex++;
            return condition;
          });
          whereClauses.push(`(${statusConditions.join(' OR ')})`);
        } else {
          whereClauses.push(`"StatusChoice" LIKE @p${paramIndex++}`);
          params.push(`%${status}%`);
        }
      }
      
      if (categories && Array.isArray(categories) && categories.length > 0) {
        const categoryConditions = categories.map((c: string) => {
          const condition = `"RequestCategory" LIKE @p${paramIndex}`;
          params.push(`%${c}%`);
          paramIndex++;
          return condition;
        });
        whereClauses.push(`(${categoryConditions.join(' OR ')})`);
      }
      
      // Add project_type filtering (Project Type column - specific types like 'Hospitals', 'Bridges')
      if (project_type) {
        whereClauses.push(`"ProjectType" LIKE @p${paramIndex++}`);
        params.push(`%${project_type}%`);
        console.log(`[AI Analysis] Project Type filter applied: ${project_type}`);
      }
      
      if (min_fee !== undefined) {
        whereClauses.push(`CAST(NULLIF("Fee", '') AS NUMERIC) >= @p${paramIndex++}`);
        params.push(min_fee);
      }
      
      if (max_fee !== undefined) {
        whereClauses.push(`CAST(NULLIF("Fee", '') AS NUMERIC) <= @p${paramIndex++}`);
        params.push(max_fee);
      }
      
      // Add date filtering if start_date or end_date provided
      if (actualStartDate) {
        whereClauses.push(`TRY_CONVERT(DATE, "ConstStartDate") >= @p${paramIndex++}`);
        params.push(actualStartDate);
      }
      
      if (actualEndDate) {
        whereClauses.push(`TRY_CONVERT(DATE, "ConstStartDate") <= @p${paramIndex++}`);
        params.push(actualEndDate);
      }
      
      // Build SQL query - NO LIMIT, analyze ALL matching projects
      const sql = `
        SELECT 
          "Title" as project_name,
          "Company" as company,
          "Client" as client,
          "StatusChoice" as status,
          "Fee" as fee,
          "ChanceOfSuccess" as win_rate,
          "ConstStartDate" as start_date,
          "RequestCategory" as category,
          "State" as region,
          "ProjectType" as project_type
        FROM "${TABLE}"
        WHERE ${whereClauses.join(' AND ')}
        ORDER BY CAST(NULLIF("Fee", '') AS NUMERIC) DESC`;
      
      console.log(`[AI Analysis] Fetching ALL matching projects (no limit)...`);
      
      // Execute query
      const data = await externalDbQuery(sql, params);
      
      // Handle empty results
      if (!data || data.length === 0) {
        const filterDesc = [
          status ? `Status: ${status}` : null,
          categories ? `Categories: ${categories.join(', ')}` : null,
          min_fee ? `Min Fee: $${min_fee.toLocaleString()}` : null,
          max_fee ? `Max Fee: $${max_fee.toLocaleString()}` : null
        ].filter(Boolean).join(', ');
        
        return {
          success: false,
          data: [],
          error: `No projects found matching your criteria${filterDesc ? `: ${filterDesc}` : ''}.\n\nPlease adjust your filters or try a broader query.`
        };
      }
      
      console.log(`[AI Analysis] Found ${data.length} projects`);
      
      // Compute aggregates
      const fees = data
        .map(p => parseFloat(p.fee) || 0)
        .filter(f => f > 0);
      const winRates = data
        .map(p => parseFloat(p.win_rate) || 0);
      
      const aggregates = {
        count: data.length,
        avgFee: fees.length > 0 ? fees.reduce((a, b) => a + b, 0) / fees.length : 0,
        totalFee: fees.reduce((a, b) => a + b, 0),
        minFee: fees.length > 0 ? Math.min(...fees) : 0,
        maxFee: fees.length > 0 ? Math.max(...fees) : 0,
        avgWinRate: winRates.length > 0 ? winRates.reduce((a, b) => a + b, 0) / winRates.length : 0,
        truncated: false, // No limit applied - analyzing ALL matching projects
        filters: { status, categories, tags, min_fee, max_fee }
      };
      
      console.log(`[AI Analysis] Aggregates:`, aggregates);
      
      // Compute per-status aggregates for comparison queries
      const statusGroups: Record<string, { count: number; totalFee: number; avgFee: number; avgWinRate: number }> = {};
      data.forEach(p => {
        const st = p.status || 'Unknown';
        if (!statusGroups[st]) {
          statusGroups[st] = { count: 0, totalFee: 0, avgFee: 0, avgWinRate: 0 };
        }
        statusGroups[st].count++;
        statusGroups[st].totalFee += parseFloat(p.fee) || 0;
      });
      // Calculate averages
      Object.keys(statusGroups).forEach(st => {
        const group = statusGroups[st];
        group.avgFee = group.count > 0 ? group.totalFee / group.count : 0;
        const statusWinRates = data.filter(p => p.status === st).map(p => parseFloat(p.win_rate) || 0);
        group.avgWinRate = statusWinRates.length > 0 ? statusWinRates.reduce((a, b) => a + b, 0) / statusWinRates.length : 0;
      });
      
      // Compute per-category aggregates for breakdown queries
      const categoryGroups: Record<string, { count: number; totalFee: number; avgFee: number; avgWinRate: number }> = {};
      data.forEach(p => {
        const cat = p.category || 'Unknown';
        if (!categoryGroups[cat]) {
          categoryGroups[cat] = { count: 0, totalFee: 0, avgFee: 0, avgWinRate: 0 };
        }
        categoryGroups[cat].count++;
        categoryGroups[cat].totalFee += parseFloat(p.fee) || 0;
      });
      // Calculate averages
      Object.keys(categoryGroups).forEach(cat => {
        const group = categoryGroups[cat];
        group.avgFee = group.count > 0 ? group.totalFee / group.count : 0;
        const catWinRates = data.filter(p => p.category === cat).map(p => parseFloat(p.win_rate) || 0);
        group.avgWinRate = catWinRates.length > 0 ? catWinRates.reduce((a, b) => a + b, 0) / catWinRates.length : 0;
      });
      
      // Build per-status breakdown string
      const statusBreakdown = Object.entries(statusGroups)
        .sort((a, b) => b[1].avgFee - a[1].avgFee)
        .map(([st, g]) => `  - ${st}: ${g.count} projects, Avg Fee: $${(g.avgFee / 1000000).toFixed(2)}M, Total: $${(g.totalFee / 1000000).toFixed(1)}M, Avg Win Rate: ${g.avgWinRate.toFixed(1)}%`)
        .join('\n');
      
      // Build per-category breakdown string (top 10)
      const categoryBreakdown = Object.entries(categoryGroups)
        .sort((a, b) => b[1].avgFee - a[1].avgFee)
        .slice(0, 10)
        .map(([cat, g]) => `  - ${cat}: ${g.count} projects, Avg Fee: $${(g.avgFee / 1000000).toFixed(2)}M, Total: $${(g.totalFee / 1000000).toFixed(1)}M`)
        .join('\n');
      
      // Build cross-tabulation for status Ã— category (if multiple statuses)
      let crossTabulation = '';
      const uniqueStatuses = Object.keys(statusGroups);
      if (uniqueStatuses.length > 1 && uniqueStatuses.length <= 5) {
        const crossTab: Record<string, Record<string, { count: number; avgFee: number }>> = {};
        data.forEach(p => {
          const st = p.status || 'Unknown';
          const cat = p.category || 'Unknown';
          if (!crossTab[cat]) crossTab[cat] = {};
          if (!crossTab[cat][st]) crossTab[cat][st] = { count: 0, avgFee: 0 };
          crossTab[cat][st].count++;
          crossTab[cat][st].avgFee = ((crossTab[cat][st].avgFee * (crossTab[cat][st].count - 1)) + (parseFloat(p.fee) || 0)) / crossTab[cat][st].count;
        });
        
        crossTabulation = '\nSTATUS Ã— CATEGORY BREAKDOWN:\n' + 
          Object.entries(crossTab)
            .slice(0, 8) // Top 8 categories
            .map(([cat, statuses]) => {
              const statusDetails = uniqueStatuses
                .filter(st => statuses[st])
                .map(st => `${st}: ${statuses[st].count} @ $${(statuses[st].avgFee / 1000000).toFixed(2)}M avg`)
                .join(', ');
              return `  - ${cat}: ${statusDetails}`;
            })
            .join('\n');
      }
      
      // Build structured prompt for GPT-5
      const systemPrompt = `You are an expert business development analyst with deep experience analyzing project pipelines and predicting outcomes. Your role is to:
1. Analyze the PROVIDED DATA using the EXACT NUMBERS given - DO NOT make up statistics
2. Reference SPECIFIC PROJECTS by name (e.g., "PID 1234") when discussing patterns or outliers
3. Provide evidence-based insights citing specific data points from the dataset
4. Use the pre-calculated aggregates provided - these are the ACCURATE numbers from the database
5. Acknowledge limitations and uncertainties in your analysis

CRITICAL: All statistics (averages, counts, totals) have been pre-calculated from the COMPLETE dataset. Use these numbers directly - do NOT estimate or assume different values.

FORMATTING RULES:
- Use PLAIN TEXT ONLY - NO LaTeX, NO math notation like \\[, \\], \\text{}, \\times
- For mathematical expressions, use simple text: "Expected Wins = 140 Ã— 0.08 = 11.2 projects"
- Use Unicode symbols for multiplication (Ã—), division (Ã·), equals (=)
- Write formulas inline with plain formatting
- Use markdown for structure (headers, lists, bold) but NEVER LaTeX math blocks`;

      // Get balanced samples from each status (not just top by fee)
      const samplesByStatus: Record<string, any[]> = {};
      data.forEach(p => {
        const st = p.status || 'Unknown';
        if (!samplesByStatus[st]) samplesByStatus[st] = [];
        if (samplesByStatus[st].length < 5) { // Get top 5 from each status
          samplesByStatus[st].push(p);
        }
      });
      
      // Build balanced sample list
      const balancedPORs: any[] = [];
      Object.entries(samplesByStatus).forEach(([st, samples]) => {
        samples.slice(0, 3).forEach(p => balancedPORs.push(p)); // Top 3 from each status
      });
      
      const topProjects = balancedPORs.slice(0, 20).map(p => ({
        name: p.project_name,
        client: p.client,
        fee: parseFloat(p.fee) || 0,
        winRate: parseFloat(p.win_rate) || 0,
        status: p.status,
        category: p.category,
        tags: p.tags || ''
      }));
      
      const filterSummary = [
        status ? `Status: ${Array.isArray(status) ? status.join(', ') : status}` : null,
        categories && categories.length > 0 ? `Categories: ${categories.join(', ')}` : null,
        tags && tags.length > 0 ? `Tags: ${tags.join(', ')}` : null,
        min_fee ? `Min Fee: $${(min_fee / 1000000).toFixed(1)}M` : null,
        max_fee ? `Max Fee: $${(max_fee / 1000000).toFixed(1)}M` : null
      ].filter(Boolean).join(', ');
      
      const userPrompt = `Question: "${analysis_question}"

DATASET OVERVIEW (EXACT NUMBERS FROM DATABASE):
- Total Projects Analyzed: ${aggregates.count}
- Total Pipeline Value: $${(aggregates.totalFee / 1000000).toFixed(1)}M
- Overall Average Fee: $${(aggregates.avgFee / 1000000).toFixed(2)}M
- Fee Range: $${(aggregates.minFee / 1000000).toFixed(1)}M - $${(aggregates.maxFee / 1000000).toFixed(1)}M
- Overall Average Win Rate: ${aggregates.avgWinRate.toFixed(1)}%
${filterSummary ? `- Applied Filters: ${filterSummary}` : ''}

BREAKDOWN BY STATUS (EXACT CALCULATED AVERAGES):
${statusBreakdown}

BREAKDOWN BY CATEGORY (TOP 10 BY AVG FEE):
${categoryBreakdown}
${crossTabulation}

SAMPLE PROJECTS (balanced across statuses):
${topProjects.map((p, i) => `${i + 1}. ${p.name} - ${p.client} - $${(p.fee / 1000000).toFixed(1)}M (${p.winRate}% win rate, ${p.status}, ${p.category})${p.tags ? ` [Tags: ${p.tags}]` : ''}`).join('\n')}

INSTRUCTIONS:
- Use the EXACT statistics provided above - these are calculated from the complete database
- Reference specific projects by name when discussing patterns or notable examples
- When comparing statuses, use the pre-calculated averages from "BREAKDOWN BY STATUS"
- When comparing categories, use the pre-calculated averages from "BREAKDOWN BY CATEGORY"
- Provide actionable insights based on the actual data
- Use PLAIN TEXT for all calculations (NO LaTeX notation)

Provide comprehensive analysis addressing the question above using the exact data provided.`;

      console.log(`[AI Analysis] Calling GPT-5 for insights...`);
      
      // Call GPT-5 for analysis (with timeout and error handling)
      let aiAnalysis: string;
      try {
        aiAnalysis = await this.callGPT5ForAnalysis(systemPrompt, userPrompt);
      } catch (error: any) {
        console.error(`[AI Analysis] GPT-5 call failed:`, error);
        
        // Fall back to deterministic aggregate summary
        const fallbackSummary = `## Data Summary

Based on ${aggregates.count} projects:
- **Total Pipeline Value**: $${Math.round(aggregates.totalFee).toLocaleString()}
- **Average Project Fee**: $${Math.round(aggregates.avgFee).toLocaleString()}
- **Average Win Rate**: ${aggregates.avgWinRate.toFixed(1)}%
- **Fee Range**: $${Math.round(aggregates.minFee).toLocaleString()} to $${Math.round(aggregates.maxFee).toLocaleString()}

*Note: AI analysis temporarily unavailable. Showing statistical summary only. Please try again in a moment.*`;

        return {
          success: true,
          question: analysis_question,
          function_name: 'ai_data_analysis',
          arguments: args, // Enable follow-up question context preservation
          data: [{
            type: 'ai_analysis',
            narrative: fallbackSummary,
            aggregates,
            samples: data.slice(0, 5),
            fallback: true
          }],
          row_count: aggregates.count, // Number of projects analyzed, not data array length
          summary: aggregates,
          chart_config: null,
          message: `Analyzed ${aggregates.count} projects (fallback mode)`,
          sql_query: sql,
          sql_params: params
        };
      }
      
      console.log(`[AI Analysis] âœ“ Analysis complete`);
      
      // Return AI analysis with metadata (include function_name & arguments for follow-up questions)
      return {
        success: true,
        question: analysis_question,
        function_name: 'ai_data_analysis',
        arguments: args, // Enable follow-up question context preservation
        data: [{
          type: 'ai_analysis',
          narrative: aiAnalysis,
          aggregates,
          samples: data.slice(0, 10),
          question: analysis_question
        }],
        row_count: aggregates.count, // Number of projects analyzed, not data array length
        summary: aggregates,
        chart_config: null,
        message: `Analyzed ${aggregates.count} projects`,
        sql_query: sql,
        sql_params: params
      };
      
    } catch (error: any) {
      console.error(`[AI Analysis] Error:`, error);
      return {
        success: false,
        data: [],
        error: `AI analysis failed: ${error.message || 'Unknown error'}. Please try rephrasing your question or contact support.`
      };
    }
  }
  
  /**
   * Call GPT model to generate analytical insights
   * Uses GPT-5.2 for best insights (gpt-4o is used for classification)
   */
  private async callGPT5ForAnalysis(systemPrompt: string, userPrompt: string): Promise<string> {
    console.log(`[AI Analysis] Prompt length: ${(systemPrompt + userPrompt).length} chars`);
    
    // Use GPT-5.2 for analytical insights (better reasoning than gpt-4o)
    const analysis = await this.openaiClient.chat(
      [
        { role: "system", content: systemPrompt },
        { role: "user", content: userPrompt }
      ],
      { 
        model: "gpt-5.1", // Best available model for analysis
        max_completion_tokens: 3000
      }
    );
    
    console.log(`[AI Analysis] Response length: ${analysis.length} chars`);
    
    if (!analysis || analysis.trim().length === 0) {
      throw new Error(`AI analysis returned empty response`);
    }
    
    return analysis;
  }

  /**
   * Detect unrecognized filter terms in user query
   * Returns info about terms that look like filters but weren't recognized
   * Examples: "projects in xx", "variance of xx sector", "xx division projects"
   */
  private detectUnrecognizedFilterTerm(
    userQuestion: string,
    args: Record<string, any>
  ): { hasUnrecognizedTerm: boolean; term?: string; filterType?: string } {
    // CRITICAL EARLY BYPASS: If poc is set, immediately return false to prevent fallback
    if (args.poc && typeof args.poc === "string") {
      console.log(`[detectUnrecognizedFilterTerm] âœ“ EARLY BYPASS: args.poc="${args.poc}" - skipping check`);
      return { hasUnrecognizedTerm: false };
    }
    if (args._poc_already_applied === true) {
      console.log(`[detectUnrecognizedFilterTerm] âœ“ EARLY BYPASS: _poc_already_applied=true - skipping check`);
      return { hasUnrecognizedTerm: false };
    }
    // Known categories (lowercase for comparison)
    const knownCategories = new Set([
      'education', 'healthcare', 'transportation', 'aviation', 'commercial',
      'corporate', 'civic', 'entertainment', 'energy', 'corrections', 'cultural',
      'industrial', 'mixed use', 'multifamily', 'residential', 'sports',
      'waterfront', 'hospitality', 'water', 'buildings', 'other', 'mission critical',
      'disaster relief', 'humanitarian', 'government'
    ]);
    
    // Known divisions (common ones)
    const knownDivisions = new Set([
      'ajax', 'dallas', 'lfdh', 'dias', 'abbott', 'spm', 'scm', 'architecture',
      'research and development', 'engineering', 'construction', 'design'
    ]);
    
    // Stopwords to ignore
    const stopwords = new Set([
      'the', 'a', 'an', 'in', 'on', 'at', 'to', 'for', 'of', 'by', 'with',
      'from', 'as', 'is', 'are', 'was', 'were', 'be', 'been', 'being',
      'have', 'has', 'had', 'do', 'does', 'did', 'will', 'would', 'could',
      'should', 'may', 'might', 'must', 'shall', 'can', 'need', 'all', 'any',
      'some', 'no', 'not', 'only', 'just', 'more', 'less', 'most', 'least',
      'this', 'that', 'these', 'those', 'what', 'which', 'who', 'whom',
      'show', 'me', 'give', 'get', 'find', 'list', 'display', 'provide',
      'projects', 'project', 'data', 'records', 'results', 'information',
      'variance', 'average', 'total', 'count', 'sum', 'statistics', 'stats'
    ]);
    
    // EXPLICIT REGION CHECK: Must be first to ensure region queries always bypass
    if (args.regions && Array.isArray(args.regions) && args.regions.length > 0) {
      console.log(`[detectUnrecognizedFilterTerm] âœ“ BYPASSING: args.regions is set`);
      return { hasUnrecognizedTerm: false };
    }

    // Skip detection if filters were already extracted
    const hasFilterApplied = args.modules || args._module_context || args.categories || args.category || args.division || 
                            args.department || args.sector || args.project_type ||
                            args.state_code || args.state || args.region ||
                            args._keyword_already_applied || args._project_type_already_applied ||
                            args.poc || args._poc_already_applied || args.company || args._company_already_applied ||
                            args.organization || args.status || args.client ||
                            (args.project_types && args.project_types.length > 0) ||
                            (args.divisions && args.divisions.length > 0) ||
                            (args.departments && args.departments.length > 0) ||
                            (args.states && args.states.length > 0) ||
                            (args.regions && args.regions.length > 0);

    console.log(`[detectUnrecognizedFilterTerm] args.poc=${args.poc}, args._poc_already_applied=${args._poc_already_applied}, args.status=${JSON.stringify(args.status)}`);
    console.log(`[detectUnrecognizedFilterTerm] hasFilterApplied=${hasFilterApplied}`);

    if (hasFilterApplied) {
      return { hasUnrecognizedTerm: false };
    }
    // Pattern to detect filter-like terms: "in XX", "XX projects", "XX sector"
    // Note: Capture only the LAST word after "in/for/from" - don't include spaces
    // This prevents matching "projects in xx" and extracting "projects in xx"
    const filterPatterns = [
      // "in xx" at end of sentence - capture last word only
      /\b(?:in|for|from)\s+([a-z]+)\s*$/i,
      // "variance/stats of xx" patterns
      /\b(?:variance|stats?|statistics|breakdown|analysis)\s+(?:of|for|in)\s+(?:the\s+)?([a-z]+)\s*$/i,
    ];
    
    console.log(`[UnrecognizedFilter] Checking query: "${userQuestion}"`);
    console.log(`[UnrecognizedFilter] Has filter applied:`, hasFilterApplied ? 'YES' : 'NO');
    
    for (const pattern of filterPatterns) {
      const match = userQuestion.match(pattern);
      console.log(`[UnrecognizedFilter] Testing pattern: ${pattern}, match:`, match);
      if (match && match[1]) {
        const term = match[1].trim().toLowerCase();
        console.log(`[UnrecognizedFilter] Pattern matched, term: "${term}"`);
        
        // Skip if it's a stopword, too short, or numeric
        if (stopwords.has(term) || term.length < 2 || /^\d+$/.test(term)) {
          continue;
        }
        
        // Skip if it's a known category
        if (knownCategories.has(term)) {
          continue;
        }
        
        // Skip if it's a known division
        if (knownDivisions.has(term)) {
          continue;
        }
        
        // Skip common phrases that aren't filters
        if (/\b(last|this|next|past|previous)\s+(year|month|week|quarter)/i.test(term)) {
          continue;
        }
        
        // This looks like an unrecognized filter term
        return {
          hasUnrecognizedTerm: true,
          term: term,
          filterType: 'category'
        };
      }
    }
    
    return { hasUnrecognizedTerm: false };
  }

  /**
   * AI Fallback Handler - provides helpful AI response when queries fail
   * Now includes AUTO-EXECUTE: Generates and executes alternative queries automatically
   * Used when: SQL returns no results, query can't be classified, or errors occur
   */
  private async handleAIFallback(
    userQuestion: string,
    failureReason: 'no_results' | 'classification_failed' | 'execution_error' | 'unknown',
    context: {
      attemptedFunction?: string;
      appliedFilters?: Record<string, any>;
      errorMessage?: string;
      previousContext?: { question: string; function_name: string; arguments: Record<string, any> };
    },
    externalDbQuery: (sql: string, params?: any[]) => Promise<any[]>
  ): Promise<{ success: boolean; data: any[]; message?: string; error?: string; ai_insights?: string; sql_query?: string; sql_params?: any[]; function_name?: string; arguments?: Record<string, any>; row_count?: number; summary?: Record<string, any>; chart_config?: any; suggested_queries?: Array<{ description: string; suggested_question: string; filters: Record<string, any>; function_name: string }>; query_reference?: string }> {
    console.log(`[AI Fallback] ğŸ”„ Initiating fallback for: "${userQuestion}"`);
    console.log(`[AI Fallback] Reason: ${failureReason}`);
    console.log(`[AI Fallback] Context:`, JSON.stringify(context, null, 2));

    try {
      // ========================================
      // STEP 1: AUTO-EXECUTE ALTERNATIVE QUERIES
      // Generate structured alternative queries and execute them
      // ========================================
      
      // Skip auto-execute for certain failure reasons
      const shouldAutoExecute = failureReason === 'no_results' && context.appliedFilters;
      
      if (shouldAutoExecute) {
        console.log(`[AI Fallback] ğŸ”„ Attempting auto-execute of alternative queries...`);
        
        // Check if user has only a single filter (like just client or company)
        // In this case, skip GPT alternatives and only show similar entities
        const appliedFilterKeys = Object.keys(context.appliedFilters || {}).filter(k => !k.startsWith('__'));
        const isSingleEntityQuery = appliedFilterKeys.length === 1 && 
          (appliedFilterKeys[0] === 'client' || appliedFilterKeys[0] === 'company');
        
        // Build list of suggested queries for user to choose from
        const suggestedQueries: Array<{
          description: string;
          suggested_question: string;
          filters: Record<string, any>;
          function_name: string;
        }> = [];
        
        // Only generate GPT alternatives if user has multiple filters to relax
        if (!isSingleEntityQuery) {
          // Get database context for GPT to generate smart alternatives
          let dbContext = "";
          try {
            const [statusResult, categoryResult, clientPOR, companyPOR] = await Promise.all([
              externalDbQuery(`SELECT DISTINCT "StatusChoice" as status FROM "${TABLE}" WHERE "StatusChoice" IS NOT NULL AND "StatusChoice" != '' ORDER BY "StatusChoice" OFFSET 0 ROWS FETCH NEXT 20 ROWS ONLY`, []),
              externalDbQuery(`SELECT DISTINCT "RequestCategory" as category FROM "${TABLE}" WHERE "RequestCategory" IS NOT NULL AND "RequestCategory" != '' ORDER BY "RequestCategory" OFFSET 0 ROWS FETCH NEXT 20 ROWS ONLY`, []),
              externalDbQuery(`SELECT DISTINCT "Client" as client FROM "${TABLE}" WHERE "Client" IS NOT NULL AND "Client" != '' ORDER BY "Client" OFFSET 0 ROWS FETCH NEXT 10 ROWS ONLY`, []),
              externalDbQuery(`SELECT DISTINCT "Company" as company FROM "${TABLE}" WHERE "Company" IS NOT NULL AND "Company" != '' ORDER BY "Company" OFFSET 0 ROWS FETCH NEXT 10 ROWS ONLY`, [])
            ]);
            
            dbContext = `
Available Status values: ${statusResult.map(r => r.status).join(', ')}
Available Categories: ${categoryResult.map(r => r.category).join(', ')}
POR Client IDs: ${clientPOR.map(r => r.client).join(', ')}
POR Companies: ${companyPOR.map(r => r.company).join(', ')}`;
          } catch (e) {
            console.log(`[AI Fallback] Could not fetch DB context:`, e);
          }

          // Generate structured alternative queries using GPT
          const alternativePrompt = `You are generating alternative database queries for a project pipeline system.

Original question: "${userQuestion}"
Filters applied: ${JSON.stringify(context.appliedFilters)}
${dbContext}

Generate 2-3 UNIQUE alternative queries that might return results by broadening the search.

IMPORTANT: Write descriptions from the USER's perspective - describe what they'll SEE, not what filters are being removed.

GOOD description examples:
- "Search across all project statuses"
- "Include projects from any state"
- "Show projects from any time period"
- "Broaden search to all categories"

BAD description examples (NEVER use these):
- "Remove status filter" (user may not know what filters exist)
- "Remove date constraints" (too technical)
- "Relax multiple filters" (meaningless to user)

Return ONLY valid JSON in this exact format (no markdown, no explanation):
{
  "alternatives": [
    {
      "description": "User-friendly description of what results will include",
      "relaxed_filters": { "key": "value" }
    }
  ]
}

Example alternatives:
1. {"description": "Search across all project statuses", "relaxed_filters": {"status": null}}
2. {"description": "Include projects from any time period", "relaxed_filters": {"start_date": null, "end_date": null}}
3. {"description": "Broaden to projects in any state", "relaxed_filters": {"states": null, "state_code": null}}`;

        try {
          const alternativesResponse = await this.openaiClient.chat(
            [{ role: "user", content: alternativePrompt }],
            { model: "gpt-5.1", max_completion_tokens: 800 }
          );
          
          console.log(`[AI Fallback] GPT alternatives response: ${alternativesResponse.substring(0, 200)}...`);
          
          // Parse the JSON response
          const jsonMatch = alternativesResponse.match(/\{[\s\S]*\}/);
          if (jsonMatch) {
            const parsed = JSON.parse(jsonMatch[0]);
            const alternatives = parsed.alternatives || [];
            
            console.log(`[AI Fallback] Generated ${alternatives.length} alternative queries`);
            
            // Process alternatives to create user-friendly suggestions
            // (using outer suggestedQueries array declared above)
            for (let i = 0; i < alternatives.length; i++) {
              const alt = alternatives[i];
              console.log(`[AI Fallback] Trying alternative ${i + 1}: ${alt.description}`);
              
              // Build relaxed arguments by merging with original and applying relaxations
              const relaxedArgs: Record<string, any> = { ...context.appliedFilters };
              
              // Apply relaxations (null means remove the filter)
              for (const [key, value] of Object.entries(alt.relaxed_filters || {})) {
                if (value === null || value === undefined) {
                  delete relaxedArgs[key];
                  
                  // Also remove related/duplicate fields
                  if (key === 'states' || key === 'state_code') {
                    delete relaxedArgs.states;
                    delete relaxedArgs.state_code;
                  }
                  if (key === 'start_date' || key === 'end_date') {
                    delete relaxedArgs.start_date;
                    delete relaxedArgs.end_date;
                  }
                  if (key === 'category' || key === 'categories') {
                    delete relaxedArgs.category;
                    delete relaxedArgs.categories;
                  }
                } else {
                  relaxedArgs[key] = value;
                }
              }
              
              // Remove internal flags
              delete relaxedArgs.__autoRetryPerformed;
              delete relaxedArgs.__filterRelaxationPerformed;
              relaxedArgs.__autoFallbackRetry = true;
              
              // Skip this alternative if no meaningful filters remain
              const meaningfulKeys = Object.keys(relaxedArgs).filter(k => !k.startsWith('__') && !k.startsWith('_'));
              if (meaningfulKeys.length === 0) {
                console.log(`[AI Fallback] Skipping alternative ${i + 1}: No meaningful filters after relaxation`);
                continue;
              }
              
              // Determine the best function based on remaining filters
              let functionToUse = context.attemptedFunction || 'search_projects';
              
              // If original function required a specific parameter that's now missing, use a general function
              const requiredParamFunctions: Record<string, string[]> = {
                'get_projects_by_client': ['client'],
                'get_projects_by_poc': ['poc', 'contact'],
                'get_projects_by_status': ['status'],
                'get_projects_by_category': ['category'],
                'get_projects_by_project_type': ['project_type'],
                'get_projects_by_state': ['state_code', 'states'],
              };
              
              const requiredParams = requiredParamFunctions[functionToUse] || [];
              const hasRequiredParam = requiredParams.some(p => relaxedArgs[p]);
              
              if (!hasRequiredParam && requiredParams.length > 0) {
                // Core parameter removed - switch to a more general function
                functionToUse = 'get_projects_by_combined_filters';
              }
              
              // Build a natural language question from the filters
              const questionParts: string[] = [];
              if (relaxedArgs.status) questionParts.push(`${Array.isArray(relaxedArgs.status) ? relaxedArgs.status.join('/') : relaxedArgs.status}`);
              if (relaxedArgs.category || relaxedArgs.categories) questionParts.push(`${relaxedArgs.category || relaxedArgs.categories}`);
              if (relaxedArgs.project_type) questionParts.push(`${relaxedArgs.project_type}`);
              questionParts.push('projects');
              if (relaxedArgs.client) questionParts.push(`for ${relaxedArgs.client}`);
              if (relaxedArgs.company) questionParts.push(`by ${relaxedArgs.company}`);
              if (relaxedArgs.states || relaxedArgs.state_code) questionParts.push(`in ${relaxedArgs.states || relaxedArgs.state_code}`);
              if (relaxedArgs.start_date && relaxedArgs.end_date) {
                const year = relaxedArgs.start_date.substring(0, 4);
                questionParts.push(`from ${year}`);
              }
              
              const suggestedQuestion = questionParts.join(' ').replace(/\s+/g, ' ').trim();
              const finalQuestion = suggestedQuestion || `Show ${alt.description.toLowerCase()}`;
              
              // Deduplicate - skip if we already have this exact question
              const normalizedQuestion = finalQuestion.toLowerCase().trim();
              const seenQuestions = suggestedQueries.map(q => q.suggested_question.toLowerCase().trim());
              
              if (seenQuestions.includes(normalizedQuestion)) {
                console.log(`[AI Fallback] Skipping duplicate suggestion: "${finalQuestion}"`);
                continue;
              }
              
              // Execute this alternative query to verify it returns results
              console.log(`[AI Fallback] Testing suggestion ${i + 1}: "${finalQuestion}"`);
              try {
                const testResult = await this.executeQuery(functionToUse, { ...relaxedArgs }, externalDbQuery, finalQuestion);
                const resultCount = testResult.data?.length || 0;
                
                if (resultCount === 0) {
                  console.log(`[AI Fallback] Skipping suggestion ${i + 1}: No results found`);
                  continue;
                }
                
                console.log(`[AI Fallback] âœ“ Suggestion ${i + 1} verified: ${resultCount} results`);
                
                // Add to suggested queries list with result count
                suggestedQueries.push({
                  description: `${alt.description} (${resultCount} projects)`,
                  suggested_question: finalQuestion,
                  filters: { ...relaxedArgs },
                  function_name: functionToUse
                });
                
                console.log(`[AI Fallback] Added suggestion ${i + 1}: "${finalQuestion}" (${resultCount} results)`);
              } catch (testError: any) {
                console.log(`[AI Fallback] Skipping suggestion ${i + 1}: Execution failed - ${testError.message}`);
                continue;
              }
            }
          }
        } catch (parseError: any) {
          console.log(`[AI Fallback] Could not parse alternatives:`, parseError.message);
        }
        } // End of if (!isSingleEntityQuery)
            
        // Also add similar client/company suggestions if applicable (always add these)
        const appliedFiltersForSuggestions = context.appliedFilters || {};
            const clientFilterForSuggestions = appliedFiltersForSuggestions.client;
            const companyFilterForSuggestions = appliedFiltersForSuggestions.company;
            
            if (clientFilterForSuggestions) {
              try {
                const clientPattern = String(clientFilterForSuggestions).replace(/[^a-zA-Z0-9]/g, '');
                const similarClientsSql = `
                  SELECT TOP 3 "Client" as client, COUNT(*) as project_count
                  FROM "${TABLE}" 
                  WHERE "Client" IS NOT NULL AND "Client" != ''
                  AND (
                    "Client" LIKE @p1
                    OR "Client" LIKE @p2
                  )
                  GROUP BY "Client"
                  ORDER BY project_count DESC`;
                
                const similarClients = await externalDbQuery(similarClientsSql, [
                  `%${clientPattern.substring(0, Math.min(4, clientPattern.length))}%`,
                  `%${clientFilterForSuggestions.toString().split(' ')[0]}%`
                ]);
                
                for (const similarClient of similarClients) {
                  if (similarClient.client === clientFilterForSuggestions) continue;
                  suggestedQueries.push({
                    description: `Try similar client: ${similarClient.client} (${similarClient.project_count} projects)`,
                    suggested_question: `Show projects for ${similarClient.client}`,
                    filters: { client: similarClient.client },
                    function_name: 'get_projects_by_client'
                  });
                }
              } catch (e) {
                console.log(`[AI Fallback] Could not fetch similar clients:`, e);
              }
            }
            
            if (companyFilterForSuggestions) {
              try {
                const companyPattern = String(companyFilterForSuggestions).split(' ')[0];
                const similarCompaniesSql = `
                  SELECT TOP 3 "Company" as company, COUNT(*) as project_count
                  FROM "${TABLE}" 
                  WHERE "Company" IS NOT NULL AND "Company" != ''
                  AND "Company" LIKE @p1
                  GROUP BY "Company"
                  ORDER BY project_count DESC`;
                
                const similarCompanies = await externalDbQuery(similarCompaniesSql, [`%${companyPattern}%`]);
                
                for (const similarCompany of similarCompanies) {
                  if (similarCompany.company === companyFilterForSuggestions) continue;
                  suggestedQueries.push({
                    description: `Try similar company: ${similarCompany.company} (${similarCompany.project_count} projects)`,
                    suggested_question: `Show projects by ${similarCompany.company}`,
                    filters: { company: similarCompany.company },
                    function_name: 'get_projects_by_company'
                  });
                }
              } catch (e) {
                console.log(`[AI Fallback] Could not fetch similar companies:`, e);
              }
            }
            
            // If we have suggestions, return them for user to choose
            if (suggestedQueries.length > 0) {
              console.log(`[AI Fallback] Returning ${suggestedQueries.length} suggested queries for user selection`);
              const queryRefNumber = `Q${Date.now().toString(36).toUpperCase()}${Math.random().toString(36).substring(2, 6).toUpperCase()}`;
              
              return {
                success: true,
                data: [{
                  type: 'suggested_queries',
                  original_question: userQuestion,
                  original_filters: context.appliedFilters,
                  message: `Great question! I need to talk to my creators to ensure that I have the right answer for you. Query # ${queryRefNumber}`,
                  suggestions: suggestedQueries
                }],
                function_name: 'suggested_queries',
                message: `Great question! I need to talk to my creators to ensure that I have the right answer for you. Query # ${queryRefNumber}`,
                suggested_queries: suggestedQueries,
                query_reference: queryRefNumber
              };
            }
            
        // If we have suggestions, return them for user to choose
        if (suggestedQueries.length > 0) {
          console.log(`[AI Fallback] Returning ${suggestedQueries.length} suggested queries for user selection`);
          const queryRefNumber = `Q${Date.now().toString(36).toUpperCase()}${Math.random().toString(36).substring(2, 6).toUpperCase()}`;
          
          return {
            success: true,
            data: [{
              type: 'suggested_queries',
              original_question: userQuestion,
              original_filters: context.appliedFilters,
              message: `Great question! I need to talk to my creators to ensure that I have the right answer for you. Query # ${queryRefNumber}`,
              suggestions: suggestedQueries
            }],
            function_name: 'suggested_queries',
            message: `Great question! I need to talk to my creators to ensure that I have the right answer for you. Query # ${queryRefNumber}`,
            suggested_queries: suggestedQueries,
            query_reference: queryRefNumber
          };
        }
            
        console.log(`[AI Fallback] No suggestions generated, falling back to text suggestions`);
      }

      // ========================================
      // STEP 2: TEXT-BASED FALLBACK (if auto-execute failed)
      // ========================================
      
      // Get some data to provide context for helpful suggestions
      let sampleData: any[] = [];
      let dataContext = "";
      
      try {
        const sampleSql = `
          SELECT TOP 20 
            "Title" as project_name,
            "Company" as company,
            "StatusChoice" as status,
            "Fee" as fee,
            "RequestCategory" as category,
            "State" as region
          FROM "${TABLE}"
          ORDER BY "ConstStartDate" DESC`;
        
        sampleData = await externalDbQuery(sampleSql, []);
        
        if (sampleData.length > 0) {
          // Fetch ALL actual status values from the database (not just from sample)
          let allStatuses: string[] = [];
          try {
            const statusResult = await externalDbQuery(
              `SELECT DISTINCT "StatusChoice" as status FROM "${TABLE}" WHERE "StatusChoice" IS NOT NULL AND "StatusChoice" != '' ORDER BY "StatusChoice"`,
              []
            );
            allStatuses = statusResult.map(r => r.status).filter(Boolean);
          } catch (statusError) {
            // Fallback to sample-based statuses
            allStatuses = Array.from(new Set(sampleData.map(p => p.status).filter(Boolean)));
          }
          
          // Fetch ALL actual categories from the database (not just from sample)
          let allCategories: string[] = [];
          try {
            const categoryResult = await externalDbQuery(
              `SELECT DISTINCT "RequestCategory" as category FROM "${TABLE}" WHERE "RequestCategory" IS NOT NULL AND "RequestCategory" != '' ORDER BY "RequestCategory"`,
              []
            );
            allCategories = categoryResult.map(r => r.category).filter(Boolean);
          } catch (catError) {
            // Fallback to sample-based categories
            allCategories = Array.from(new Set(sampleData.map(p => p.category).filter(Boolean)));
          }
          
          dataContext = `
DATABASE CONTEXT (for reference):
- Available Status values: ${allStatuses.join(', ')}
- Available Categories: ${allCategories.join(', ')}
- Total projects in database: ~16,000+`;
        }
      } catch (dbError) {
        console.log(`[AI Fallback] Could not fetch sample data:`, dbError);
      }

      // Generate a unique query reference number for tracking
      const queryRefNumber = `Q${Date.now().toString(36).toUpperCase()}${Math.random().toString(36).substring(2, 6).toUpperCase()}`;
      
      // Build the friendly "needs review" message - no GPT call needed
      const fallbackResponse = `Great question! I need to talk to my creators to ensure that I have the right answer for you. Query # ${queryRefNumber}`;
      
      console.log(`[AI Fallback] Generated fallback with query reference: ${queryRefNumber}`);

      // Return as AI analysis format so it displays nicely
      // Include ai_insights at top level so frontend displays it properly
      return {
        success: true,
        data: [{
          type: 'ai_analysis',
          narrative: fallbackResponse,
          aggregates: { count: 0, totalFee: 0, avgFee: 0 },
          samples: [],
          question: userQuestion,
          is_fallback: true,
          query_reference: queryRefNumber
        }],
        ai_insights: fallbackResponse, // Add at top level for frontend display
        message: 'Query needs review',
        query_reference: queryRefNumber
      };

    } catch (fallbackError: any) {
      console.error(`[AI Fallback] Error generating fallback:`, fallbackError);
      
      // Ultimate fallback - return a friendly "needs review" message with query reference
      const queryRefNumber = `Q${Date.now().toString(36).toUpperCase()}${Math.random().toString(36).substring(2, 6).toUpperCase()}`;
      const genericFallback = `Great question! I need to talk to my creators to ensure that I have the right answer for you. Query # ${queryRefNumber}`;
      
      return {
        success: true,
        data: [{
          type: 'ai_analysis',
          narrative: genericFallback,
          aggregates: { count: 0, totalFee: 0, avgFee: 0 },
          samples: [],
          question: userQuestion,
          is_fallback: true,
          query_reference: queryRefNumber
        }],
        ai_insights: genericFallback, // Add at top level for frontend display
        message: 'Query needs review',
        query_reference: queryRefNumber
      };
    }
  }

  /**
   * Handle "same attribute as PID X" queries (two-step lookup)
   */
  private async handleSameAttributeQuery(
    args: Record<string, any>,
    externalDbQuery: (sql: string, params?: any[]) => Promise<any[]>
  ): Promise<{ success: boolean; data: any[]; error?: string; sql_query?: string; sql_params?: any[]; extracted_args?: Record<string, any> }> {
    try {
      const { reference_pid, attribute } = args;

      // Handle special cases: ordinal positions, superlatives, etc.
      let lookupSql: string;
      let lookupParams: any[];
      
      // Check if this is an ordinal position (first, second, third, 1st, 2nd, etc.)
      const position = this.parseOrdinalPosition(reference_pid);
      
      if (position !== null) {
        // Get the Nth row directly from the database without any ordering
        // This gives us the actual physical row position as stored in the database
        lookupSql = `SELECT * FROM "${TABLE}" 
                     ORDER BY (SELECT NULL)
                     OFFSET @p1 ROWS FETCH NEXT 1 ROWS ONLY`;
        lookupParams = [position - 1]; // OFFSET is 0-indexed
        console.log(`[QueryEngine] Step 1: Getting row at position ${position} (natural database order)`);
      } else if (/largest|biggest|highest\s*fee|top/i.test(reference_pid)) {
        // Get the project with highest fee
        lookupSql = `SELECT TOP 1 * FROM "${TABLE}" 
                     WHERE CAST(NULLIF("Fee", '') AS NUMERIC) IS NOT NULL
                     ORDER BY CAST(NULLIF("Fee", '') AS NUMERIC) DESC`;
        lookupParams = [];
        console.log(`[QueryEngine] Step 1: Getting "${reference_pid}" (highest fee project)`);
      } else {
        // Standard PID lookup with flexible matching
        let normalizedPid = reference_pid;
        let pidWithSpace = reference_pid;
        
        // If user typed "PID7" (no space), also try "PID 7" (with space)
        if (/^PID\d+$/i.test(reference_pid)) {
          pidWithSpace = reference_pid.replace(/^(PID)(\d+)$/i, '$1 $2');
        }
        // If user typed "PID 7" (with space), also try "PID7" (no space)
        else if (/^PID\s+\d+$/i.test(reference_pid)) {
          normalizedPid = reference_pid.replace(/\s+/g, '');
        }
        
        lookupSql = `SELECT TOP 1 * FROM "${TABLE}" 
                     WHERE "Title" LIKE @p1 
                     OR "Title" LIKE @p2
                     OR CAST("InternalId" AS NVARCHAR(MAX)) LIKE @p1
                     OR CAST("InternalId" AS NVARCHAR(MAX)) LIKE @p2`;
        lookupParams = [`%${normalizedPid}%`, `%${pidWithSpace}%`];
        
        console.log(`[QueryEngine] Step 1: Looking up reference project "${reference_pid}" (also trying "${pidWithSpace}")`);
      }
      
      // Log Step 1 query
      console.log(`\n${'='.repeat(80)}`);
      console.log(`[QueryEngine] STEP 1 SQL QUERY (Reference Lookup):`);
      console.log(`${'='.repeat(80)}`);
      console.log(this.substituteParams(lookupSql, lookupParams));
      console.log(`${'='.repeat(80)}\n`);
      
      const referenceProjects = await externalDbQuery(lookupSql, lookupParams);
      
      if (referenceProjects.length === 0) {
        return {
          success: false,
          data: [],
          error: `Reference project "${reference_pid}" not found`,
        };
      }

      const referenceProject = referenceProjects[0];
      console.log(`[QueryEngine] Step 1 Result: Found reference project "${referenceProject['Project Name']}" (PID: ${referenceProject['Project Name']})`);
      
      // Step 2: Handle multiple attributes (comma-separated)
      const attributes = attribute.split(',').map((a: string) => a.trim());
      
      const attributeMap: Record<string, string> = {
        poc: "PointOfContact",
        category: "RequestCategory",
        client: "Client",
        status: "StatusChoice",
        company: "Company",
      };

      // Build WHERE conditions for all attributes
      const whereClauses: string[] = [];
      const sqlParams: any[] = [];
      let paramIndex = 1;
      
      // Store extracted values for follow-up queries
      const extractedArgs: Record<string, any> = {};

      for (const attr of attributes) {
        const columnName = attributeMap[attr];
        if (!columnName) {
          return {
            success: false,
            data: [],
            error: `Invalid attribute type: ${attr}`,
          };
        }

        const attributeValue = referenceProject[columnName];
        if (!attributeValue) {
          console.log(`[QueryEngine] âš ï¸ Warning: Reference project has no ${attr} value, skipping this filter`);
          continue;
        }

        // Special handling for tags - for simplicity, match projects with ALL the reference tags
        // Note: This will also match projects that have additional tags beyond the reference set
        if (false) { /* Tags column not in database - removed */
        } else {
          // Normal attribute matching
          console.log(`[QueryEngine] Step 2: Found ${attr} = "${attributeValue}"`);
          whereClauses.push(`"${columnName}" LIKE @p${paramIndex}`);
          sqlParams.push(`%${attributeValue}%`);
          paramIndex++;
          
          // Store extracted value for follow-up queries
          if (attr === 'category') extractedArgs.categories = [attributeValue];
          else if (attr === 'status') extractedArgs.status = attributeValue;
          else if (attr === 'client') extractedArgs.client = attributeValue;
          else if (attr === 'company') extractedArgs.company = attributeValue;
          else if (attr === 'poc') extractedArgs.poc = attributeValue;
        }
      }

      if (whereClauses.length === 0) {
        return {
          success: false,
          data: [],
          error: `Reference project has no values for the specified attributes: ${attributes.join(', ')}`,
        };
      }

      // Step 3: Build query to find all projects with same attributes
      let sql = `SELECT * FROM "${TABLE}" WHERE ${whereClauses.join(' AND ')}`;

      // Check both original boolean and normalized array forms for exclusion flags
      const shouldExcludeCategory = args.exclude_category === true || 
                                    (args.exclude_categories && args.exclude_categories.length > 0);
      const shouldExcludeStatus = args.exclude_status === true || 
                                   (args.exclude_statuses && args.exclude_statuses.length > 0);
      const shouldExcludeClient = args.exclude_client === true || 
                                   (args.exclude_clients && args.exclude_clients.length > 0);

      // Add exclusion filters (e.g., "similar but different category")
      if (shouldExcludeCategory && referenceProject["RequestCategory"]) {
        sql += ` AND "RequestCategory" NOT LIKE @p${paramIndex}`;
        sqlParams.push(`%${referenceProject["RequestCategory"]}%`);
        paramIndex++;
        console.log(`[QueryEngine] Excluding category: "${referenceProject["RequestCategory"]}"`);
      }
      if (shouldExcludeStatus && referenceProject["StatusChoice"]) {
        sql += ` AND "StatusChoice" NOT LIKE @p${paramIndex}`;
        sqlParams.push(`%${referenceProject["StatusChoice"]}%`);
        paramIndex++;
        console.log(`[QueryEngine] Excluding status: "${referenceProject["StatusChoice"]}"`);
      }
      if (shouldExcludeClient && referenceProject["Client"]) {
        sql += ` AND "Client" NOT LIKE @p${paramIndex}`;
        sqlParams.push(`%${referenceProject["Client"]}%`);
        paramIndex++;
        console.log(`[QueryEngine] Excluding client: "${referenceProject["Client"]}"`);
      }

      // Add optional filters
      if (args.min_fee !== undefined && !isNaN(Number(args.min_fee))) {
        sql += ` AND CAST(NULLIF("Fee", '') AS NUMERIC) >= @p${paramIndex}`;
        sqlParams.push(Number(args.min_fee));
        paramIndex++;
      }
      if (args.max_fee !== undefined && !isNaN(Number(args.max_fee))) {
        sql += ` AND CAST(NULLIF("Fee", '') AS NUMERIC) <= @p${paramIndex}`;
        sqlParams.push(Number(args.max_fee));
        paramIndex++;
      }
      if (args.start_date) {
        sql += ` AND TRY_CONVERT(DATE, "ConstStartDate") >= @p${paramIndex}`;
        sqlParams.push(args.start_date);
        paramIndex++;
      }
      if (args.end_date) {
        sql += ` AND TRY_CONVERT(DATE, "ConstStartDate") <= @p${paramIndex}`;
        sqlParams.push(args.end_date);
        paramIndex++;
      }

      sql += ` ORDER BY CAST(NULLIF("Fee", '') AS NUMERIC) DESC`;

      console.log(`\n${'='.repeat(80)}`);
      console.log(`[QueryEngine] EXECUTED SQL QUERY (Two-step):`);
      console.log(`${'='.repeat(80)}`);
      console.log(this.substituteParams(sql, sqlParams));
      console.log(`${'='.repeat(80)}\n`);

      const results = await externalDbQuery(sql, sqlParams);
      console.log(`[QueryEngine] Results count: ${results.length}`);
      console.log(`[QueryEngine] Extracted args for follow-up context:`, JSON.stringify(extractedArgs, null, 2));

      return {
        success: true,
        data: results,
        sql_query: sql,
        sql_params: sqlParams,
        extracted_args: extractedArgs, // Store for follow-up queries
      };
    } catch (error) {
      console.error(`Error in handleSameAttributeQuery:`, error);
      return {
        success: false,
        data: [],
        error: String(error),
      };
    }
  }

  /**
   * Handle pattern analysis queries: analyze reference group â†’ find upcoming projects with similar patterns
   */
  private async handlePatternAnalysisQuery(
    args: Record<string, any>,
    externalDbQuery: (sql: string, params?: any[]) => Promise<any[]>
  ): Promise<{ success: boolean; data: any[]; error?: string; sql_query?: string; sql_params?: any[] }> {
    // Tags column doesn't exist in the database - pattern analysis disabled
    console.log('[Pattern Analysis] Feature disabled - Tags column not in database');
    return {
      success: false,
      data: [],
      error: 'Pattern analysis requires Tags column which is not available in the current database schema'
    };
    }

  private async executeQuery(
    functionName: string,
    args: Record<string, any>,
    externalDbQuery: (sql: string, params?: any[]) => Promise<any[]>,
    userQuestion: string = ""
  ): Promise<{ 
    success: boolean; 
    data: any[]; 
    error?: string; 
    sql_query?: string; 
    sql_params?: any[]; 
    extracted_args?: Record<string, any>;
    chart_config?: any;
    summary?: any;
    question?: string;
    function_name?: string;
    arguments?: Record<string, any>;
    row_count?: number;
    message?: string;
  }> {
    try {
      // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
      // NORMALIZE ARGUMENTS FIRST - Must happen BEFORE any SQL template processing
      // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
      
      // Normalize dates: Convert natural language to YYYY-MM-DD
      const normalizedDates = this.normalizeDateRange(args);
      if (normalizedDates.start_date) args.start_date = normalizedDates.start_date;
      if (normalizedDates.end_date) args.end_date = normalizedDates.end_date;

      // POST-NORMALIZATION GUARD: If year is set (from "this year" detection in preprocessQuery),
      // clear start_date/end_date to ensure YEAR() filter is used instead of date range
      if (args.year !== undefined && args.year !== null && !isNaN(Number(args.year))) {
        if (args.start_date || args.end_date) {
          console.log(`[executeQuery] ğŸ“… Year filter active (${args.year}) - clearing redundant date range filters`);
          console.log(`[executeQuery]   Clearing: start_date=${args.start_date}, end_date=${args.end_date}`);
          delete args.start_date;
          delete args.end_date;
          args._date_already_applied = true;
        }
      }

      // Normalize filter arguments: categoryâ†’categories, tagâ†’tags, etc.
      // BUT: Skip normalization if template requires singular form as required parameter
      args._debug_in_executeQuery = { category: args.category, _category_already_applied: args._category_already_applied };
      const templateDef = this.queryTemplates[functionName];
      const skipCategoryNormalization = templateDef?.params?.includes('category');
      const skipTagNormalization = templateDef?.params?.includes('tag');
      this.normalizeFilterArgs(args, skipCategoryNormalization, skipTagNormalization);

      // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
      // FINAL STATUS OPEN/CLOSED EXPANSION (before SQL execution)
      // This runs AFTER all merging/normalization to catch cases where
      // status was set to a single value like "in progress" by follow-up logic
      // but the original question contained "open" or "closed" keywords
      // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
      const FINAL_OPEN_KEYWORDS = /\b(?:which\s+are\s+open|that\s+are\s+open|are\s+open|open\s+projects?|open\s+opportunities?|active\s+projects?|ongoing\s+projects?|current\s+projects?|currently\s+open|still\s+open)\b/i;
      const FINAL_CLOSED_KEYWORDS = /\b(?:which\s+are\s+closed|that\s+are\s+closed|are\s+closed|closed\s+projects?|completed\s+projects?|finished\s+projects?|currently\s+closed)\b/i;
      
      const FINAL_OPEN_STATUSES = ["Proposal Development", "Qualified Lead", "Submitted", "Won", "Lead", "In Progress", "Hold"];
      const FINAL_CLOSED_STATUSES = ["Lost", "No Go", "Cancelled"];
      
      // Handle both string and single-element array status values
      let statusToCheck: string | null = null;
      if (args.status && typeof args.status === 'string') {
        statusToCheck = args.status;
      } else if (args.status && Array.isArray(args.status) && args.status.length === 1 && typeof args.status[0] === 'string') {
        // Single-element array like ["Open"] - treat as synonym to expand
        statusToCheck = args.status[0];
      }
      
      if (statusToCheck) {
        const statusLower = statusToCheck.toLowerCase().trim();
        const isOpenInQuestion = FINAL_OPEN_KEYWORDS.test(userQuestion);
        const isClosedInQuestion = FINAL_CLOSED_KEYWORDS.test(userQuestion);
        
        // First try cache-backed resolution
        const cacheResolved = columnCache.isReady() ? columnCache.resolveStatus(statusLower) : null;
        
        if (cacheResolved && cacheResolved.length > 0) {
          console.log(`[executeQuery] ğŸ”“ CACHE STATUS EXPANSION: "${statusToCheck}" â†’ ${JSON.stringify(cacheResolved)}`);
          args.status = cacheResolved;
        } else if (statusLower === 'open' || statusLower === 'active' || statusLower === 'ongoing' || statusLower === 'current') {
          console.log(`[executeQuery] ğŸ”“ FINAL STATUS EXPANSION: "${statusToCheck}" â†’ ALL open statuses (direct keyword)`);
          args.status = FINAL_OPEN_STATUSES;
        } else if (statusLower === 'closed' || statusLower === 'completed' || statusLower === 'finished' || statusLower === 'lost') {
          console.log(`[executeQuery] ğŸ”’ FINAL STATUS EXPANSION: "${statusToCheck}" â†’ ALL closed statuses (direct keyword)`);
          args.status = FINAL_CLOSED_STATUSES;
        } else if (isOpenInQuestion && FINAL_OPEN_STATUSES.map(s => s.toLowerCase()).includes(statusLower)) {
          console.log(`[executeQuery] ğŸ”“ FINAL STATUS EXPANSION: "${statusToCheck}" â†’ ALL open statuses (context)`);
          args.status = FINAL_OPEN_STATUSES;
        } else if (isClosedInQuestion && FINAL_CLOSED_STATUSES.map(s => s.toLowerCase()).includes(statusLower)) {
          console.log(`[executeQuery] ğŸ”’ FINAL STATUS EXPANSION: "${statusToCheck}" â†’ ALL closed statuses (context)`);
          args.status = FINAL_CLOSED_STATUSES;
        }
      }

      // FINAL STATUS CAPITALIZATION: Ensure status values use proper capitalization for SQL matching
      if (args.status && Array.isArray(args.status)) {
        const STATUS_CAP_MAP: Record<string, string> = {
          'won': 'Won', 'lost': 'Lost', 'lead': 'Lead', 'submitted': 'Submitted',
          'in progress': 'In Progress', 'proposal development': 'Proposal Development',
          'qualified lead': 'Qualified Lead', 'hold': 'Hold', 'no go': 'No Go', 'cancelled': 'Cancelled'
        };
        const capitalizedStatus = args.status.map((s: string) => {
          const lower = s.toLowerCase();
          return STATUS_CAP_MAP[lower] || s;
        });
        if (JSON.stringify(capitalizedStatus) !== JSON.stringify(args.status)) {
          console.log(`[executeQuery] ğŸ“ FINAL STATUS CAPITALIZATION: ${JSON.stringify(args.status)} â†’ ${JSON.stringify(capitalizedStatus)}`);
          args.status = capitalizedStatus;
        }
      }
      // These functions have custom logic and don't use standard SQL templates
      
      // Special handling for status transition queries (not supported - return clarification)
      if (functionName === "clarify_status_transition_not_supported") {
        const fromStatus = args.from_status || "one status";
        const toStatus = args.to_status || "another status";
        const timeRef = args.time_reference ? ` ${args.time_reference}` : "";
        
        return {
          success: false,
          data: [],
          error: `Status transition tracking is not currently available. The system only tracks each project's current status, not its history of status changes.\n\nYou asked about projects that moved from "${fromStatus}" to "${toStatus}"${timeRef}, but this requires historical status change data that isn't being recorded.\n\nAs an alternative, you can:\nâ€¢ Filter by current status: "Show projects in ${toStatus} status"\nâ€¢ Filter by date range: "Show ${toStatus} projects from the last 2 weeks"\nâ€¢ Combine filters: "Show ${toStatus} projects with specific criteria"`,
        };
      }

      // Special handling for simple answer extraction from AI Analysis follow-ups
      if (functionName === "provide_simple_answer") {
        const answer = args.answer || "Information not found in previous analysis.";
        
        console.log(`[QueryEngine] ğŸ“ Extracted answer from AI Analysis: ${answer.substring(0, 100)}...`);
        
        return {
          success: true,
          data: [{
            type: 'ai_analysis',
            narrative: answer,
            source: 'narrative_extraction', // Mark as extracted from previous narrative
            aggregates: null,
            samples: []
          }],
        };
      }

      // Special handling for AI-powered data analysis (predictive/analytical queries)
      if (functionName === "ai_data_analysis") {
        return await this.handleAIDataAnalysis(args, externalDbQuery);
      }
      
      // Special handling for get_projects_with_same_attribute (two-step query)
      if (functionName === "get_projects_with_same_attribute") {
        return await this.handleSameAttributeQuery(args, externalDbQuery);
      }

      // Special handling for get_upcoming_similar_to_group_pattern (two-step pattern analysis)
      if (functionName === "get_upcoming_similar_to_group_pattern") {
        return await this.handlePatternAnalysisQuery(args, externalDbQuery);
      }

      // Now check for standard SQL template
      let template = this.queryTemplates[functionName];
      console.log(`[executeQuery] ğŸ” TEMPLATE LOOKUP: functionName=${functionName}, template_found=${!!template}`);
      if (!template) {
        console.log(`[executeQuery] âŒ TEMPLATE NOT FOUND: ${functionName}, available: ${Object.keys(this.queryTemplates).slice(0, 10).join(', ')}...`);
        return {
          success: false,
          data: [],
          error: `Unknown function: ${functionName}`,
        };
      }

      // Special handling for status="all" - user wants ALL projects regardless of status
      // Redirect to get_largest_projects which returns all projects without status filter
      if ((functionName === "get_projects_by_status" || functionName === "get_clients_by_status_count") 
          && args.status && !Array.isArray(args.status) && args.status.toLowerCase() === 'all') {
        console.log(`[QueryEngine] Detected status='all', redirecting from ${functionName} to get_largest_projects`);
        const originalFunction = functionName;
        functionName = "get_largest_projects";
        // Remove status from args since get_largest_projects doesn't use it
        const { status, ...restArgs } = args;
        args = restArgs;
        // Re-fetch the template for the new function
        const newTemplate = this.queryTemplates[functionName];
        if (!newTemplate) {
          return {
            success: false,
            data: [],
            error: `Failed to redirect from ${originalFunction} to ${functionName}`,
          };
        }
        // Update template reference and recursively call executeQuery
        template = newTemplate;
      }

      // Validation: Prevent get_projects_by_fee_range without fee parameters
      // This catches misclassified queries like "status is submitted" that were wrongly classified as fee_range
      if (functionName === "get_projects_by_fee_range") {
        const hasFeeParams = args.min_fee !== undefined || args.max_fee !== undefined;
        if (!hasFeeParams) {
          console.log(`[QueryEngine] âš ï¸ Detected get_projects_by_fee_range without fee params - likely misclassified`);
          console.log(`[QueryEngine]   Args: ${JSON.stringify(args)}`);
          
          // If it has status, redirect to get_projects_by_status
          if (args.status) {
            console.log(`[QueryEngine]   Redirecting to get_projects_by_status instead`);
            functionName = "get_projects_by_status";
            const newTemplate = this.queryTemplates[functionName];
            if (!newTemplate) {
              return {
                success: false,
                data: [],
                error: `Failed to redirect from get_projects_by_fee_range to get_projects_by_status`,
              };
            }
            template = newTemplate;
          } else {
            // No status either - this is a malformed query
            return {
              success: false,
              data: [],
              error: `get_projects_by_fee_range requires at least min_fee or max_fee parameter`,
            };
          }
        }
      }
      
      // CRITICAL FIX: Detect EXACT win rate queries like "win rate of 0%", "0% win rate", "exactly 50%"
      // When user asks for an EXACT percentage, we need min_win = max_win = X
      const questionLower = userQuestion.toLowerCase();
      const exactWinPatterns = [
        /win\s*(?:rate|%|percent(?:age)?)\s*(?:of|is|=|equals?)\s*(\d+)\s*%?/i,
        /(\d+)\s*%?\s*win\s*(?:rate|%|percent(?:age)?)/i,
        /exactly\s*(\d+)\s*%?\s*(?:win)?/i,
        /^(\d+)\s*%\s*(?:win)?$/i,
        /win\s*(?:rate|%)?\s*(?:is\s+)?(\d+)\s*$/i,
      ];
      
      let exactWinValue: number | null = null;
      for (const pattern of exactWinPatterns) {
        const match = questionLower.match(pattern);
        if (match) {
          exactWinValue = parseInt(match[1], 10);
          break;
        }
      }
      
      // If exact win rate detected and no below/above/less/greater language, treat as exact match
      const hasRangeLanguage = /\b(below|above|under|over|less\s+than|greater\s+than|more\s+than|at\s+least|at\s+most)\b/i.test(userQuestion);
      
      if (exactWinValue !== null && !hasRangeLanguage && args.min_win === undefined && args.max_win === undefined) {
        args.min_win = exactWinValue;
        args.max_win = exactWinValue;
        console.log(`[QueryEngine] âœ“ EXACT WIN RATE detected: "${userQuestion}" â†’ min_win=${exactWinValue}, max_win=${exactWinValue}`);
      } else if (exactWinValue !== null && !hasRangeLanguage && args.min_win !== undefined && args.max_win === undefined) {
        // GPT extracted min_win but not max_win for an exact query - add max_win
        args.max_win = args.min_win;
        console.log(`[QueryEngine] âœ“ EXACT WIN RATE fix: Adding max_win=${args.min_win} to match min_win for exact match`);
      }
      
      // Fix for win range queries: provide default min_win of 0 when only max_win is specified
      // This handles queries like "show projects with win% below 15%"
      if (functionName === "get_projects_by_win_range" || functionName === "get_projects_by_category_and_win_range" || functionName === "get_projects_by_status_and_win_rate") {
        if (args.max_win !== undefined && args.min_win === undefined) {
          args.min_win = 0;
          console.log(`[QueryEngine] âœ“ Added default min_win=0 for "below ${args.max_win}%" query (${functionName})`);
        }
      }
      
      // Also add default min_win=0 for any function that uses win rate filters
      // This ensures queries like "Education projects with win rate below 60%" work correctly
      if (args.max_win !== undefined && args.min_win === undefined) {
        // Check if this function template requires min_win
        const template = this.queryTemplates[functionName];
        if (template && template.params && template.params.includes('min_win')) {
          args.min_win = 0;
          console.log(`[QueryEngine] âœ“ Added default min_win=0 for template requiring min_win (${functionName})`);
        }
      }
      
      // Fix for fee range queries: provide default min_fee of 0 when only max_fee is specified
      // This handles queries like "less than 10 million", "below 1 million", etc.
      if (functionName === "get_projects_by_fee_range") {
        if (args.max_fee !== undefined && args.min_fee === undefined) {
          args.min_fee = 0;
          console.log(`[QueryEngine] âœ“ Added default min_fee=0 for "below $${(args.max_fee / 1000000).toFixed(1)}M" query`);
        }
      }

      let sql = template.sql;
      const sqlParams: any[] = [];
      
      // Handle column_name substitution for get_project_column_by_id
      if (functionName === "get_project_column_by_id" && args.column_name) {
        sql = sql.replace(/\{column_name\}/g, args.column_name);
      }
      
      // Handle columns substitution for select_specific_columns
      if (functionName === "select_specific_columns") {
        if (args.columns) {
          // Handle special case: "all" or "all columns" â†’ SELECT *
          const columnsLower = args.columns.toLowerCase().trim();
          if (columnsLower === 'all' || columnsLower === 'all columns' || columnsLower === '*') {
            console.log('[Columns] Special case detected: "all" â†’ SELECT *');
            sql = sql.replace(/\{columns\}/g, '*');
          } else {
            // Split by comma, trim, wrap each in quotes
            const columnList = args.columns
              .split(',')
              .map((col: string) => `"${col.trim()}"`)
              .join(', ');
            sql = sql.replace(/\{columns\}/g, columnList);
          }
        } else {
          // Default to all columns when none specified
          console.log('[Columns] No columns specified - defaulting to SELECT *');
          sql = sql.replace(/\{columns\}/g, '*');
        }
      }
      
      // SECURITY: Validate that SQL is read-only before building/executing
      if (!this.isReadOnlySQL(sql)) {
        console.error(`[SECURITY] â›” BLOCKED non-SELECT query: ${sql}`);
        return {
          success: false,
          data: [],
          error: `Security error: Only SELECT queries are allowed. Destructive operations are blocked.`,
        };
      }

      // First, add template's required parameters in order
      for (const paramName of template.params) {
        if (args[paramName] !== undefined) {
          // Add wildcards for text search parameters that use LIKE
          // FLEXIBLE WHITESPACE: Handle "waste water" vs "wastewater" variations
          if (paramName === 'division' || paramName === 'department') {
            // Use flexible matching for division/department - handles missing punctuation
            // "LCC Healthcare" matches "LCC - Healthcare", "Civil Structural" matches "Civil & Structural"
            sqlParams.push(normalizeDivisionForFlexibleMatch(args[paramName]));
          } else if (paramName === 'category' || paramName === 'project_type' || paramName === 'service_type') {
            // FLEXIBLE WHITESPACE: Use no-spaces version for category/type fields
            // "waste water" â†’ search for "wastewater" pattern to match database entries
            const term = args[paramName];
            if (term && typeof term === 'string' && term.includes(' ')) {
              // Use flexible pattern that matches with or without spaces
              const noSpaces = term.replace(/\s+/g, '');
              sqlParams.push(`%${noSpaces}%`);
              console.log(`[FlexibleMatch] ${paramName}: "${term}" â†’ LIKE "%${noSpaces}%"`);
            } else {
              sqlParams.push(`%${term}%`);
            }
          } else if (paramName === 'poc' || paramName === 'poc1' || paramName === 'poc2' || paramName === 'keyword' || paramName === 'client' || paramName === 'project_name' || paramName === 'company') {
            // Standard LIKE matching with wildcards
            sqlParams.push(`%${args[paramName]}%`);
          } else {
            sqlParams.push(args[paramName]);
          }
        }
      }

      // Mark if parameters are already in required params to avoid duplication in additional_filters
      if (template.params.includes("start_date") && template.params.includes("end_date")) {
        args._date_already_applied = true;
      }
      if (template.params.includes("poc")) {
        args._poc_already_applied = true;
      }
      if (template.params.includes("keyword")) {
        args._keyword_already_applied = true;
        // CRITICAL: If keyword is required but not set, extract it from the question
        if (!args.keyword && userQuestion) {
          // Extract entity from question by removing common query words
          let extractedKeyword = userQuestion
            .replace(/\b(show|display|list|get|find|search|all|the|projects?|data|for|of|with|from|by|me|give|provide)\b/gi, '')
            .replace(/\s+/g, ' ')
            .trim();
          // Strip any surrounding quotes
          extractedKeyword = extractedKeyword.replace(/^["']+|["']+$/g, '');
          if (extractedKeyword.length > 2) {
            args.keyword = extractedKeyword;
            console.log(`[buildSql] ğŸ”§ KEYWORD RECOVERY: Extracted keyword "${extractedKeyword}" from question`);
            
            // CRITICAL: Clear project_type if it's contained within the keyword
            // This prevents "Civil Engineering Services" from being treated as a filter
            // when it's actually part of the project title
            if (args.project_type && typeof args.project_type === 'string' && 
                extractedKeyword.toLowerCase().includes(args.project_type.toLowerCase())) {
              console.log(`[buildSql] ğŸ§¹ CLEARING project_type "${args.project_type}" - it's part of keyword`);
              delete args.project_type;
              delete args._project_type_explicit;
            }
          }
        }
      }

      // Then build SQL with dynamic replacements (this will add more params)
      // Pass template.params to avoid duplicating filters in {additional_filters}
      // IMPORTANT: Also exclude plural forms (categoryâ†’categories, tagâ†’tags) since normalizeFilterArgs
      // converts singular to plural before buildSql is called
      const excludeParams = [...template.params];
      if (template.params.includes('category')) {
        excludeParams.push('categories'); // Exclude both singular and plural
      }
      if (template.params.includes('tag')) {
        excludeParams.push('tags'); // Exclude both singular and plural
      }
      // If template has placeholder conditions, exclude the corresponding params to avoid duplicates
      if (template.sql.includes('{project_type_condition}')) {
        excludeParams.push('project_type', 'project_types');
      }
      if (template.sql.includes('{service_type_condition}')) {
        excludeParams.push('service_type');
      }
      if (template.sql.includes('{category_or_type_condition}')) {
        excludeParams.push('category', 'categories', 'project_type', 'project_types');
      }
      sql = this.buildSql(sql, args, sqlParams, template.params.length, excludeParams);

      // Log the actual executed SQL with parameters substituted
      const executedSql = this.substituteParams(sql, sqlParams);
      
      // Display the SQL with @pN placeholders for MS SQL
      const displaySql = convertPlaceholders(executedSql);
      
      console.log(`\n${'='.repeat(80)}`);
      console.log(`[QueryEngine] EXECUTED SQL QUERY (MS SQL):`);
      console.log(`${'='.repeat(80)}`);
      console.log(displaySql);
      console.log(`${'='.repeat(80)}\n`);

      const results = await externalDbQuery(sql, sqlParams);

      console.log(`[QueryEngine] Results count: ${results.length}`);

      // For get_top_tags, extract tag values so follow-up questions can reference them
      let extracted_args: Record<string, any> | undefined;
      if (false /* get_top_tags removed */ && results.length > 0) {
        // Extract all tag values from the results
        const tagValues = results.map(row => row.tag).filter(tag => tag);
        if (tagValues.length > 0) {
          extracted_args = { tags: tagValues };
          console.log(`[QueryEngine] Extracted tags for context:`, tagValues);
        }
      }

      // Return the SQL with MS SQL placeholders for display in UI logs
      const returnSql = convertPlaceholders(sql);
      
      return {
        success: true,
        data: results,
        sql_query: returnSql,
        sql_params: sqlParams,
        extracted_args,
      };
    } catch (error) {
      console.error(`Error executing ${functionName}:`, error);
      return {
        success: false,
        data: [],
        error: String(error),
      };
    }
  }

  /**
   * Normalize date parameters: convert natural language dates to YYYY-MM-DD format
   * Handles both explicit ISO dates and relative phrases like "last 6 months"
   */
  private normalizeDateRange(args: Record<string, any>): {
    start_date?: string;
    end_date?: string;
  } {
    const result: { start_date?: string; end_date?: string } = {};

    // GUARD: If year filter is already set (from "this year" detection in preprocessQuery),
    // skip date normalization entirely - YEAR() filter will be used instead
    if (args.year !== undefined && args.year !== null && !isNaN(Number(args.year))) {
      console.log(`[normalizeDateRange] â­ï¸ Skipping - year filter (${args.year}) already set`);
      return result; // Return empty - no date range needed
    }

    // If both dates are already ISO format, return them
    const isoDatePattern = /^\d{4}-\d{2}-\d{2}$/;
    if (
      args.start_date &&
      args.end_date &&
      isoDatePattern.test(args.start_date) &&
      isoDatePattern.test(args.end_date)
    ) {
      result.start_date = args.start_date;
      result.end_date = args.end_date;
      return result;
    }

    // If start_date is natural language (e.g., "last 6 months"), parse it
    if (args.start_date && !isoDatePattern.test(args.start_date)) {
      const parsed = this.timeParser.parse(args.start_date);
      if (parsed) {
        result.start_date = parsed[0];
        result.end_date = parsed[1];
        console.log(`[QueryEngine] Normalized date: "${args.start_date}" â†’ ${result.start_date} to ${result.end_date}`);
        return result;
      } else {
        console.warn(`[QueryEngine] Could not parse date: "${args.start_date}"`);
      }
    }

    // If only explicit dates provided, use them
    if (args.start_date && isoDatePattern.test(args.start_date)) {
      result.start_date = args.start_date;
    }
    if (args.end_date && isoDatePattern.test(args.end_date)) {
      result.end_date = args.end_date;
    }

    return result;
  }

  /**
   * Normalize filter arguments: convert singular forms to arrays and dedupe
   * Handles: categoryâ†’categories, tagâ†’tags, exclude_categoryâ†’exclude_categories, exclude_tagâ†’exclude_tags
   * Note: project_type, status, client, company stay singular (no conversion needed)
   */
  private normalizeFilterArgs(args: Record<string, any>, skipCategoryNormalization: boolean = false, skipTagNormalization: boolean = false): void {
    // Helper function to ensure array format, dedupe, and remove empties
    const ensureArray = (value: any): string[] | null => {
      if (!value) return null;
      
      if (Array.isArray(value)) {
        const filtered = value
          .map((v: any) => String(v).trim())
          .filter((v: string) => v.length > 0);
        return filtered.length > 0 ? Array.from(new Set(filtered)) : null;
      }
      
      const str = String(value).trim();
      return str.length > 0 ? [str] : null;
    };

    // category â†’ categories (merge if both exist)
    // Skip if template requires singular 'category' parameter
    console.log(`[NormalizeFilterArgs] args._category_already_applied=${args._category_already_applied}, args.category="${args.category}"`);
    if (!skipCategoryNormalization && !args._category_already_applied && (args.category || args.categories)) {
      const singularArray = ensureArray(args.category);
      const pluralArray = ensureArray(args.categories);
      
      if (singularArray && pluralArray) {
        // Merge and dedupe
        args.categories = Array.from(new Set([...pluralArray, ...singularArray]));
      } else if (singularArray) {
        args.categories = singularArray;
      } else if (pluralArray) {
        args.categories = pluralArray;
      }
      
   // Remove singular form after processing
    }

    // tag â†’ tags (merge if both exist)
    // Skip if template requires singular 'tag' parameter
    if (!skipTagNormalization && (args.tag || args.tags)) {
      const singularArray = ensureArray(args.tag);
      const pluralArray = ensureArray(args.tags);
      
      if (singularArray && pluralArray) {
        args.tags = Array.from(new Set([...pluralArray, ...singularArray]));
      } else if (singularArray) {
        args.tags = singularArray;
      } else if (pluralArray) {
        args.tags = pluralArray;
      }
      
      delete args.tag; // Remove singular form after processing
    }

    // poc_names â†’ pocs (AI sometimes uses poc_names instead of pocs)
    if (args.poc_names && Array.isArray(args.poc_names)) {
      args.pocs = args.poc_names;
      delete args.poc_names;
      console.log(`[Normalize] Converted poc_names to pocs: ${args.pocs.join(', ')}`);
    }

    // Handle project_type with "and" - split into project_types array
    if (args.project_type && typeof args.project_type === 'string' && 
        (args.project_type.toLowerCase().includes(' and ') || args.project_type.includes(','))) {
      const types = args.project_type
        .split(/,|\s+and\s+/i)
        .map((t: string) => t.trim())
        .filter((t: string) => t.length > 0);
      if (types.length > 1) {
        args.project_types = types;
        delete args.project_type;
        console.log(`[Normalize] Split project_type into project_types: ${types.join(', ')}`);
      }
    }

    // exclude_category â†’ exclude_categories (merge if both exist)
    if (args.exclude_category || args.exclude_categories) {
      const singularArray = ensureArray(args.exclude_category);
      const pluralArray = ensureArray(args.exclude_categories);
      
      if (singularArray && pluralArray) {
        args.exclude_categories = Array.from(new Set([...pluralArray, ...singularArray]));
      } else if (singularArray) {
        args.exclude_categories = singularArray;
      } else if (pluralArray) {
        args.exclude_categories = pluralArray;
      }
      
      delete args.exclude_category; // Remove singular form after processing
    }

    // exclude_tag â†’ exclude_tags (merge if both exist)
    if (args.exclude_tag || args.exclude_tags) {
      const singularArray = ensureArray(args.exclude_tag);
      const pluralArray = ensureArray(args.exclude_tags);
      
      if (singularArray && pluralArray) {
        args.exclude_tags = Array.from(new Set([...pluralArray, ...singularArray]));
      } else if (singularArray) {
        args.exclude_tags = singularArray;
      } else if (pluralArray) {
        args.exclude_tags = pluralArray;
      }
      
      delete args.exclude_tag; // Remove singular form after processing
    }
  }

  /**
   * Build additional filters for follow-up questions
   * This allows ANY query to accept filter refinements from follow-ups
   * Returns SQL fragment and the next parameter index
   */
  private buildAdditionalFilters(
    args: Record<string, any>,
    params: any[],
    startIndex: number,
    excludeParams: string[] = []
  ): { sql: string; nextIndex: number } {
    const filters: string[] = [];
    let paramIndex = startIndex;

    
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    // ENTITY-PROJECT_TYPE CLEANUP:
    // If company/client/organization contains project type keywords, clear project_type
    // This prevents "DFW Airport" from filtering by Client AND ProjectType="Airports"
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    const entityVal = args.company || args.client || args.organization;
    if (entityVal && args.project_type) {
      const ptKeywordMap: Record<string, string[]> = {
        'Airports': ['airport', 'airports', 'aviation'],
        'Hospitals': ['hospital', 'hospitals', 'medical', 'health'],
        'Transit': ['transit', 'transportation', 'railway'],
        'K-12': ['school', 'schools'],
        'Higher Education': ['university', 'college'],
        'Government': ['government', 'civic', 'municipal'],
        'Water/Wastewater': ['water', 'wastewater', 'utility'],
        'Industrial': ['industrial', 'manufacturing', 'factory']
      };
      const entLower = entityVal.toLowerCase();
      const ptv = Array.isArray(args.project_type) ? args.project_type[0] : args.project_type;
      const kws = ptKeywordMap[ptv] || [];
      if (kws.some(k => entLower.includes(k))) {
        console.log(`[buildAdditionalFilters] ğŸ§¹ ENTITY-PT CLEANUP: Clearing project_type="${ptv}" - found in entity="${entityVal}"`);
        delete args.project_type;
        delete args._project_type_explicit;
      }
    }
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    // DIRECTIONAL DIVISION TO REGION CONVERSION:
    // If user says "southeast division" but there's no such division, they likely mean a region
    // Since the database has a Region column (with values like "NA - South", "NA - West", etc.),
    // we should filter by Region directly instead of expanding to individual states.
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    if (args.division && typeof args.division === 'string') {
      const divisionLower = args.division.toLowerCase().trim();
      
      // Directional terms that should map to Region column instead of Division
      const directionalTerms = [
        'southeast', 'southeastern', 'northeast', 'northeastern',
        'midwest', 'midwestern', 'southwest', 'southwestern',
        'northwest', 'northwestern', 'west', 'western',
        'south', 'southern', 'north', 'northern', 'east', 'eastern'
      ];
      
      // Check if division is actually a directional/region term
      if (directionalTerms.includes(divisionLower)) {
        console.log(`[Filter] ğŸ§­ DIRECTIONAL â†’ REGION: "${args.division}" â†’ Region column filter`);
        
        // Remove the division filter and add as region instead
        const regionValue = args.division;
        delete args.division;
        if (args.divisions) {
          args.divisions = args.divisions.filter((d: string) => !directionalTerms.includes(d.toLowerCase().trim()));
          if (args.divisions.length === 0) delete args.divisions;
        }
        
        // Add to regions array for Region column filtering (merge with existing)
        const existingRegions = Array.isArray(args.regions) ? args.regions : (args.region ? [args.region] : []);
        args.regions = Array.from(new Set([...existingRegions, regionValue]));
        delete args.region; // Use regions array instead
        args._directional_to_region_converted = true;
      }
    }

    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    // COMPOUND DIVISION CLEANUP: Clear company/poc/category if they're substrings of division
    // This catches cases where LLM incorrectly split "LCC - Healthcare" into company="LCC" + division="Healthcare"
    // or where LLM extracts category="Healthcare" from "LCC - Healthcare division"
    // ONLY triggers for confirmed compound divisions with punctuation (hyphen, colon, ampersand)
    // Multi-word divisions without punctuation (e.g., "LCC commercial") should NOT trigger this
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    if (args.division && typeof args.division === 'string') {
      const divisionLower = args.division.toLowerCase();
      const isConfirmedCompoundDivision = /[-:&]/.test(args.division);
      
      // ONLY apply cleanup for confirmed compound divisions (with punctuation)
      if (isConfirmedCompoundDivision) {
        // Check if company is a substring of division
        if (args.company && typeof args.company === 'string') {
          const companyLower = args.company.toLowerCase();
          if (divisionLower.includes(companyLower)) {
            console.log(`[Filter] âš ï¸ CLEANUP: Removing company="${args.company}" - it's part of compound division="${args.division}"`);
            delete args.company;
          }
        }
        // Check if POC is a substring of division (e.g., "Hill" in "Hill - Saudi Arabia - Projects")
        if (args.poc && typeof args.poc === 'string') {
          const pocLower = args.poc.toLowerCase();
          if (divisionLower.includes(pocLower)) {
            console.log(`[Filter] âš ï¸ CLEANUP: Removing poc="${args.poc}" - it's part of compound division="${args.division}"`);
            delete args.poc;
          }
        }
        // Check if category is a substring of division (e.g., "Healthcare" in "LCC - Healthcare")
        if (args.category && typeof args.category === 'string') {
          const categoryLower = args.category.toLowerCase();
          if (divisionLower.includes(categoryLower)) {
            console.log(`[Filter] âš ï¸ CLEANUP: Removing category="${args.category}" - it's part of compound division="${args.division}"`);
        
          }
        }
        // Check if categories array contains values that are substrings of division
        if (args.categories && Array.isArray(args.categories)) {
          const originalCategories = [...args.categories];
          args.categories = args.categories.filter((cat: string) => {
            const catLower = cat.toLowerCase();
            if (divisionLower.includes(catLower)) {
              console.log(`[Filter] âš ï¸ CLEANUP: Removing category "${cat}" from categories array - it's part of compound division="${args.division}"`);
              return false;
            }
            return true;
          });
          if (args.categories.length === 0) {
        
       // Also remove singular form
          }
        }
        // Check if project_type is a substring of division (e.g., "Healthcare" in "LCC - Healthcare")
        if (args.project_type && typeof args.project_type === 'string') {
          const projectTypeLower = args.project_type.toLowerCase();
          if (divisionLower.includes(projectTypeLower)) {
            console.log(`[Filter] âš ï¸ CLEANUP: Removing project_type="${args.project_type}" - it's part of compound division="${args.division}"`);
            delete args.project_type;
          }
        }
        // Check if project_types array contains values that are substrings of division
        if (args.project_types && Array.isArray(args.project_types)) {
          args.project_types = args.project_types.filter((pt: string) => {
            const ptLower = pt.toLowerCase();
            if (divisionLower.includes(ptLower)) {
              console.log(`[Filter] âš ï¸ CLEANUP: Removing project_type "${pt}" from project_types array - it's part of compound division="${args.division}"`);
              return false;
            }
            return true;
          });
          if (args.project_types.length === 0) {
            delete args.project_types;
          }
        }
      }
    }

    // SAFETY NET: If category/categories is set but project_type is not, treat as project_type
    // This ensures we default to "ProjectType" column instead of "RequestCategory"
    // EXCEPT: Skip this when user explicitly said "category/categories" (marked by _explicit_category flag)
    // CRITICAL FIX: Handle BOTH singular (category) and plural (categories) forms for follow-up preservation
    if ((args.category || args.categories) && !args.project_type && !args.project_types && !args._explicit_category && !args._category_already_applied) {
      // Merge singular and plural into one array
      const singularVal = args.category ? [args.category] : [];
      const pluralVal = Array.isArray(args.categories) ? args.categories : (args.categories ? [args.categories] : []);
      const categoriesArray = Array.from(new Set([...singularVal, ...pluralVal]));
      
      if (categoriesArray.length > 0) {
        console.log(`[Filter] âš ï¸ SAFETY NET: Moving category/categories to project_type in buildAdditionalFilters`);
        console.log(`[Filter]   category="${args.category}", categories=${JSON.stringify(args.categories)} â†’ project_type(s)`);
        if (categoriesArray.length === 1) {
          args.project_type = categoriesArray[0];
        } else {
          args.project_types = categoriesArray;
        }
    
    
       // Also remove singular form
      }
    }

    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    // "THIS YEAR" GUARD: Check for "this year" pattern and enforce YEAR filter
    // This must run BEFORE normalizeDateRange to prevent date range from being set
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    // Note: We check a special flag that should be set by preprocessQuery
    // because userQuestion is not available here
    if (args._this_year_detected && !args.year) {
      const currentYearBuild = new Date().getFullYear();
      args.year = currentYearBuild;
      delete args.start_date;
      delete args.end_date;
      args._date_already_applied = true;
      console.log(`[buildAdditionalFilters] ğŸ“… THIS YEAR GUARD: Set year=${currentYearBuild}, cleared dates`);
    }
    
    // If year filter is set, skip date normalization entirely
    if (args.year !== undefined && args.year !== null && !isNaN(Number(args.year))) {
      // Don't call normalizeDateRange - year filter takes precedence
      delete args.start_date;
      delete args.end_date;
      console.log(`[buildAdditionalFilters] ğŸ“… Year filter (${args.year}) active - skipping date normalization`);
    } else {
      // Normalize dates first (convert "last 6 months" to actual dates)
      const dates = this.normalizeDateRange(args);
      if (dates.start_date) args.start_date = dates.start_date;
      if (dates.end_date) args.end_date = dates.end_date;
    }

    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    // QUARTER FILTER: Filter by quarter (Q1=1-3, Q2=4-6, Q3=7-9, Q4=10-12)
    // Used when user asks for specific quarter data (e.g., "Q4 2026 revenue")
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    if (args.quarter !== undefined && !isNaN(Number(args.quarter)) && !excludeParams.includes('quarter')) {
      const quarter = Number(args.quarter);
      if (quarter >= 1 && quarter <= 4) {
        // Map quarter to month range
        const quarterMonths: Record<number, number[]> = {
          1: [1, 2, 3],    // Q1: Jan, Feb, Mar
          2: [4, 5, 6],    // Q2: Apr, May, Jun
          3: [7, 8, 9],    // Q3: Jul, Aug, Sep
          4: [10, 11, 12]  // Q4: Oct, Nov, Dec
        };
        const months = quarterMonths[quarter];
        filters.push(`MONTH(TRY_CONVERT(DATE, "ConstStartDate")) IN (${months.join(', ')})`);
        console.log(`[Filter] Quarter filter: Q${quarter} â†’ months ${months.join(', ')}`);
      }
    }

    // Size filter (uses CASE statement)
    if (args.size) {
      // Normalize size synonyms to canonical values
      const normalizeSizeValue = (size: string): string => {
        const lowerSize = size.toLowerCase().trim();
        const sizeMap: Record<string, string> = {
          // Mega synonyms
          'mega': 'Mega', 'huge': 'Mega', 'massive': 'Mega', 'giant': 'Mega', 'biggest': 'Mega', 'largest': 'Mega',
          // Large synonyms
          'large': 'Large', 'big': 'Large', 'major': 'Large',
          // Medium synonyms
          'medium': 'Medium', 'mid-sized': 'Medium', 'moderate': 'Medium', 'mid': 'Medium',
          // Small synonyms
          'small': 'Small', 'minor': 'Small', 'little': 'Small',
          // Micro synonyms
          'micro': 'Micro', 'tiny': 'Micro', 'smallest': 'Micro'
        };
        return sizeMap[lowerSize] || size; // Return original if not found
      };
      
      const sizeCase = this.sizeCalculator.getSqlCaseStatement();
      
      // Handle multiple size values (e.g., "Small, Medium" or "Small and Medium")
      const sizeString = args.size.toString();
      const multipleSizes = sizeString.includes(',') || sizeString.toLowerCase().includes(' and ');
      
      if (multipleSizes) {
        // Split by comma or "and", trim, normalize, and filter out empty values
        const sizes = sizeString
          .split(/,|\s+and\s+/i)
          .map((s: string) => normalizeSizeValue(s.trim()))
          .filter((s: string) => s.length > 0);
        
        // Use IN clause for multiple sizes: (size_case) IN ('Small', 'Medium')
        filters.push(`(${sizeCase}) IN (SELECT value FROM STRING_SPLIT(@p${paramIndex}, ','))`);
        params.push(sizes.join(','));
        paramIndex++;
      } else {
        // Single size value - normalize it
        const normalizedSize = normalizeSizeValue(sizeString);
        filters.push(`(${sizeCase}) = @p${paramIndex}`);
        params.push(normalizedSize);
        paramIndex++;
      }
    }

    // Status filter - apply in additional_filters for templates that don't have {status_filter} placeholder
    // Skip if 'status' is in excludeParams (meaning template has its own {status_filter})
    if (args.status && !excludeParams.includes('status')) {
      if (Array.isArray(args.status) && args.status.length > 0) {
        // Handle multiple status values: (status LIKE val1 OR status LIKE val2)
        const statusConditions = args.status.map((status: string) => {
          const condition = `"StatusChoice" LIKE @p${paramIndex}`;
          params.push(`%${status}%`);
          paramIndex++;
          return condition;
        });
        filters.push(`(${statusConditions.join(' OR ')})`);
        console.log(`[Filter] Status filter (multiple): ${args.status.join(', ')}`);
      } else if (!Array.isArray(args.status)) {
        // Single status value
        filters.push(`"StatusChoice" LIKE @p${paramIndex}`);
        params.push(`%${args.status}%`);
        paramIndex++;
        console.log(`[Filter] Status filter: ${args.status}`);
      }
    }

    // Is Updated filter - binary field (values: "1" or "" empty string)
    if (args.is_updated !== undefined && args.is_updated !== null) {
      filters.push(`"IsUpdated" = @p${paramIndex}`);
      params.push(args.is_updated.toString());
      paramIndex++;
    }

    // Title filter - case-insensitive LIKE match for project title
    if (args.title && !excludeParams.includes("title")) {
      filters.push(`"Title" LIKE @p${paramIndex}`);
      params.push(`%${args.title}%`);
      paramIndex++;
      console.log(`[Filter] Title filter: ${args.title}`);
    }

    // State/Location filter - case-insensitive match (single state)
    // Skip if excluded (template uses {state_filter} placeholder)
    // ALSO skip if state_code is actually an international region (should use Region column instead)
    if (args.state_code && !args.states && !args.state_lookup_min && !args.state_lookup_max && !excludeParams.includes('state_code')) {
      const INTERNATIONAL_REGION_NAMES = [
        'hong kong', 'europe', 'mena', 'middle east', 'asia', 'southeast asia', 'south east asia',
        'singapore', 'canada', 'latin america', 'south america', 'central america',
        'sub-saharan africa', 'africa', 'oceania', 'australia', 'united kingdom', 'uk',
        'china', 'japan', 'india', 'korea', 'vietnam', 'thailand', 'malaysia', 'indonesia',
        'philippines', 'taiwan', 'uae', 'saudi arabia', 'qatar', 'dubai', 'abu dhabi',
        'germany', 'france', 'spain', 'italy', 'netherlands', 'belgium', 'switzerland',
        'poland', 'czech', 'austria', 'sweden', 'norway', 'denmark', 'finland', 'ireland',
        'portugal', 'greece', 'turkey', 'russia', 'ukraine', 'brazil', 'mexico', 'argentina',
        'chile', 'colombia', 'peru', 'central asia', 'caribbean', 'puerto rico'
      ];
      
      const stateCodeLower = args.state_code.toLowerCase();
      const isInternationalRegion = INTERNATIONAL_REGION_NAMES.includes(stateCodeLower);
      
      if (isInternationalRegion) {
        // This is an international region - convert to region filter instead of state filter
        console.log(`[Filter] âš ï¸ CONVERTING state_code "${args.state_code}" to region filter (international location)`);
        if (!args.region) {
          args.region = args.state_code;
        }
        // Don't add state filter - region filter will be added below
      } else {
        filters.push(`"State" LIKE @p${paramIndex}`);
        params.push(`%${args.state_code}%`);
        paramIndex++;
      }
    }
    
    // States array filter - for region queries (multiple states)
    // Skip if excluded (template uses {state_filter} placeholder)
    // Use case-insensitive matching with LIKE for each state
    console.log(`[buildAdditionalFilters] ğŸ“Š STATE CHECK: args.states=${args.states?.length || 0}, args.exclude_states=${args.exclude_states?.length || 0}`);
    if (args.states && Array.isArray(args.states) && args.states.length > 0 && !excludeParams.includes('states') && !(args.regions && Array.isArray(args.regions) && args.regions.length > 0)) {
      const stateConditions = args.states.map((_: string, idx: number) => `"State" LIKE @p${paramIndex + idx}`);
      filters.push(`(${stateConditions.join(' OR ')})`);
      args.states.forEach((state: string) => params.push(state));
      paramIndex += args.states.length;
      console.log(`[Filter] Region/States filter: ${args.states.length} states (case-insensitive) - USING LIKE (INCLUSION)`);
    }
    
    // EXCLUDE States array filter - for "except [region]" queries
    // Uses NOT LIKE to exclude the specified states
    if (args.exclude_states && Array.isArray(args.exclude_states) && args.exclude_states.length > 0 && !excludeParams.includes('exclude_states')) {
      const excludeStateConditions = args.exclude_states.map((_: string, idx: number) => `"State" NOT LIKE @p${paramIndex + idx}`);
      filters.push(`(${excludeStateConditions.join(' AND ')})`);
      args.exclude_states.forEach((state: string) => params.push(state));
      paramIndex += args.exclude_states.length;
      console.log(`[Filter] EXCLUDING Region/States filter: ${args.exclude_states.length} states - USING NOT LIKE (EXCLUSION)`);
    }
    
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    // INTERNATIONAL REGION FILTER: Filter by Region column for non-US regions
    // Handles: Europe, Hong Kong, MENA, Canada, Latin America, Sub-Saharan Africa,
    // South East Asia, Singapore, Central Asia, Oceania, etc.
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    console.log(`[buildSql] ğŸ” REGION CHECK: args.region=${args.region}, args.regions=${args.regions?.length || 0}, excludeParams=${JSON.stringify(excludeParams)}`);
    // Skip singular region if regions array is already set (avoid duplicate filters)
    const skipSingularRegion = args.regions && Array.isArray(args.regions) && args.regions.length > 0;
    if (args.region && !excludeParams.includes('region') && !skipSingularRegion) {
      // Always query Region column directly - no more state expansion
      filters.push(`"Region" LIKE @p${paramIndex}`);
      params.push(`%${args.region}%`);
      paramIndex++;
      console.log(`[Filter] âœ… Region column filter ADDED: "${args.region}" at paramIndex ${paramIndex-1}`);
    } else if (skipSingularRegion) {
      console.log(`[Filter] âš ï¸ Singular Region SKIPPED - regions array already set (${args.regions.length} items)`);
    } else if (args.region) {
      console.log(`[Filter] âš ï¸ Region SKIPPED - in excludeParams`);
    } else {
      console.log(`[Filter] âš ï¸ Region NOT SET in args`);
    }
    
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    // REGIONS ARRAY FILTER: Filter by Region column for US regions
    // Uses Region column values like 'NA - South', 'NA - West', 'NA - Northeast', etc.
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    if (args.regions && Array.isArray(args.regions) && args.regions.length > 0 && !excludeParams.includes('regions')) {
      const regionConditions = args.regions.map((_: string, idx: number) => `"Region" LIKE @p${paramIndex + idx}`);
      filters.push(`(${regionConditions.join(' OR ')})`);
      args.regions.forEach((region: string) => params.push(`%${region}%`));
      paramIndex += args.regions.length;
      console.log(`[Filter] US Regions filter (Region column): ${args.regions.join(', ')}`);
    }
    
    // COUNTRIES ARRAY FILTER: Filter by Country column
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    if (args.countries && Array.isArray(args.countries) && args.countries.length > 0 && !excludeParams.includes('countries')) {
      const countryConditions = args.countries.map((_: string, idx: number) => `"Country" LIKE @p${paramIndex + idx}`);
      filters.push(`(${countryConditions.join(' OR ')})`);
      args.countries.forEach((country: string) => params.push(`%${country}%`));
      paramIndex += args.countries.length;
      console.log(`[Filter] Countries filter (Country column): ${args.countries.join(', ')}`);
    }
    
    // State Lookup range filter (BETWEEN) - for numeric state lookup values
    if (args.state_lookup_min !== undefined && !isNaN(Number(args.state_lookup_min))) {
      filters.push(`CAST(NULLIF("State", '') AS NUMERIC) >= @p${paramIndex}`);
      params.push(Number(args.state_lookup_min));
      paramIndex++;
    }
    if (args.state_lookup_max !== undefined && !isNaN(Number(args.state_lookup_max))) {
      filters.push(`CAST(NULLIF("State", '') AS NUMERIC) <= @p${paramIndex}`);
      params.push(Number(args.state_lookup_max));
      paramIndex++;
    }

    // Company filter (OPCO) - skip if already in template's WHERE clause
    // Also skip if the company value is part of the division name (false positive from LLM)
    // Example: "BCCI - Silicon Valley division" â†’ LLM extracts company="BCCI" but it's part of division name
    if (args.company && !excludeParams.includes('company') && !args._organization_override) {
      const companyLower = args.company.toLowerCase();
      const divisionLower = (args.division || '').toLowerCase();
      const isCompanyPartOfDivision = divisionLower.includes(companyLower);
      
      if (isCompanyPartOfDivision) {
        console.log(`[Filter] âš ï¸ Skipping Company filter "${args.company}" - it's part of division name "${args.division}"`);
      } else {
        filters.push(`"Company" LIKE @p${paramIndex}`);
        params.push(`%${args.company}%`);
        paramIndex++;
      }
    }

    // FINAL COMPANY CLEANUP: Remove ALL non-explicit categories/tags for known company queries
    // When user asks "list hill projects", we should NOT filter by category/tags unless explicit
    if (args.organization && args._organization_override) {
      const orgLower = args.organization.toLowerCase();
      const KNOWN_COMPANIES_FINAL = new Set(["ais", "gafcon", "gei", "hill", "liro", "palladium", "stobg"]);
      if (KNOWN_COMPANIES_FINAL.has(orgLower)) {
        // Remove ALL categories unless explicitly requested by user
        if (args.categories && !args._explicit_category) {
          console.log(`[Final Company Cleanup] Removing non-explicit categories for company query: ${JSON.stringify(args.categories)}`);
      
       // Also remove singular form
        }
        // Remove ALL tags unless explicitly requested by user
        if (args.tags && !args._explicit_tags) {
          console.log(`[Final Company Cleanup] Removing non-explicit tags for company query: ${JSON.stringify(args.tags)}`);
        }
      }
    }


    // Organization filter - searches across Client, Company, ProjectType, AND PointOfContact columns
    // Used when user mentions a company name without specifying if it's client or company
    // Example: "show projects for Google" â†’ searches all 4 columns with OR logic for maximum recall
    // Only apply if neither client nor company were explicitly set to avoid double-filtering
    if (args.organization && !excludeParams.includes('organization') &&
        ((!args.client && !args.company) || args._organization_override) && !args._organization_already_applied &&
        !args._title_already_applied) { // SKIP if title was set via disambiguation
      const orgValue = args.organization.trim();
      // Check if this is a known company - if so, only filter on Company column
      const KNOWN_COMPANY_NAMES = new Set(["ais", "gafcon", "gei", "hill", "liro", "palladium", "stobg", "jcm", "l.r. kimball", "lrkimball", "arc-tec", "schipporeit", "rwb", "rwbgroup", "deltek", "ims", "cbl", "cblarchitects", "blw"]);
      const isKnownCompany = KNOWN_COMPANY_NAMES.has(orgValue.toLowerCase());
      
      if (isKnownCompany) {
        // KNOWN COMPANY: Only filter on Company column for accurate results
        filters.push(`"Company" LIKE @p${paramIndex}`);
        params.push(`%${orgValue}%`);
        paramIndex += 1;
        console.log(`[Filter] Organization filter (Company ONLY - known company): ${orgValue}`);
      } else {
        // UNKNOWN ORG: Search across all columns for maximum recall
        filters.push(`("Client" LIKE @p${paramIndex} OR "Company" LIKE @p${paramIndex + 1} OR "ProjectType" LIKE @p${paramIndex + 2} OR "PointOfContact" LIKE @p${paramIndex + 3})`);
        params.push(`%${orgValue}%`, `%${orgValue}%`, `%${orgValue}%`, `%${orgValue}%`);
        paramIndex += 4;
        console.log(`[Filter] Organization filter (Client OR Company OR ProjectType OR POC): ${orgValue}`);
      }
    }

    // Division filter - organizational business unit
    // Uses flexible matching to handle missing punctuation (e.g., "LCC Healthcare" matches "LCC - Healthcare")
    if (args.division && !excludeParams.includes('division')) {
      filters.push(`"Division" LIKE @p${paramIndex}`);
      params.push(normalizeDivisionForFlexibleMatch(args.division));
      paramIndex++;
      console.log(`[Filter] Division filter (flexible): ${args.division}`);
    }
    
    // Divisions array filter - for multiple divisions
    if (args.divisions && Array.isArray(args.divisions) && args.divisions.length > 0 && !excludeParams.includes('divisions')) {
      const divisionConditions = args.divisions.map((_: string, idx: number) => `"Division" LIKE @p${paramIndex + idx}`);
      filters.push(`(${divisionConditions.join(' OR ')})`);
      args.divisions.forEach((div: string) => {
        params.push(normalizeDivisionForFlexibleMatch(div));
      });
      paramIndex += args.divisions.length;
      console.log(`[Filter] Divisions filter (flexible): ${args.divisions.join(', ')}`);
    }

    // Department filter - organizational department
    // Uses flexible matching to handle missing punctuation
    if (args.department && !excludeParams.includes('department')) {
      filters.push(`"Department" LIKE @p${paramIndex}`);
      params.push(normalizeDivisionForFlexibleMatch(args.department));
      paramIndex++;
      console.log(`[Filter] Department filter (flexible): ${args.department}`);
    }
    
    // Departments array filter - for multiple departments
    if (args.departments && Array.isArray(args.departments) && args.departments.length > 0 && !excludeParams.includes('departments')) {
      const deptConditions = args.departments.map((_: string, idx: number) => `"Department" LIKE @p${paramIndex + idx}`);
      filters.push(`(${deptConditions.join(' OR ')})`);
      args.departments.forEach((dept: string) => {
        params.push(normalizeDivisionForFlexibleMatch(dept));
      });
      paramIndex += args.departments.length;
      console.log(`[Filter] Departments filter (flexible): ${args.departments.join(', ')}`);
    }


    // Modules filter - for ModuleName column (Opportunities, Tracked Work, Construction)
    if (args.modules && Array.isArray(args.modules) && args.modules.length > 0 && !excludeParams.includes('modules')) {
      const moduleConditions = args.modules.map((_: string, idx: number) => `"ModuleName" LIKE @p${paramIndex + idx}`);
      filters.push(`(${moduleConditions.join(' OR ')})`);
      args.modules.forEach((mod: string) => {
        params.push(`%${mod}%`);
      });
      paramIndex += args.modules.length;
      console.log(`[Filter] Modules filter: ${args.modules.join(', ')}`);
    }
    // Client filter  - skip if already in template's WHERE clause
    // Also check if it's a person name and redirect to POC filter
    if (args.client && !excludeParams.includes('client')) {
      const clientValue = args.client.trim();
      
      // Check if it looks like a person name (2 words, both start with capital letters)
      // BUT NOT if it contains organization indicators or is a known organization pattern
      const twoWordPattern = /^[A-Za-z]+\s+[A-Za-z]+$/.test(clientValue);
      const orgIndicators = /\b(company|corp|corporation|inc|llc|ltd|group|authority|agency|district|foundation|hospital|airports?|university|college|school|transit|metro|mta|port|center|institute|department|office|service|board|commission|county|city|medical|health|children|bank|financial|insurance|associates|partners|consulting|solutions|systems|technologies|industries|international|national|regional|global)\b/i;
      const hasOrgIndicator = orgIndicators.test(clientValue);
      const hasThreeOrMoreWords = clientValue.split(/\s+/).length >= 3;
      
      // Only treat as person name if it's exactly 2 words AND doesn't have org indicators
      const looksLikePersonName = twoWordPattern && !hasOrgIndicator && !hasThreeOrMoreWords;
      
      if (looksLikePersonName) {
        // This is a person name - use POC filter instead of Client filter
        console.log(`[Filter] âš ï¸ AUTO-CORRECTING: "${clientValue}" is a person name, filtering by POC instead of Client`);
        filters.push(`"PointOfContact" LIKE @p${paramIndex}`);
        params.push(`%${clientValue}%`);
        paramIndex++;
        // Mark POC as already applied to avoid duplicate filter
        args._poc_already_applied = true;
      } else {
        filters.push(`"Client" LIKE @p${paramIndex}`);
        params.push(`%${args.client}%`);
        paramIndex++;
      }
    }

    // Project Type filter - skip if already in template's WHERE clause
    // IMPORTANT: For follow-up queries where the function changed (e.g., from get_projects_by_project_type 
    // to get_projects_by_combined_filters), we MUST add the project_type filter even if 
    // _project_type_already_applied is true, because the new template doesn't include it.
    // We simply apply the filter whenever project_type is set and not in excludeParams.
    // The excludeParams tells us if the current template already has the filter.
    const shouldApplyProjectTypeFilter = !excludeParams.includes('project_type');
    
    if (args.project_types && Array.isArray(args.project_types) && args.project_types.length > 0 && shouldApplyProjectTypeFilter) {
      // Multiple project types - use OR logic with LIKE for each
      const typeConditions = args.project_types.map((_: string, idx: number) => {
        return `"ProjectType" LIKE @p${paramIndex + idx}`;
      });
      filters.push(`(${typeConditions.join(' OR ')})`);
      args.project_types.forEach((type: string) => {
        params.push(`%${type}%`);
        paramIndex++;
      });
      console.log(`[Filter] Multiple Project Types: ${args.project_types.join(', ')}`);
    } else if (args.project_type && shouldApplyProjectTypeFilter) {
      filters.push(`"ProjectType" LIKE @p${paramIndex}`);
      params.push(`%${args.project_type}%`);
      paramIndex++;
      console.log(`[Filter] Single Project Type: ${args.project_type} (preserved from follow-up: ${!!args._project_type_already_applied})`);
    }

    // Point of Contact filter (POC) - skip if already in template's WHERE clause
    // Also skip if the POC value is a substring of the division name (false positive from LLM)
    // Example: "Hill - Saudi Arabia - Projects division" â†’ LLM extracts poc="Hill" but it's part of division name
    if (args.poc && !excludeParams.includes('poc') && !args._poc_already_applied) {
      const pocLower = args.poc.toLowerCase();
      const divisionLower = (args.division || '').toLowerCase();
      const isPocPartOfDivision = divisionLower.includes(pocLower);
      
      if (isPocPartOfDivision) {
        console.log(`[Filter] âš ï¸ Skipping POC filter "${args.poc}" - it's part of division name "${args.division}"`);
      } else {
        filters.push(`"PointOfContact" LIKE @p${paramIndex}`);
        params.push(`%${args.poc}%`);
        paramIndex++;
      }
    }

    
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    // FINAL ENTITY-CATEGORY CLEANUP: Last chance before category filter is applied




    // This ensures entity-keyword categories are removed regardless of earlier path
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

    const entitySignal = args.organization || args.client || args.company;

    if (entitySignal && (args.categories || args.category)) {

      const entLower = entitySignal.toLowerCase();
      const catKeyMap: Record<string, string[]> = {
        'Transportation': ['airport', 'airports', 'aviation', 'transit', 'railway', 'port'],
        'Healthcare': ['hospital', 'hospitals', 'medical', 'health', 'clinic'],
        'Education': ['school', 'schools', 'university', 'college', 'academy'],
        'Government': ['government', 'civic', 'municipal']
      };
      // Clean singular category
      if (args.category) {
        const kwds = catKeyMap[args.category] || [];
        if (kwds.some(k => entLower.includes(k))) {
          console.log(`[FinalCleanup] ğŸ§¹ Removing category="${args.category}" - conflicts with entity "${entitySignal}"`);
          delete args.category;
      
        }
      }
      // Clean categories array
      if (args.categories && Array.isArray(args.categories)) {
        const cleaned = args.categories.filter((c: string) => {
          const kwds = catKeyMap[c] || [];
          const hasKwd = kwds.some(k => entLower.includes(k));
          if (hasKwd) {
            console.log(`[FinalCleanup] ğŸ§¹ Removing category="${c}" from array - conflicts with entity "${entitySignal}"`);
            return false;
          }
          return true;
        });
        if (cleaned.length === 0) {
          delete args.categories;
      
        } else {
          args.categories = cleaned;
        }
      }
    }

    
    // ULTRA-SIMPLE ENTITY-CATEGORY CLEANUP: Direct check before category filter
    console.log(`[ULTRA_DEBUG] args.organization=${args.organization}, args.client=${args.client}, args.company=${args.company}`);
    // Add debug field visible in response
    const ultraEntity = args.organization || args.client || args.company;
    if (ultraEntity && typeof ultraEntity === "string") {
      const ue = ultraEntity.toLowerCase();
      const categoryPatterns: [RegExp, string][] = [
        [/airport|aviation/, "Transportation"],
        [/hospital|medical|health/, "Healthcare"],
        [/school|university|college/, "Education"],
        [/government|civic|municipal/, "Government"]
      ];
      for (const [pattern, cat] of categoryPatterns) {
        if (pattern.test(ue)) {
          if (args.category === cat) { delete args.category; }
          if (Array.isArray(args.categories)) {
            args.categories = args.categories.filter((c: string) => c !== cat);
            if (args.categories.length === 0) delete args.categories;
          }
        }
      }
    }

    // Category filter (singular) - applies to Request Category column
    // This is used when user explicitly says "request category" or "in the education sector"
    if (args.category && !args._category_already_applied) {
      filters.push(`"RequestCategory" LIKE @p${paramIndex}`);
      params.push(`%${args.category}%`);
      paramIndex++;
      console.log(`[Filter] Request Category filter: ${args.category}`);
    }
    
    // Categories filter (array) - applies to Request Category column
    if (args.categories && args.categories.length > 0 && !args._category_already_applied) {
      const categoryConditions = args.categories.map((c: string) => {
        const condition = `"RequestCategory" LIKE @p${paramIndex}`;
        params.push(`%${c}%`);
        paramIndex++;
        return condition;
      });
      filters.push(`(${categoryConditions.join(' OR ')})`);
      console.log(`[Filter] Request Categories filter: ${args.categories.join(', ')}`);
    }

    // Tags filter (array) - use OR logic: match if ANY tag matches
    // Tags filtering removed - column not in database

    // Fee range filters - check excludeParams to avoid duplicating template params
    // Use !== undefined && !== null to allow 0 values (0 is falsy but valid for "equal to 0" queries)
    if (args.min_fee !== undefined && args.min_fee !== null && !isNaN(Number(args.min_fee)) && !excludeParams.includes('min_fee')) {
      filters.push(`CAST(NULLIF("Fee", '') AS NUMERIC) >= @p${paramIndex}`);
      params.push(Number(args.min_fee));
      paramIndex++;
    }

    if (args.max_fee !== undefined && args.max_fee !== null && !isNaN(Number(args.max_fee)) && !excludeParams.includes('max_fee')) {
      filters.push(`CAST(NULLIF("Fee", '') AS NUMERIC) <= @p${paramIndex}`);
      params.push(Number(args.max_fee));
      paramIndex++;
    }

    // Win percentage filters (check for undefined/null, not falsy, to allow 0%)
    // Also check excludeParams - aggregation queries should only apply win filters in HAVING clause
    if (args.min_win !== undefined && args.min_win !== null && !isNaN(Number(args.min_win)) && !excludeParams.includes('min_win')) {
      filters.push(`CAST(NULLIF("ChanceOfSuccess", '') AS NUMERIC) >= @p${paramIndex}`);
      params.push(Number(args.min_win));
      paramIndex++;
    }

    if (args.max_win !== undefined && args.max_win !== null && !isNaN(Number(args.max_win)) && !excludeParams.includes('max_win')) {
      filters.push(`CAST(NULLIF("ChanceOfSuccess", '') AS NUMERIC) <= @p${paramIndex}`);
      params.push(Number(args.max_win));
      paramIndex++;
    }

    // Is Updated filter (column with values "0", "1", or "")
    if (args.is_updated !== undefined && args.is_updated !== null && args.is_updated !== '') {
      // Normalize to canonical values: "0" or "1"
      const normalized = String(args.is_updated).trim();
      if (normalized === '0' || normalized === '1') {
        filters.push(`"IsUpdated" = @p${paramIndex}`);
        params.push(normalized);
        paramIndex++;
      }
    }

    // Year filter: Filter by YEAR(TRY_CONVERT(DATE, "ConstStartDate")) = year
    // This is used when user asks "this year", "in 2024", etc.
    if (args.year !== undefined && args.year !== null && !isNaN(Number(args.year)) && !excludeParams.includes('year')) {
      filters.push(`YEAR(TRY_CONVERT(DATE, "ConstStartDate")) = @p${paramIndex}`);
      params.push(Number(args.year));
      paramIndex++;
      console.log(`[Filter] Year filter: ${args.year}`);
    }

    // Date range filter (only add if not already in main query)
    // Check if the query already has date parameters to avoid duplicates
    // Support open-ended ranges: empty string "" means no boundary on that side
    // SKIP date range if year filter is already applied (year is more precise for "this year" queries)
    const yearFilterApplied = args.year !== undefined && args.year !== null && !isNaN(Number(args.year)) && !excludeParams.includes('year');
    if (!args._date_already_applied && !yearFilterApplied) {
      const hasStartDate = args.start_date && args.start_date !== "";
      const hasEndDate = args.end_date && args.end_date !== "";
      
      if (hasStartDate && hasEndDate) {
        // Full date range
        filters.push(
          `TRY_CONVERT(DATE, "ConstStartDate") >= @p${paramIndex} AND TRY_CONVERT(DATE, "ConstStartDate") <= @p${paramIndex + 1}`
        );
        params.push(args.start_date, args.end_date);
        paramIndex += 2; // Fixed: was incorrectly += 4
      } else if (hasStartDate) {
        // Open-ended: "after X", "since X" - only start boundary
        filters.push(`TRY_CONVERT(DATE, "ConstStartDate") >= @p${paramIndex}`);
        params.push(args.start_date);
        paramIndex++;
      } else if (hasEndDate) {
        // Open-ended: "before X", "until X" - only end boundary
        filters.push(`TRY_CONVERT(DATE, "ConstStartDate") <= @p${paramIndex}`);
        params.push(args.end_date);
        paramIndex++;
      }
    }


    // City filter
    if (args.city && !excludeParams.includes('city')) {
      filters.push(`"City" LIKE @p${paramIndex}`);
      params.push(`%${args.city}%`);
      paramIndex++;
      console.log(`[Filter] City filter: ${args.city}`);
    }

    // Strategic project filter
    if (args.strategic !== undefined && !excludeParams.includes('strategic')) {
      const isStrategic = args.strategic === true || args.strategic === 'true' || args.strategic === 1;
      filters.push(`"IsStrategicProject" = @p${paramIndex}`);
      params.push(isStrategic ? 1 : 0);
      paramIndex++;
      console.log(`[Filter] Strategic project filter: ${isStrategic}`);
    }

    // Contract date filter
    if (args.contract_date && !excludeParams.includes('contract_date')) {
      filters.push(`TRY_CONVERT(DATE, "ContractDate") = @p${paramIndex}`);
      params.push(args.contract_date);
      paramIndex++;
      console.log(`[Filter] Contract date filter: ${args.contract_date}`);
    }

    // Module name filter (single value)
    if (args.module && !excludeParams.includes('module')) {
      filters.push(`"ModuleName" LIKE @p${paramIndex}`);
      params.push(`%${args.module}%`);
      paramIndex++;
      console.log(`[Filter] Module filter: ${args.module}`);
    }
    // Return SQL fragment
    return {
      sql: filters.length > 0 ? `AND ${filters.join(" AND ")}` : "",
      nextIndex: paramIndex,
    };
  }

  private buildSql(sql: string, args: Record<string, any>, params: any[], startIndex: number = 0, excludeParams: string[] = []): string {
    let result = sql;
    let paramIndex = startIndex + 1;

    // Handle date filter - supports open-ended ranges with empty string ""
    if (result.includes("{date_filter}")) {
      // CRITICAL FIX: Check for year filter FIRST (from "this year" / "current year" detection)
      // Use YEAR() = year instead of date ranges for cleaner SQL
      const hasYearFilter = args.year !== undefined && args.year !== null && !isNaN(Number(args.year));
      const hasStartDate = args.start_date && args.start_date !== "";
      const hasEndDate = args.end_date && args.end_date !== "";
      
      if (hasYearFilter) {
        // Use YEAR() function for "this year" / "current year" queries
        console.log(`[buildSql] ğŸ“… Using YEAR filter: YEAR(ConstStartDate) = ${args.year}`);
        result = result.replace(
          "{date_filter}",
          `AND YEAR(TRY_CONVERT(DATE, "ConstStartDate")) = @p${paramIndex}`
        );
        params.push(Number(args.year));
        paramIndex++;
        args._date_already_applied = true;
      } else if (hasStartDate && hasEndDate) {
        // Full date range
        result = result.replace(
          "{date_filter}",
          `AND TRY_CONVERT(DATE, "ConstStartDate") >= @p${paramIndex} AND TRY_CONVERT(DATE, "ConstStartDate") <= @p${paramIndex + 1}`
        );
        params.push(args.start_date, args.end_date);
        paramIndex += 4;
        args._date_already_applied = true;
      } else if (hasStartDate) {
        // Open-ended: "after X", "since X" - only start boundary
        result = result.replace(
          "{date_filter}",
          `AND TRY_CONVERT(DATE, "ConstStartDate") >= @p${paramIndex}`
        );
        params.push(args.start_date);
        paramIndex++;
        args._date_already_applied = true;
      } else if (hasEndDate) {
        // Open-ended: "before X", "until X" - only end boundary
        result = result.replace(
          "{date_filter}",
          `AND TRY_CONVERT(DATE, "ConstStartDate") <= @p${paramIndex}`
        );
        params.push(args.end_date);
        paramIndex++;
        args._date_already_applied = true;
      } else {
        result = result.replace("{date_filter}", "");
      }
    }

    // Handle separate start_date and end_date filters
    if (result.includes("{start_date_filter}")) {
      if (args.start_date) {
        result = result.replace(
          "{start_date_filter}",
          `AND TRY_CONVERT(DATE, "ConstStartDate") >= @p${paramIndex}`
        );
        params.push(args.start_date);
        paramIndex++;
      } else {
        result = result.replace("{start_date_filter}", "");
      }
    }

    if (result.includes("{end_date_filter}")) {
      if (args.end_date) {
        result = result.replace(
          "{end_date_filter}",
          `AND TRY_CONVERT(DATE, "ConstStartDate") <= @p${paramIndex}`
        );
        params.push(args.end_date);
        paramIndex++;
        args._date_already_applied = true; // Mark dates as applied to avoid duplication
      } else {
        result = result.replace("{end_date_filter}", "");
      }
    }

    // Handle win_rate_filter for min/max win percentage (for get_projects_by_status_and_win_rate)
    if (result.includes("{win_rate_filter}")) {
      const winConditions: string[] = [];
      
      if (args.min_win !== undefined && args.min_win !== null && !isNaN(Number(args.min_win))) {
        winConditions.push(`CAST(NULLIF("ChanceOfSuccess", '') AS NUMERIC) >= @p${paramIndex}`);
        params.push(Number(args.min_win));
        paramIndex++;
        console.log(`[Win Rate Filter] min_win >= ${args.min_win}`);
      }
      
      if (args.max_win !== undefined && args.max_win !== null && !isNaN(Number(args.max_win))) {
        winConditions.push(`CAST(NULLIF("ChanceOfSuccess", '') AS NUMERIC) < @p${paramIndex}`);
        params.push(Number(args.max_win));
        paramIndex++;
        console.log(`[Win Rate Filter] max_win < ${args.max_win}`);
      }
      
      if (winConditions.length > 0) {
        result = result.replace("{win_rate_filter}", `AND ${winConditions.join(' AND ')}`);
      } else {
        result = result.replace("{win_rate_filter}", "");
      }
    }

    // Handle year_filter for year-over-year comparison queries
    if (result.includes("{year_filter}")) {
      // If all_years is true, show all years without filtering
      if (args.all_years === true || args.all_years === 'true') {
        result = result.replace("{year_filter}", "");
      } else if (args.year1 && args.year2) {
        // Both years provided
        result = result.replace(
          "{year_filter}",
          `AND YEAR(TRY_CONVERT(DATE, "ConstStartDate")) IN (@p${paramIndex}, @p${paramIndex + 1})`
        );
        params.push(args.year1, args.year2);
        paramIndex += 4;
      } else if (args.year2) {
        // Only year2 provided - compare to previous year
        const year1 = args.year2 - 1;
        result = result.replace(
          "{year_filter}",
          `AND YEAR(TRY_CONVERT(DATE, "ConstStartDate")) IN (@p${paramIndex}, @p${paramIndex + 1})`
        );
        params.push(year1, args.year2);
        paramIndex += 4;
      } else if (args.year1) {
        // Only year1 provided - compare to next year
        const year2 = args.year1 + 1;
        result = result.replace(
          "{year_filter}",
          `AND YEAR(TRY_CONVERT(DATE, "ConstStartDate")) IN (@p${paramIndex}, @p${paramIndex + 1})`
        );
        params.push(args.year1, year2);
        paramIndex += 4;
      } else {
        // No years specified - show ALL years (don't limit to just 2)
        result = result.replace("{year_filter}", "");
      }
    }

    // Handle growth_filter for filtering increases/decreases
    if (result.includes("{growth_filter}")) {
      if (args.show_only_increases === true || args.show_only_increases === 'true') {
        result = result.replace("{growth_filter}", "AND (project_count - prev_year_count) > 0");
      } else if (args.show_only_decreases === true || args.show_only_decreases === 'true') {
        result = result.replace("{growth_filter}", "AND (project_count - prev_year_count) < 0");
      } else {
        result = result.replace("{growth_filter}", "");
      }
    }

    // Handle having_clause for filtering aggregated results
    if (result.includes("{having_clause}")) {
      const havingConditions: string[] = [];
      
      // Filter by minimum project count
      if (args.min_project_count) {
        havingConditions.push(`COUNT(*) >= @p${paramIndex}`);
        params.push(args.min_project_count);
        paramIndex++;
      }
      
      // Filter by minimum average win rate
      if (args.min_win !== undefined && args.min_win !== null) {
        havingConditions.push(`AVG(CAST(NULLIF("ChanceOfSuccess", '') AS NUMERIC)) >= @p${paramIndex}`);
        params.push(Number(args.min_win));
        paramIndex++;
      }
      
      // Filter by maximum average win rate
      if (args.max_win !== undefined && args.max_win !== null) {
        havingConditions.push(`AVG(CAST(NULLIF("ChanceOfSuccess", '') AS NUMERIC)) <= @p${paramIndex}`);
        params.push(Number(args.max_win));
        paramIndex++;
      }
      
      if (havingConditions.length > 0) {
        result = result.replace("{having_clause}", `HAVING ${havingConditions.join(" AND ")}`);
      } else {
        result = result.replace("{having_clause}", "");
      }
    }

    // Handle order_by_clause for different query types
    if (result.includes("{order_by_clause}")) {
      // Check if this is a chronological query (sort_field=start_date)
      if (args.sort_field === "start_date") {
        const direction = args.sort_direction === "DESC" ? "DESC" : "ASC"; // Default to ASC for oldest/first
        result = result.replace("{order_by_clause}", `ORDER BY "ConstStartDate" ${direction}`);
        console.log(`[QueryEngine] Chronological sorting: Start Date ${direction}`);
      } else if (args.sort_by === "won_count") {
        // Aggregation query sorted by won count (for "which client won most projects")
        result = result.replace("{order_by_clause}", "ORDER BY won_count DESC, project_count DESC");
        console.log(`[QueryEngine] Sorting by won_count DESC`);
      } else if (args.sort_by === "project_count") {
        // Aggregation query sorted by count
        result = result.replace("{order_by_clause}", "ORDER BY project_count DESC, total_value DESC");
      } else if (args.sort_by === "total_value") {
        // Aggregation query sorted by total value
        result = result.replace("{order_by_clause}", "ORDER BY total_value DESC");
      } else {
        // Default: sort by Fee DESC (highest first) for non-aggregation queries
        // Check if result contains aggregation columns (project_count, total_value)
        if (result.includes("total_value") || result.includes("project_count")) {
          result = result.replace("{order_by_clause}", "ORDER BY total_value DESC");
        } else {
          result = result.replace("{order_by_clause}", "ORDER BY CAST(NULLIF(\"Fee\", '') AS NUMERIC) DESC");
        }
      }
    }

    // Handle sort_direction for fee queries - "last X" = ASC (lowest), default = DESC (highest)
    if (result.includes("{sort_direction}")) {
      const direction = args.sort_direction === "ASC" ? "ASC" : "DESC";
      result = result.replace("{sort_direction}", direction);
    }

    // Handle POC condition - supports single poc or multiple pocs array
    if (result.includes("{poc_condition}")) {
      if (args.pocs && Array.isArray(args.pocs) && args.pocs.length > 0) {
        // Multiple POCs - use OR logic with LIKE for each
        const pocConditions = args.pocs.map((_: string, idx: number) => {
          return `"PointOfContact" LIKE @p${paramIndex + idx}`;
        });
        result = result.replace("{poc_condition}", `(${pocConditions.join(' OR ')})`);
        args.pocs.forEach((poc: string) => {
          params.push(`%${poc}%`);
          paramIndex++;
        });
        args._poc_already_applied = true;
        console.log(`[POC Condition] Multiple POCs: ${args.pocs.join(', ')}`);
      } else if (args.poc) {
        // Single POC
        result = result.replace("{poc_condition}", `"PointOfContact" LIKE @p${paramIndex}`);
        params.push(`%${args.poc}%`);
        paramIndex++;
        args._poc_already_applied = true;
        console.log(`[POC Condition] Single POC: ${args.poc}`);
      } else {
        // No POC specified - match all (shouldn't happen normally)
        result = result.replace("{poc_condition}", "1=1");
        console.log(`[POC Condition] No POC specified, matching all`);
      }
    }

    // Handle project type condition - supports single or multiple project types
    if (result.includes("{project_type_condition}")) {
      if (args.project_types && Array.isArray(args.project_types) && args.project_types.length > 0) {
        // Multiple project types - use OR logic with LIKE for each
        const typeConditions = args.project_types.map((_: string, idx: number) => {
          return `"ProjectType" LIKE @p${paramIndex + idx}`;
        });
        result = result.replace("{project_type_condition}", `(${typeConditions.join(' OR ')})`);
        args.project_types.forEach((type: string) => {
          params.push(`%${type}%`);
          paramIndex++;
        });
        args._project_type_already_applied = true;
        console.log(`[Project Type Condition] Multiple types: ${args.project_types.join(', ')}`);
      } else if (args.project_type) {
        // Single project type
        result = result.replace("{project_type_condition}", `"ProjectType" LIKE @p${paramIndex}`);
        params.push(`%${args.project_type}%`);
        paramIndex++;
        args._project_type_already_applied = true;
        console.log(`[Project Type Condition] Single type: ${args.project_type}`);
      } else {
        // No project type specified - match all (shouldn't happen normally)
        result = result.replace("{project_type_condition}", "1=1");
        console.log(`[Project Type Condition] No type specified, matching all`);
      }
    }
    
    // Handle service type condition - for querying by ServiceType column
    if (result.includes("{service_type_condition}")) {
      if (args.service_type) {
        // DISAMBIGUATION FIX: Use stored original value if available
        let serviceTypeValue = args.service_type;
        
        // Check if we have a stored disambiguation value (set during EARLY MERGE)
        if (args._service_type_original_value) {
          console.log(`[Service Type] Using stored disambiguation value: "${args._service_type_original_value}" (LLM had: "${args.service_type}")`);
          serviceTypeValue = args._service_type_original_value;
        } else {
          console.log(`[Service Type] Using LLM value: "${args.service_type}"`);
        }
        
        // Build SQL condition
        result = result.replace("{service_type_condition}", `"ServiceType" LIKE @p${paramIndex}`);
        // FLEXIBLE WHITESPACE: Handle variations like "waste water" vs "wastewater"
        let wildcardValue: string;
        if (serviceTypeValue.startsWith('%')) {
          wildcardValue = serviceTypeValue;
        } else if (serviceTypeValue.includes(' ')) {
          const noSpaces = serviceTypeValue.replace(/\s+/g, '');
          wildcardValue = `%${noSpaces}%`;
          console.log(`[FlexibleMatch] service_type: "${serviceTypeValue}" â†’ LIKE "${wildcardValue}"`);
        } else {
          wildcardValue = `%${serviceTypeValue}%`;
        }
        params.push(wildcardValue);
        paramIndex++;
        args._service_type_already_applied = true;
        console.log(`[Service Type Condition] Service type: ${args.service_type}`);
      } else {
        // No service type specified - match all (shouldn't happen normally)
        result = result.replace("{service_type_condition}", "1=1");
        console.log(`[Service Type Condition] No service type specified, matching all`);
      }
    }
    
    // Handle smart category/type condition - checks which column to use based on cached values
    // This is used when we need to detect if a value is a Project Type vs Request Category
    if (result.includes("{category_or_type_condition}")) {
      console.log(`[CATDEBUG] At category_or_type_condition: args.category="${args.category}", args.categories="${args.categories}"`);
      const categoryValue = args.category;
      if (categoryValue) {
        // Check if this value exists in Project Type cache (more specific)
        const isProjectType = this.projectTypeCache?.some(
          pt => pt.toLowerCase() === categoryValue.toLowerCase()
        );
        
        if (isProjectType) {
          // Use Project Type column only
          result = result.replace("{category_or_type_condition}", `"ProjectType" LIKE @p${paramIndex}`);
          console.log(`[Smart Category] "${categoryValue}" found in Project Type - using Project Type column only`);
        } else {
          // Use Request Category column only
          result = result.replace("{category_or_type_condition}", `"RequestCategory" LIKE @p${paramIndex}`);
          console.log(`[Smart Category] "${categoryValue}" using Request Category column`);
        }
        // FLEXIBLE WHITESPACE: Handle "waste water" vs "wastewater" variations
        if (categoryValue.includes(' ')) {
          const noSpaces = categoryValue.replace(/\s+/g, '');
          params.push(`%${noSpaces}%`);
          console.log(`[FlexibleMatch] category: "${categoryValue}" â†’ LIKE "%${noSpaces}%"`);
        } else {
          params.push(`%${categoryValue}%`);
        }
        paramIndex++;
        args._category_already_applied = true;
      } else {
        // No category specified - match all
        result = result.replace("{category_or_type_condition}", "1=1");
        console.log(`[Smart Category] No category specified, matching all`);
      }
    }

    // Handle limit clause with optional offset (MS SQL syntax)
    // MS SQL uses OFFSET ... FETCH NEXT ... instead of LIMIT
    if (result.includes("{limit_clause}")) {
      if (args.limit) {
        const offset = args.offset || 0;
        // MS SQL requires ORDER BY for OFFSET/FETCH - if not present, add a default
        if (!result.toUpperCase().includes('ORDER BY')) {
          result = result.replace("{limit_clause}", `ORDER BY (SELECT NULL) OFFSET ${offset} ROWS FETCH NEXT ${args.limit} ROWS ONLY`);
        } else {
          result = result.replace("{limit_clause}", `OFFSET ${offset} ROWS FETCH NEXT ${args.limit} ROWS ONLY`);
        }
      } else {
        result = result.replace("{limit_clause}", "");
      }
    }

    // Handle extremes_limit for fee outliers query (used in get_fee_extremes)
    // This replaces {extremes_limit} with the number of top/bottom projects to return
    if (result.includes("{extremes_limit}")) {
      const extremesLimit = args.limit || 3; // Default to 3 highest and 3 lowest
      result = result.replace(/{extremes_limit}/g, extremesLimit.toString());
    }

    // Handle sort direction (ASC for "bottom", DESC for "top")
    if (result.includes("{sort_direction}")) {
      const sortDir = args.sort_direction?.toUpperCase() === 'ASC' ? 'ASC' : 'DESC';
      result = result.replace("{sort_direction}", sortDir);
    }

    // Handle size condition
    if (result.includes("{size_condition}")) {
      const sizeCase = this.sizeCalculator.getSqlCaseStatement();
      // Use $1 since 'size' is the first (and only) required param for get_projects_by_size
      result = result.replace("{size_condition}", `(${sizeCase}) = @p1`);
    }

    // Handle size case
    if (result.includes("{size_case}")) {
      const sizeCase = this.sizeCalculator.getSqlCaseStatement();
      result = result.replace("{size_case}", sizeCase);
    }

    // Handle combined filters
    if (result.includes("{filters}")) {
      const filters: string[] = [];

      // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
      // DIRECTIONAL DIVISION TO REGION CONVERSION (before any division filtering)
      // If user says "southeast division" or "in the west", convert to Region column filter
      // The database has a Region column, so we should use it directly instead of expanding to states
      // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
      const directionalTerms = [
        'southeast', 'southeastern', 'northeast', 'northeastern',
        'midwest', 'midwestern', 'southwest', 'southwestern',
        'northwest', 'northwestern', 'west', 'western',
        'south', 'southern', 'north', 'northern', 'east', 'eastern'
      ];
      
      if (args.division && typeof args.division === 'string') {
        const divisionLower = args.division.toLowerCase().trim();
        
        if (directionalTerms.includes(divisionLower)) {
          console.log(`[Filter] ğŸ§­ DIRECTIONAL â†’ REGION: "${args.division}" â†’ Region column filter`);
          
          // Remove division filter, add to regions instead
          const regionValue = args.division;
          delete args.division;
          if (args.divisions) {
            args.divisions = args.divisions.filter((d: string) => !directionalTerms.includes(d.toLowerCase().trim()));
            if (args.divisions.length === 0) delete args.divisions;
          }
          
          // Add to regions array for Region column filtering
          const existingRegions = Array.isArray(args.regions) ? args.regions : (args.region ? [args.region] : []);
          args.regions = Array.from(new Set([...existingRegions, regionValue]));
          delete args.region;
        }
      }
      
      // Also check divisions array for directional terms
      if (args.divisions && Array.isArray(args.divisions)) {
        let additionalRegions: string[] = [];
        args.divisions = args.divisions.filter((div: string) => {
          const divLower = div.toLowerCase().trim();
          if (directionalTerms.includes(divLower)) {
            additionalRegions.push(div);
            console.log(`[Filter] ğŸ§­ Removing directional "${div}" from divisions, adding to regions`);
            return false;
          }
          return true;
        });
        
        if (additionalRegions.length > 0) {
          const existingRegions = Array.isArray(args.regions) ? args.regions : (args.region ? [args.region] : []);
          args.regions = Array.from(new Set([...existingRegions, ...additionalRegions]));
          delete args.region;
        }
        
        if (args.divisions.length === 0) delete args.divisions;
      }

      if (args.size) {
        // Normalize size synonyms to canonical values
        const normalizeSizeValue = (size: string): string => {
          const lowerSize = size.toLowerCase().trim();
          const sizeMap: Record<string, string> = {
            // Mega synonyms
            'mega': 'Mega', 'huge': 'Mega', 'massive': 'Mega', 'giant': 'Mega', 'biggest': 'Mega', 'largest': 'Mega',
            // Large synonyms
            'large': 'Large', 'big': 'Large', 'major': 'Large',
            // Medium synonyms
            'medium': 'Medium', 'mid-sized': 'Medium', 'moderate': 'Medium', 'mid': 'Medium',
            // Small synonyms
            'small': 'Small', 'minor': 'Small', 'little': 'Small',
            // Micro synonyms
            'micro': 'Micro', 'tiny': 'Micro', 'smallest': 'Micro'
          };
          return sizeMap[lowerSize] || size; // Return original if not found
        };
        
        const sizeCase = this.sizeCalculator.getSqlCaseStatement();
        
        // Handle both array format and comma-separated string format
        const isArray = Array.isArray(args.size);
        const isCommaSeparatedString = typeof args.size === 'string' && 
                                      (args.size.includes(',') || args.size.toLowerCase().includes(' and '));
        
        if (isArray) {
          // AI returned array: ["Small", "Medium"] - normalize each value
          const normalizedSizes = args.size.map((s: string) => normalizeSizeValue(s));
          filters.push(`(${sizeCase}) IN (SELECT value FROM STRING_SPLIT(@p${paramIndex}, ','))`);
          params.push(normalizedSizes.join(','));
          paramIndex++;
        } else if (isCommaSeparatedString) {
          // AI returned comma-separated string: "Small, Medium" or "Small and Medium"
          const sizes = args.size
            .split(/,|\s+and\s+/i)
            .map((s: string) => normalizeSizeValue(s.trim()))
            .filter((s: string) => s.length > 0);
          
          filters.push(`(${sizeCase}) IN (SELECT value FROM STRING_SPLIT(@p${paramIndex}, ','))`);
          params.push(sizes.join(','));
          paramIndex++;
        } else {
          // Single size value - normalize it
          const normalizedSize = normalizeSizeValue(args.size.toString());
          filters.push(`(${sizeCase}) = @p${paramIndex}`);
          params.push(normalizedSize);
          paramIndex++;
        }
      }

      if (args.status) {
        // STATUS EXPANSION: Convert "open"/"closed" strings to correct status arrays
        const OPEN_STATUSES_FILTER = ["Proposal Development", "Qualified Lead", "Submitted", "Won", "Lead", "In Progress", "Hold"];
        const CLOSED_STATUSES_FILTER = ["Lost", "No Go", "Cancelled"];
        
        let statusValue = args.status;
        if (typeof statusValue === 'string') {
          const statusLower = statusValue.toLowerCase();
          if (statusLower === 'open' || statusLower === 'active' || statusLower === 'ongoing' || statusLower === 'current') {
            console.log(`[Filter] STATUS EXPANSION in {filters}: "${statusValue}" â†’ all open statuses`);
            statusValue = OPEN_STATUSES_FILTER;
          } else if (statusLower === 'closed' || statusLower === 'completed' || statusLower === 'finished') {
            console.log(`[Filter] STATUS EXPANSION in {filters}: "${statusValue}" â†’ all closed statuses`);
            statusValue = CLOSED_STATUSES_FILTER;
          }
        }
        
        if (Array.isArray(statusValue) && statusValue.length > 0) {
          // Handle multiple status values: (status LIKE val1 OR status LIKE val2)
          const statusConditions = statusValue.map((status: string) => {
            const condition = `"StatusChoice" LIKE @p${paramIndex}`;
            params.push(`%${status}%`);
            paramIndex++;
            return condition;
          });
          filters.push(`(${statusConditions.join(' OR ')})`);
        } else if (!Array.isArray(statusValue)) {
          // Single status value (non-array string)
          filters.push(`"StatusChoice" LIKE @p${paramIndex}`);
          params.push(`%${statusValue}%`);
          paramIndex++;
        }
        // else: empty array - skip status filter
      }

      // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
      // ENTITY-CATEGORY CLEANUP FOR {filters}: Remove category if entity name contains it
      // Prevents "DFW Airport" from filtering by Client AND RequestCategory="Transportation"
      // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
      const entityForCatCleanup = args.organization || args.client || args.company;
      if (entityForCatCleanup && typeof entityForCatCleanup === "string") {
        const entLower = entityForCatCleanup.toLowerCase();
        const catPatterns: [RegExp, string][] = [
          [/airport|aviation|transit|port|railway/, "Transportation"],
          [/hospital|medical|health|clinic|healthcare/, "Healthcare"],
          [/school|university|college|education/, "Education"],
          [/government|civic|municipal|city|county/, "Government"]
        ];
        for (const [pattern, catName] of catPatterns) {
          if (pattern.test(entLower)) {
            if (Array.isArray(args.categories)) {
              const before = args.categories.length;
              args.categories = args.categories.filter((c: string) => c !== catName);
              if (args.categories.length < before) {
                console.log(`[Filter] ğŸ§¹ ENTITY-CATEGORY CLEANUP in {filters}: Removed "${catName}" from categories (entity="${entityForCatCleanup}")`);
              }
              if (args.categories.length === 0) delete args.categories;
            }
            if (args.category === catName) {
              console.log(`[Filter] ğŸ§¹ ENTITY-CATEGORY CLEANUP in {filters}: Removed category="${catName}" (entity="${entityForCatCleanup}")`);
              delete args.category;
            }
          }
        }
      }

      if (args.categories && args.categories.length > 0) {
        const categoryConditions = args.categories.map((c: string) => {
          const condition = `"RequestCategory" LIKE @p${paramIndex}`;
          params.push(`%${c}%`);
          paramIndex++;
          return condition;
        });
        filters.push(`(${categoryConditions.join(' OR ')})`);
      }

      // Exclude categories (for "NOT in Healthcare", "except Transportation", etc.)
      if (args.exclude_categories && args.exclude_categories.length > 0) {
        const excludeConditions = args.exclude_categories.map((c: string) => {
          const condition = `"RequestCategory" NOT LIKE @p${paramIndex}`;
          params.push(`%${c}%`);
          paramIndex++;
          return condition;
        });
        filters.push(`(${excludeConditions.join(' AND ')})`);
      }

      // Tags filtering removed - column not in database

      // Exclude tags (for "NOT tagged with X", "except tag Y", etc.)
      // Exclude tags filtering removed - column not in database

      // Title filter - case-insensitive LIKE match for project title
      if (args.title) {
        filters.push(`"Title" LIKE @p${paramIndex}`);
        params.push(`%${args.title}%`);
        paramIndex++;
        console.log(`[Filter] Title filter in {filters}: ${args.title}`);
      }

      if (args.client) {
        filters.push(`"Client" LIKE @p${paramIndex}`);
        params.push(`%${args.client}%`);
        paramIndex++;
      }

      // POC filter - skip if POC value is part of division name (false positive from LLM)
      if (args.poc && !args._poc_already_applied) {
        const pocLower = args.poc.toLowerCase();
        const divisionLower = (args.division || '').toLowerCase();
        const isPocPartOfDivision = divisionLower.includes(pocLower);
        
        if (isPocPartOfDivision) {
          console.log(`[Filter] âš ï¸ Skipping POC filter "${args.poc}" in {filters} - it's part of division name "${args.division}"`);
        } else {
          filters.push(`"PointOfContact" LIKE @p${paramIndex}`);
          params.push(`%${args.poc}%`);
          paramIndex++;
        }
      }

      // Company filter - skip if company value is part of division name (false positive from LLM)
      if (args.company && !args._organization_override) {
        const companyLower = args.company.toLowerCase();
        const divisionLower = (args.division || '').toLowerCase();
        const isCompanyPartOfDivision = divisionLower.includes(companyLower);
        
        if (isCompanyPartOfDivision) {
          console.log(`[Filter] âš ï¸ Skipping Company filter "${args.company}" in {filters} - it's part of division name "${args.division}"`);
        } else {
          filters.push(`"Company" LIKE @p${paramIndex}`);
          params.push(`%${args.company}%`);
          paramIndex++;
        }
      }


      // Organization filter - searches across Client, Company, ProjectType, AND PointOfContact columns
      // Used when _organization_override is set (company was converted to organization for 4-column search)
      if (args.organization && args._organization_override && !args._organization_already_applied &&
          !args._title_already_applied) { // SKIP if title was set via disambiguation
        const orgValue = args.organization.trim();
        // Check if this is a known company - if so, only filter on Company column
        const KNOWN_COMPANY_NAMES_2 = new Set(["ais", "gafcon", "gei", "hill", "liro", "palladium", "stobg", "jcm", "l.r. kimball", "lrkimball", "arc-tec", "schipporeit", "rwb", "rwbgroup", "deltek", "ims", "cbl", "cblarchitects", "blw"]);
        const isKnownCompany2 = KNOWN_COMPANY_NAMES_2.has(orgValue.toLowerCase());
        
        if (isKnownCompany2) {
          // KNOWN COMPANY: Only filter on Company column for accurate results
          filters.push(`"Company" LIKE @p${paramIndex}`);
          params.push(`%${orgValue}%`);
          paramIndex += 1;
          console.log(`[Filter] Organization filter in {filters} (Company ONLY - known company): ${orgValue}`);
        } else {
          // UNKNOWN ORG: Search across all columns for maximum recall
          filters.push(`("Client" LIKE @p${paramIndex} OR "Company" LIKE @p${paramIndex + 1} OR "ProjectType" LIKE @p${paramIndex + 2} OR "PointOfContact" LIKE @p${paramIndex + 3})`);
          params.push(`%${orgValue}%`, `%${orgValue}%`, `%${orgValue}%`, `%${orgValue}%`);
          paramIndex += 4;
          console.log(`[Filter] Organization filter in {filters} (Client OR Company OR ProjectType OR POC): ${orgValue}`);
        }
      }
      // Division filter - organizational business unit
      // Use normalizeDivisionForFlexibleMatch for flexible matching:
      // "UK Domestic" â†’ "%UK%Domestic%" â†’ matches "UK - Domestic"
      if (args.division) {
        filters.push(`"Division" LIKE @p${paramIndex}`);
        params.push(normalizeDivisionForFlexibleMatch(args.division));
        paramIndex++;
        console.log(`[Filter] Division filter in {filters} (flexible): ${args.division}`);
      }
      
      // Divisions array filter - for multiple divisions
      if (args.divisions && Array.isArray(args.divisions) && args.divisions.length > 0) {
        const divisionConditions = args.divisions.map((_: string, idx: number) => `"Division" LIKE @p${paramIndex + idx}`);
        filters.push(`(${divisionConditions.join(' OR ')})`);
        args.divisions.forEach((div: string) => {
          params.push(normalizeDivisionForFlexibleMatch(div));
        });
        paramIndex += args.divisions.length;
        console.log(`[Filter] Divisions filter in {filters} (flexible): ${args.divisions.join(', ')}`);
      }

      // Department filter - organizational department
      // Use normalizeDivisionForFlexibleMatch for flexible matching
      if (args.department) {
        filters.push(`"Department" LIKE @p${paramIndex}`);
        params.push(normalizeDivisionForFlexibleMatch(args.department));
        paramIndex++;
        console.log(`[Filter] Department filter in {filters} (flexible): ${args.department}`);
      }
      
      // Departments array filter - for multiple departments
      if (args.departments && Array.isArray(args.departments) && args.departments.length > 0) {
        const deptConditions = args.departments.map((_: string, idx: number) => `"Department" LIKE @p${paramIndex + idx}`);
        filters.push(`(${deptConditions.join(' OR ')})`);
        args.departments.forEach((dept: string) => {
          params.push(normalizeDivisionForFlexibleMatch(dept));
        });
        paramIndex += args.departments.length;
        console.log(`[Filter] Departments filter in {filters} (flexible): ${args.departments.join(', ')}`);
      }

      // Closed filter - filter on the Closed column (boolean 'true'/'false')
      // Used when user asks for "closed projects" - filters on Closed='true'
      if (args.is_closed === true || args.is_closed === 'true') {
        filters.push(`"Closed" = 'true'`);
        console.log(`[Filter] Closed filter in {filters}: Closed = 'true'`);
      } else if (args.is_closed === false || args.is_closed === 'false') {
        filters.push(`"Closed" = 'false'`);
        console.log(`[Filter] Closed filter in {filters}: Closed = 'false'`);
      }

      // State/Location filter - case-insensitive match (single state)
      // SKIP state filtering if organization is present - state is likely just context (e.g., "DFW Airport (Dallas, TX)")
      const skipStateForOrg = args.organization && typeof args.organization === 'string' && args.organization.length > 0;
      if (args.state_code && !args.states && !args.state_lookup_min && !args.state_lookup_max && !skipStateForOrg) {
        filters.push(`"State" LIKE @p${paramIndex}`);
        params.push(`%${args.state_code}%`);
        paramIndex++;
      } else if (skipStateForOrg && args.state_code) {
        console.log(`[Filter] â­ï¸ SKIPPING state_code="${args.state_code}" - organization filter present ("${args.organization}")`);
        delete args.state_code;
      }
      
      // States array filter - for region queries (multiple states)
      // Use case-insensitive matching with LIKE for each state
      // SKIP states filtering if organization is present - state is likely just context
      if (args.states && Array.isArray(args.states) && args.states.length > 0 && !(args.regions && Array.isArray(args.regions) && args.regions.length > 0) && !skipStateForOrg) {
        const stateConditions = args.states.map((_: string, idx: number) => `"State" LIKE @p${paramIndex + idx}`);
        filters.push(`(${stateConditions.join(' OR ')})`);
        args.states.forEach((state: string) => params.push(state));
        paramIndex += args.states.length;
        console.log(`[Filter] Region/States filter: ${args.states.length} states (case-insensitive)`);
      } else if (skipStateForOrg && args.states && Array.isArray(args.states) && args.states.length > 0) {
        console.log(`[Filter] â­ï¸ SKIPPING states=[${args.states.join(', ')}] - organization filter present`);
        delete args.states;
      }
      
      // EXCLUDE States array filter - for "except [region]" queries
      // Uses NOT LIKE to exclude the specified states
      if (args.exclude_states && Array.isArray(args.exclude_states) && args.exclude_states.length > 0) {
        const excludeStateConditions = args.exclude_states.map((_: string, idx: number) => `"State" NOT LIKE @p${paramIndex + idx}`);
        filters.push(`(${excludeStateConditions.join(' AND ')})`);
        args.exclude_states.forEach((state: string) => params.push(state));
        paramIndex += args.exclude_states.length;
        console.log(`[Filter] EXCLUDING Region/States filter in {filters}: ${args.exclude_states.length} states (NOT LIKE)`);
      }
      
      // Region filter - query Region column directly for ALL regions
      if (args.region) {
        filters.push(`"Region" LIKE @p${paramIndex}`);
        params.push(`%${args.region}%`);
        paramIndex++;
        console.log(`[Filter] Region column filter in {filters}: ${args.region}`);
      }
      
      // US Regions array filter - for US region queries (Region column: 'NA - South', 'NA - West', etc.)
      if (args.regions && Array.isArray(args.regions) && args.regions.length > 0) {
        const regionConditions = args.regions.map((_: string, idx: number) => `"Region" LIKE @p${paramIndex + idx}`);
        filters.push(`(${regionConditions.join(' OR ')})`);
        args.regions.forEach((region: string) => params.push(`%${region}%`));
        paramIndex += args.regions.length;
        console.log(`[Filter] US Regions filter in {filters} (Region column): ${args.regions.join(', ')}`);
      }
      
      // Countries array filter - for country-specific queries (Country column)
      if (args.countries && Array.isArray(args.countries) && args.countries.length > 0) {
        const countryConditions = args.countries.map((_: string, idx: number) => `"Country" LIKE @p${paramIndex + idx}`);
        filters.push(`(${countryConditions.join(' OR ')})`);
        args.countries.forEach((country: string) => params.push(`%${country}%`));
        paramIndex += args.countries.length;
        console.log(`[Filter] Countries filter in {filters} (Country column): ${args.countries.join(', ')}`);
      }
      
      // State Lookup range filter (BETWEEN) - for numeric state lookup values
      if (args.state_lookup_min !== undefined && !isNaN(Number(args.state_lookup_min))) {
        filters.push(`CAST(NULLIF("State", '') AS NUMERIC) >= @p${paramIndex}`);
        params.push(Number(args.state_lookup_min));
        paramIndex++;
      }
      if (args.state_lookup_max !== undefined && !isNaN(Number(args.state_lookup_max))) {
        filters.push(`CAST(NULLIF("State", '') AS NUMERIC) <= @p${paramIndex}`);
        params.push(Number(args.state_lookup_max));
        paramIndex++;
      }

      if (args.is_updated !== undefined && args.is_updated !== null && args.is_updated !== '') {
        const normalized = String(args.is_updated).trim();
        if (normalized === '0' || normalized === '1') {
          filters.push(`"IsUpdated" = @p${paramIndex}`);
          params.push(normalized);
          paramIndex++;
        }
      }

      // Project Type filter - handles both single and multiple project types
      // NOTE: Removed _project_type_already_applied check - for follow-up queries where the function 
      // changes (e.g., from get_projects_by_project_type to get_projects_by_combined_filters),
      // we MUST still add the filter because the new template doesn't include it in its WHERE clause.
      if (args.project_types && Array.isArray(args.project_types) && args.project_types.length > 0) {
        // Multiple project types - use OR logic with LIKE for each
        const typeConditions = args.project_types.map((_: string, idx: number) => {
          return `"ProjectType" LIKE @p${paramIndex + idx}`;
        });
        filters.push(`(${typeConditions.join(' OR ')})`);
        args.project_types.forEach((type: string) => {
          params.push(`%${type}%`);
          paramIndex++;
        });
        console.log(`[Filter] Multiple Project Types in {filters}: ${args.project_types.join(', ')}`);
      } else if (args.project_type) {
        filters.push(`"ProjectType" LIKE @p${paramIndex}`);
        params.push(`%${args.project_type}%`);
        paramIndex++;
        console.log(`[Filter] Single Project Type in {filters}: ${args.project_type} (preserved: ${!!args._project_type_already_applied})`);
      }

      if (args.min_fee && !isNaN(Number(args.min_fee))) {
        filters.push(`CAST(NULLIF("Fee", '') AS NUMERIC) >= @p${paramIndex}`);
        params.push(Number(args.min_fee));
        paramIndex++;
      }

      if (args.max_fee && !isNaN(Number(args.max_fee))) {
        filters.push(`CAST(NULLIF("Fee", '') AS NUMERIC) <= @p${paramIndex}`);
        params.push(Number(args.max_fee));
        paramIndex++;
      }

      // Win percentage filters - use !== undefined/null to allow 0% values
      if (args.min_win !== undefined && args.min_win !== null && !isNaN(Number(args.min_win))) {
        filters.push(`CAST(NULLIF("ChanceOfSuccess", '') AS NUMERIC) >= @p${paramIndex}`);
        params.push(Number(args.min_win));
        paramIndex++;
      }

      if (args.max_win !== undefined && args.max_win !== null && !isNaN(Number(args.max_win))) {
        filters.push(`CAST(NULLIF("ChanceOfSuccess", '') AS NUMERIC) <= @p${paramIndex}`);
        params.push(Number(args.max_win));
        paramIndex++;
      }

      // Date range filters - handle start_date and end_date separately for flexibility
      if (args.start_date && args.end_date) {
        // Both dates provided - use range
        filters.push(
          `TRY_CONVERT(DATE, "ConstStartDate") >= @p${paramIndex} AND TRY_CONVERT(DATE, "ConstStartDate") <= @p${paramIndex + 1}`
        );
        params.push(args.start_date, args.end_date);
        paramIndex += 4;
        console.log(`[Filter] Date range: ${args.start_date} to ${args.end_date}`);
      } else if (args.start_date && !args.end_date) {
        // Only start_date - projects starting on or after this date
        filters.push(`TRY_CONVERT(DATE, "ConstStartDate") >= @p${paramIndex}`);
        params.push(args.start_date);
        paramIndex++;
        console.log(`[Filter] Start date (after): ${args.start_date}`);
      } else if (args.end_date && !args.start_date) {
        // Only end_date - projects starting on or before this date (e.g., "before 2026")
        filters.push(`TRY_CONVERT(DATE, "ConstStartDate") <= @p${paramIndex}`);
        params.push(args.end_date);
        paramIndex++;
        console.log(`[Filter] End date (before): ${args.end_date}`);
      }

      // Year filter: YEAR(TRY_CONVERT(DATE, "ConstStartDate")) = year
      // This is used for "this year", "in 2024", etc.
      if (args.year !== undefined && args.year !== null && !isNaN(Number(args.year))) {
        filters.push(`YEAR(TRY_CONVERT(DATE, "ConstStartDate")) = @p${paramIndex}`);
        params.push(Number(args.year));
        paramIndex++;
        console.log(`[Filter] Year filter in {filters}: ${args.year}`);
      }

      // Quarter filter: MONTH(ConstStartDate) IN (1,2,3) for Q1, (4,5,6) for Q2, etc.
      // This is used for "Q4 2026", "projects in Q3", etc.
      if (args.quarter !== undefined && args.quarter !== null && !isNaN(Number(args.quarter))) {
        const quarter = Number(args.quarter);
        if (quarter >= 1 && quarter <= 4) {
          const quarterMonths: Record<number, number[]> = {
            1: [1, 2, 3],    // Q1: Jan, Feb, Mar
            2: [4, 5, 6],    // Q2: Apr, May, Jun
            3: [7, 8, 9],    // Q3: Jul, Aug, Sep
            4: [10, 11, 12]  // Q4: Oct, Nov, Dec
          };
          const months = quarterMonths[quarter];
          filters.push(`MONTH(TRY_CONVERT(DATE, "ConstStartDate")) IN (${months.join(', ')})`);
          console.log(`[Filter] Quarter filter in {filters}: Q${quarter} â†’ months ${months.join(', ')}`);
        }
      }

      result = result.replace("{filters}", filters.length > 0 ? `AND ${filters.join(" AND ")}` : "");
    }

    // Handle tag conditions
    if (result.includes("{tag_conditions}")) {
      const tagFilters: string[] = [];
      
      // Handle tags array (preferred format)
      if (args.tags && Array.isArray(args.tags)) {
        for (const tag of args.tags) {
          // Tags filter removed - column not in database
          params.push(`%${tag}%`);
          paramIndex++;
        }
      } 
      // Fallback: handle individual tag1, tag2, etc. parameters
      else {
        for (let i = 1; i <= 5; i++) {
          if (args[`tag${i}`]) {
            // Tags filter removed - column not in database
            params.push(`%${args[`tag${i}`]}%`);
            paramIndex++;
          }
        }
      }
      
      // Use OR logic for tags (match ANY tag, not all)
      result = result.replace(
        "{tag_conditions}",
        tagFilters.length > 0 ? `AND (${tagFilters.join(" OR ")})` : ""
      );
    }

    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    // STATE FILTER (handles both single state and region/multiple states)
    // NOTE: Template uses WHERE {state_filter}, so NO "AND" prefix needed
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    if (result.includes("{state_filter}")) {
      if (args.exclude_states && Array.isArray(args.exclude_states) && args.exclude_states.length > 0) {
        // EXCLUDING states (for "except [region]" queries) - use AND with NOT LIKE
        const excludeStateConditions = args.exclude_states.map((_: string, idx: number) => `"State" NOT LIKE @p${paramIndex + idx}`);
        result = result.replace("{state_filter}", `(${excludeStateConditions.join(' AND ')})`);
        args.exclude_states.forEach((state: string) => params.push(state));
        paramIndex += args.exclude_states.length;
        console.log(`[buildSql] ğŸš« EXCLUDING Region: ${args.exclude_states.length} states (NOT LIKE)`);
      } else if (args.states && Array.isArray(args.states) && args.states.length > 0 && !(args.regions && Array.isArray(args.regions) && args.regions.length > 0)) {
        // Multiple states (region query) - use OR with LIKE for case-insensitivity
        const stateConditions = args.states.map((_: string, idx: number) => `"State" LIKE @p${paramIndex + idx}`);
        result = result.replace("{state_filter}", `(${stateConditions.join(' OR ')})`);
        args.states.forEach((state: string) => params.push(state));
        paramIndex += args.states.length;
        console.log(`[buildSql] ğŸŒ Region filter: ${args.states.length} states (case-insensitive)`);
      } else if (args.regions && Array.isArray(args.regions) && args.regions.length > 0) {
        // REGIONS filter (for "Region" column like "NA - East", "NA - West", etc.)
        const regionConditions = args.regions.map((_: string, idx: number) => `"Region" LIKE @p${paramIndex + idx}`);
        result = result.replace("{state_filter}", `(${regionConditions.join(' OR ')})`);
        args.regions.forEach((region: string) => params.push(`%${region}%`));
        paramIndex += args.regions.length;
        console.log(`[buildSql] REGION column filter: ${args.regions.length} regions (${args.regions.join(', ')})`);
      } else if (args.state_code) {
        // Single state - case-insensitive match
        result = result.replace("{state_filter}", `"State" LIKE @p${paramIndex}`);
        params.push(args.state_code);
        paramIndex++;
      } else {
        // No state/region filter - use 1=1 as placeholder to maintain valid SQL
        result = result.replace("{state_filter}", "1=1");
      }
    }

    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    // IMPORTANT: Process placeholders in the ORDER they appear in SQL templates!
    // Template: WHERE ... >= @p1 {max_fee_filter} {date_filter} {additional_filters}
    // So we MUST process {max_fee_filter} BEFORE {additional_filters}
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

    // Handle {max_fee_filter} FIRST (before additional_filters)
    if (result.includes("{max_fee_filter}")) {
      if (args.max_fee && !isNaN(Number(args.max_fee))) {
        result = result.replace("{max_fee_filter}", `AND CAST(NULLIF("Fee", '') AS NUMERIC) <= @p${paramIndex}`);
        params.push(Number(args.max_fee));
        paramIndex++;
      } else {
        result = result.replace("{max_fee_filter}", "");
      }
    }

    // Handle {max_win_filter} BEFORE additional_filters
    // CRITICAL: Use !== undefined instead of && to handle max_win=0 correctly
    if (result.includes("{max_win_filter}")) {
      if (args.max_win !== undefined && !isNaN(Number(args.max_win))) {
        result = result.replace("{max_win_filter}", `AND CAST(NULLIF("ChanceOfSuccess", '') AS NUMERIC) <= @p${paramIndex}`);
        params.push(Number(args.max_win));
        paramIndex++;
      } else {
        result = result.replace("{max_win_filter}", "");
      }
    }

    // Handle {min_win_clause} - for templates that need win% filtering in WHERE clause
    if (result.includes("{min_win_clause}")) {
      if (args.min_win !== undefined && !isNaN(Number(args.min_win))) {
        result = result.replace("{min_win_clause}", `AND CAST(NULLIF(REPLACE("ChanceOfSuccess", '%', ''), '') AS NUMERIC) >= @p${paramIndex}`);
        params.push(Number(args.min_win));
        paramIndex++;
      } else {
        result = result.replace("{min_win_clause}", "");
      }
    }

    // Handle {max_win_clause} - for templates that need win% filtering in WHERE clause
    if (result.includes("{max_win_clause}")) {
      if (args.max_win !== undefined && !isNaN(Number(args.max_win))) {
        result = result.replace("{max_win_clause}", `AND CAST(NULLIF(REPLACE("ChanceOfSuccess", '%', ''), '') AS NUMERIC) <= @p${paramIndex}`);
        params.push(Number(args.max_win));
        paramIndex++;
      } else {
        result = result.replace("{max_win_clause}", "");
      }
    }

    // Handle {category_clause} - for specialized templates like get_client_expansion_opportunities
    if (result.includes("{category_clause}")) {
      // Check all possible category parameter names: category, categories, categories_purchased
      const categoryValue = args.category || 
                           (args.categories && args.categories[0]) || 
                           (args.categories_purchased && args.categories_purchased[0]);
      if (categoryValue) {
        result = result.replace("{category_clause}", `AND "RequestCategory" LIKE @p${paramIndex}`);
        params.push(`%${categoryValue}%`);
        paramIndex++;
        console.log(`[buildSql] ğŸ“‚ Category clause: ${categoryValue}`);
      } else {
        result = result.replace("{category_clause}", "");
      }
    }

    // Handle {min_fee_clause} - for templates that need fee filtering in WHERE clause
    if (result.includes("{min_fee_clause}")) {
      if (args.min_fee && !isNaN(Number(args.min_fee))) {
        result = result.replace("{min_fee_clause}", `AND CAST(NULLIF("Fee", '') AS NUMERIC) >= @p${paramIndex}`);
        params.push(Number(args.min_fee));
        paramIndex++;
        console.log(`[buildSql] ğŸ’° Min fee clause: ${args.min_fee}`);
      } else {
        result = result.replace("{min_fee_clause}", "");
      }
    }

    // Handle {max_fee_clause} - for templates that need fee filtering in WHERE clause
    if (result.includes("{max_fee_clause}")) {
      if (args.max_fee && !isNaN(Number(args.max_fee))) {
        result = result.replace("{max_fee_clause}", `AND CAST(NULLIF("Fee", '') AS NUMERIC) <= @p${paramIndex}`);
        params.push(Number(args.max_fee));
        paramIndex++;
        console.log(`[buildSql] ğŸ’° Max fee clause: ${args.max_fee}`);
      } else {
        result = result.replace("{max_fee_clause}", "");
      }
    }

    // Handle {state_clause} - for templates that need state filtering in WHERE clause
    if (result.includes("{state_clause}")) {
      if (args.exclude_states && Array.isArray(args.exclude_states) && args.exclude_states.length > 0) {
        // EXCLUDING states (for "except [region]" queries) - use AND with NOT LIKE
        const excludeStateConditions = args.exclude_states.map((_: string, idx: number) => `"State" NOT LIKE @p${paramIndex + idx}`);
        result = result.replace("{state_clause}", `AND (${excludeStateConditions.join(' AND ')})`);
        args.exclude_states.forEach((state: string) => params.push(state));
        paramIndex += args.exclude_states.length;
        console.log(`[buildSql] ğŸš« EXCLUDING State clause: ${args.exclude_states.length} states (NOT LIKE)`);
      } else if (args.states && Array.isArray(args.states) && args.states.length > 0 && !(args.regions && Array.isArray(args.regions) && args.regions.length > 0)) {
        const stateConditions = args.states.map((_: string, idx: number) => `"State" LIKE @p${paramIndex + idx}`);
        result = result.replace("{state_clause}", `AND (${stateConditions.join(' OR ')})`);
        args.states.forEach((state: string) => params.push(state));
        paramIndex += args.states.length;
        console.log(`[buildSql] ğŸŒ State clause: ${args.states.length} states`);
      } else if (args.state_code) {
        result = result.replace("{state_clause}", `AND "State" LIKE @p${paramIndex}`);
        params.push(args.state_code);
        paramIndex++;
      } else {
        result = result.replace("{state_clause}", "");
      }
    }

    // Handle {status_clause} - for templates that need status filtering in WHERE clause
    if (result.includes("{status_clause}")) {
      if (args.status) {
        if (Array.isArray(args.status) && args.status.length > 0) {
          const statusConditions = args.status.map((status: string) => {
            const condition = `"StatusChoice" LIKE @p${paramIndex}`;
            params.push(`%${status}%`);
            paramIndex++;
            return condition;
          });
          result = result.replace("{status_clause}", `AND (${statusConditions.join(' OR ')})`);
          console.log(`[buildSql] ğŸ“Š Status clause (multiple): ${args.status}`);
        } else if (!Array.isArray(args.status)) {
          // Single status value (non-array string)
          result = result.replace("{status_clause}", `AND "StatusChoice" LIKE @p${paramIndex}`);
          params.push(`%${args.status}%`);
          paramIndex++;
          console.log(`[buildSql] ğŸ“Š Status clause (single): ${args.status}`);
        } else {
          // Empty array - no status clause
          result = result.replace("{status_clause}", "");
        }
      } else {
        result = result.replace("{status_clause}", "");
      }
    }

    // Handle {company_clause} - for templates that need company filtering in WHERE clause
    if (result.includes("{company_clause}")) {
      if (args.company) {
        result = result.replace("{company_clause}", `AND "Company" LIKE @p${paramIndex}`);
        params.push(`%${args.company}%`);
        paramIndex++;
        console.log(`[buildSql] ğŸ¢ Company clause: ${args.company}`);
      } else {
        result = result.replace("{company_clause}", "");
      }
    }

    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    // UNIVERSAL ADDITIONAL FILTERS (process AFTER max_fee_filter/max_win_filter)
    // This allows ANY query to accept follow-up filter refinements!
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    if (result.includes("{additional_filters}")) {
      // If ORIGINAL sql template has a {having_clause}, exclude min_win/max_win from WHERE clause
      // because they should ONLY be applied in the HAVING clause for aggregation queries
      // This fixes: "categories where average win% > 50" should not filter individual rows first
      // NOTE: We check the ORIGINAL sql, not result, because {having_clause} may have been replaced already
      let extendedExcludeParams = sql.includes("{having_clause}") 
        ? [...excludeParams, 'min_win', 'max_win']
        : [...excludeParams];
      
      // If ORIGINAL sql has {max_fee_filter}, exclude max_fee from additional_filters to prevent duplicate
      if (sql.includes("{max_fee_filter}")) {
        extendedExcludeParams.push('max_fee');
        console.log(`[buildSql] âœ“ Excluding max_fee from additional_filters (template has {max_fee_filter})`);
      }
      // If ORIGINAL sql has {max_win_filter}, exclude max_win from additional_filters
      if (sql.includes("{max_win_filter}")) {
        extendedExcludeParams.push('max_win');
      }
      // If ORIGINAL sql has {win_rate_filter}, exclude both min_win and max_win from additional_filters
      if (sql.includes("{win_rate_filter}")) {
        extendedExcludeParams.push('min_win', 'max_win');
        console.log(`[buildSql] âœ“ Excluding min_win/max_win from additional_filters (template has {win_rate_filter})`);
      }
      // If ORIGINAL sql has {min_win_clause} or {max_win_clause}, exclude from additional_filters
      if (sql.includes("{min_win_clause}")) {
        extendedExcludeParams.push('min_win');
        console.log(`[buildSql] âœ“ Excluding min_win from additional_filters (template has {min_win_clause})`);
      }
      if (sql.includes("{max_win_clause}")) {
        extendedExcludeParams.push('max_win');
        console.log(`[buildSql] âœ“ Excluding max_win from additional_filters (template has {max_win_clause})`);
      }
      // If ORIGINAL sql has {state_filter}, exclude state_code and states from additional_filters
      if (sql.includes("{state_filter}")) {
        extendedExcludeParams.push('state_code', 'states');
      }
      // If ORIGINAL sql has {status_filter}, exclude status from additional_filters to prevent duplicate
      if (sql.includes("{status_filter}")) {
        extendedExcludeParams.push('status');
        console.log(`[buildSql] âœ“ Excluding status from additional_filters (template has {status_filter})`);
      }
      
      // Pass excludeParams to avoid duplicating filters already in WHERE clause
      const additionalFilters = this.buildAdditionalFilters(args, params, paramIndex, extendedExcludeParams);
      if (args.regions && Array.isArray(args.regions) && args.regions.length > 0) { console.log(`[REGION_DEBUG] additionalFilters.sql = "${additionalFilters.sql}", params = ${JSON.stringify(params)}`); }
      result = result.replace("{additional_filters}", additionalFilters.sql);
      paramIndex = additionalFilters.nextIndex;
    }

    if (result.includes("{status_filter}")) {
      if (args.status) {
        if (Array.isArray(args.status) && args.status.length > 0) {
          // Handle multiple status values: (status LIKE val1 OR status LIKE val2)
          const statusConditions = args.status.map((status: string) => {
            const condition = `"StatusChoice" LIKE @p${paramIndex}`;
            params.push(`%${status}%`);
            paramIndex++;
            return condition;
          });
          result = result.replace("{status_filter}", `AND (${statusConditions.join(' OR ')})`);
        } else if (!Array.isArray(args.status)) {
          // Single status value
          result = result.replace("{status_filter}", `AND "StatusChoice" LIKE @p${paramIndex}`);
          params.push(`%${args.status}%`);
          paramIndex++;
        } else {
          // Empty array - no status filter
          result = result.replace("{status_filter}", "");
        }
      } else {
        result = result.replace("{status_filter}", "");
      }
    }

    // Special status filter for win prediction queries (get_top_predicted_wins)
    // This preserves context status if provided, otherwise uses default NOT IN ('Won', 'Lost')
    if (result.includes("{status_filter_for_wins}")) {
      if (args.status) {
        // Context has a status filter - preserve it!
        console.log(`[buildSql] ğŸ”’ Win prediction: Using context status filter: "${args.status}"`);
        if (Array.isArray(args.status) && args.status.length > 0) {
          // Handle multiple status values from context
          const statusConditions = args.status.map((status: string) => {
            const condition = `"StatusChoice" LIKE @p${paramIndex}`;
            params.push(`%${status}%`);
            paramIndex++;
            return condition;
          });
          result = result.replace("{status_filter_for_wins}", `(${statusConditions.join(' OR ')})`);
        } else if (!Array.isArray(args.status)) {
          // Single status value from context (non-array string)
          result = result.replace("{status_filter_for_wins}", `"StatusChoice" LIKE @p${paramIndex}`);
          params.push(`%${args.status}%`);
          paramIndex++;
        } else {
          // Empty array - use default NOT IN (Won, Lost)
          console.log(`[buildSql] ğŸ“Š Win prediction: Empty status array - using default NOT IN`);
          result = result.replace("{status_filter_for_wins}", `"StatusChoice" NOT IN ('Won', 'Lost')`);
        }
      } else {
        // No context status - use default "exclude won/lost" for prediction queries
        console.log(`[buildSql] ğŸ“Š Win prediction: Using default NOT IN ('Won', 'Lost')`);
        result = result.replace("{status_filter_for_wins}", `"StatusChoice" NOT IN ('Won', 'Lost')`);
      }
    }

    // Group by column for get_weighted_revenue_projection
    if (result.includes("{group_by_column}")) {
      const groupByMapping: Record<string, string> = {
        'status': '"StatusChoice"',
        'category': '"RequestCategory"',
        'company': '"Company"',
        'client': '"Client"',
        'poc': '"PointOfContact"',
        'state': '"State"',
        'project_type': '"ProjectType"',
      };
      const groupByKey = args.group_by?.toLowerCase() || 'status';
      const groupByColumn = groupByMapping[groupByKey] || '"StatusChoice"';
      result = result.replace(/{group_by_column}/g, groupByColumn);
    }

    // Year filter for compare_years template
    if (result.includes("{year_filter}")) {
      if (args.year1 && args.year2) {
        result = result.replace("{year_filter}", `AND YEAR(TRY_CONVERT(DATE, "ConstStartDate")) IN (@p${paramIndex}, @p${paramIndex + 1})`);
        params.push(args.year1, args.year2);
        paramIndex += 4;
      } else if (args.year1) {
        result = result.replace("{year_filter}", `AND YEAR(TRY_CONVERT(DATE, "ConstStartDate")) = @p${paramIndex}`);
        params.push(args.year1);
        paramIndex++;
      } else {
        // No year filter - show all years
        result = result.replace("{year_filter}", "");
      }
    }

    // Order by clause for compare_years template
    if (result.includes("{order_by}")) {
      const statusValue = Array.isArray(args.status) ? args.status[0] : args.status;
      if (statusValue && typeof statusValue === 'string' && statusValue.toLowerCase().includes("won")) {
        // If status is "won", order by won_count descending
        result = result.replace("{order_by}", "won_count DESC, year DESC");
      } else if (args.status) {
        // If other status, order by project_count descending
        result = result.replace("{order_by}", "project_count DESC, year DESC");
      } else {
        // Default: order by year
        result = result.replace("{order_by}", "year DESC");
      }
    }

    // PID filters for get_project_by_id - range takes priority over single project
    if (result.includes("{pid_range_filter}") || result.includes("{pid_single_filter}")) {
      const hasRange = args.pid_start !== undefined && args.pid_end !== undefined;
      const hasSingle = args.project_name !== undefined && args.project_name !== '';
      
      if (hasRange) {
        // Range query takes priority - ONLY use range, ignore single project_name
        // Use PATINDEX to find first digit, then SUBSTRING to extract numeric portion
        result = result.replace("{pid_single_filter}", "");
        result = result.replace("{pid_range_filter}", `
          TRY_CAST(SUBSTRING("Title", PATINDEX('%[0-9]%', "Title"), LEN("Title")) AS INT) >= @p${paramIndex}
          AND TRY_CAST(SUBSTRING("Title", PATINDEX('%[0-9]%', "Title"), LEN("Title")) AS INT) <= @p${paramIndex + 1}
        `);
        params.push(args.pid_start, args.pid_end);
        paramIndex += 4;
      } else if (hasSingle) {
        // Single project lookup
        result = result.replace("{pid_single_filter}", `
          REPLACE(CAST("Title" AS NVARCHAR(MAX)), ' ', '') LIKE REPLACE(@p${paramIndex}, ' ', '')
          OR REPLACE(CAST("InternalId" AS NVARCHAR(MAX)), ' ', '') LIKE REPLACE(@p${paramIndex}, ' ', '')
        `);
        result = result.replace("{pid_range_filter}", "");
        params.push(`%${args.project_name}%`);
        paramIndex++;
      } else {
        // Neither provided - return all (fallback)
        result = result.replace("{pid_single_filter}", "1=1");
        result = result.replace("{pid_range_filter}", "");
      }
    }

    // Add positional parameters at the END (after dynamic params)
    // This must happen AFTER all dynamic parameter processing above
    // Note: params array already contains dynamic params, so we check for missing template params
    return result;
  }

  private generateChartConfig(data: any[], functionName: string): ChartConfig | null {
    if (!data || data.length === 0) return null;

    const template = this.queryTemplates[functionName];
    if (!template) return null;

    const chartType = template.chart_type;
    const chartField = template.chart_field || "Fee";

    try {
      if (chartType === "bar" || chartType === "line") {
        const limitedData = data.slice(0, 20);
        const labels: string[] = [];
        const values: number[] = [];

        for (const item of limitedData) {
          let label = "Item";
          // Check common grouping fields first (aggregation queries)
          // Division fields - IMPORTANT for division breakdown charts
          if (item["Division"]) {
            label = String(item["Division"]).trim();
          } else if (item["division"]) {
            label = String(item["division"]).trim();
          // Department fields
          } else if (item["Department"]) {
            label = String(item["Department"]).trim();
          } else if (item["department"]) {
            label = String(item["department"]).trim();
          // Category fields
          } else if (item["Category"]) {
            label = String(item["Category"]).trim();
          } else if (item["RequestCategory"]) {
            label = String(item["RequestCategory"]).trim();
          } else if (item["request_category"]) {
            label = String(item["request_category"]).trim();
          } else if (item["category"]) {
            label = String(item["category"]).trim();
          } else if (item["ProjectType"]) {
            label = String(item["ProjectType"]).trim();
          } else if (item["project_type"]) {
            label = String(item["project_type"]).trim();
          } else if (item["State"]) {
            label = String(item["State"]).trim();
          } else if (item["state"]) {
            label = String(item["state"]).trim();
          } else if (item["Client"]) {
            label = String(item["Client"]).trim();
          } else if (item["client"]) {
            label = String(item["client"]).trim();
          } else if (item["PointOfContact"]) {
            label = String(item["PointOfContact"]).trim();
          } else if (item["poc"]) {
            label = String(item["poc"]).trim();
          } else if (item["Title"]) {
            label = String(item["Title"]).substring(0, 30);
          } else if (item["Company"]) {
            label = item["Company"];
          } else if (item["tag"]) {
            label = String(item["tag"]).trim();
          } else if (item["StatusChoice"]) {
            label = item["StatusChoice"];
          } else if (item["status"]) {
            label = String(item["status"]).trim();
          } else if (item["size_tier"]) {
            label = item["size_tier"];
          } else if (item["year"]) {
            label = String(item["year"]);
          } else if (item["month"]) {
            label = String(item["month"]);
          } else if (item["quarter"]) {
            label = String(item["quarter"]);
          } else if (item["period"]) {
            label = String(item["period"]);
          }

          labels.push(label);

          const value = item[chartField] || item["Fee"] || 0;
          values.push(parseFloat(String(value)) || 0);
        }

        return {
          type: chartType,
          title: `Top ${limitedData.length} Results`,
          labels,
          datasets: [
            {
              label: chartField,
              data: values,
              backgroundColor: "rgba(54, 162, 235, 0.6)",
              borderColor: "rgba(54, 162, 235, 1)",
              borderWidth: 1,
            },
          ],
        };
      } else if (chartType === "pie") {
        const labels: string[] = [];
        const values: number[] = [];

        for (const item of data) {
          let label = "Category";
          // Division fields
          if (item["Division"]) {
            label = String(item["Division"]).trim();
          } else if (item["division"]) {
            label = String(item["division"]).trim();
          // Department fields
          } else if (item["Department"]) {
            label = String(item["Department"]).trim();
          } else if (item["department"]) {
            label = String(item["department"]).trim();
          // Category fields
          } else if (item["Category"]) {
            label = String(item["Category"]).trim();
          } else if (item["RequestCategory"]) {
            label = String(item["RequestCategory"]).trim();
          } else if (item["request_category"]) {
            label = String(item["request_category"]).trim();
          } else if (item["category"]) {
            label = String(item["category"]).trim();
          } else if (item["ProjectType"]) {
            label = String(item["ProjectType"]).trim();
          } else if (item["StatusChoice"]) {
            label = item["StatusChoice"];
          } else if (item["status"]) {
            label = String(item["status"]).trim();
          } else if (item["size_tier"]) {
            label = item["size_tier"];
          } else if (item["Company"]) {
            label = item["Company"];
          } else if (item["Client"]) {
            label = item["Client"];
          } else if (item["State"]) {
            label = String(item["State"]).trim();
          } else if (item["state"]) {
            label = String(item["state"]).trim();
          } else if (item["year"]) {
            label = String(item["year"]);
          } else if (item["month"]) {
            label = String(item["month"]);
          } else if (item["quarter"]) {
            label = String(item["quarter"]);
          }
          labels.push(label);

          const value = item[chartField] || 1;
          values.push(parseFloat(String(value)) || 1);
        }

        return {
          type: "pie",
          title: "Distribution",
          labels,
          datasets: [
            {
              data: values,
              backgroundColor: [
                "rgba(255, 99, 132, 0.6)",
                "rgba(54, 162, 235, 0.6)",
                "rgba(255, 206, 86, 0.6)",
                "rgba(75, 192, 192, 0.6)",
                "rgba(153, 102, 255, 0.6)",
                "rgba(255, 159, 64, 0.6)",
                "rgba(199, 199, 199, 0.6)",
                "rgba(83, 102, 255, 0.6)",
                "rgba(255, 99, 255, 0.6)",
                "rgba(99, 255, 132, 0.6)",
              ],
            },
          ],
        };
      }

      return null;
    } catch (error) {
      console.error("Error generating chart config:", error);
      return null;
    }
  }

  private calculateSummaryStats(data: any[]): SummaryStats {
    if (!data || data.length === 0) return {};

    const stats: SummaryStats = {
      total_records: data.length,
    };

    // Fee statistics
    const fees: number[] = [];
    for (const item of data) {
      if (item["Fee"]) {
        const fee = parseFloat(String(item["Fee"]));
        if (!isNaN(fee)) fees.push(fee);
      }
    }

    if (fees.length > 0) {
      stats.total_value = fees.reduce((a, b) => a + b, 0);
      stats.avg_fee = stats.total_value / fees.length;
      stats.median_fee = fees.sort((a, b) => a - b)[Math.floor(fees.length / 2)];
      stats.min_fee = Math.min(...fees);
      stats.max_fee = Math.max(...fees);
    }

    // Win rate statistics
    const winRates: number[] = [];
    for (const item of data) {
      const winField = item["ChanceOfSuccess"] || item["Win_Percentage"];
      if (winField) {
        const winRate = parseFloat(String(winField));
        if (!isNaN(winRate)) winRates.push(winRate);
      }
    }

    if (winRates.length > 0) {
      stats.avg_win_rate = winRates.reduce((a, b) => a + b, 0) / winRates.length;
    }

    // Status breakdown
    const statusCounts: Record<string, number> = {};
    for (const item of data) {
      if (item["StatusChoice"]) {
        const status = item["StatusChoice"];
        statusCounts[status] = (statusCounts[status] || 0) + 1;
      }
    }

    if (Object.keys(statusCounts).length > 0) {
      stats.status_breakdown = statusCounts;
    }

    // Company breakdown
    const companyCounts: Record<string, number> = {};
    for (const item of data) {
      if (item["Company"]) {
        const company = item["Company"];
        companyCounts[company] = (companyCounts[company] || 0) + 1;
      }
    }

    if (Object.keys(companyCounts).length > 0) {
      const sorted = Object.entries(companyCounts)
        .sort((a, b) => b[1] - a[1])
        .slice(0, 5);
      stats.top_companies = Object.fromEntries(sorted);
    }

    return stats;
  }
}
// Reload trigger Sun Jan 18 10:17:18 AM UTC 2026
// trigger 1768731559
// Force reload 1768731662
// final reload 1768731732
// reload 1768732418
// reload 1768733258



